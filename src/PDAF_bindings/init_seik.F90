!$Id: init_seik.F90 75 2019-02-03 17:47:58Z lnerger $
!BOP
!
! !ROUTINE: init_seik --- Initialize ensemble
!
! !INTERFACE:
SUBROUTINE init_seik(filtertype, dim_p, dim_ens, state_p, Uinv, &
     ens_p, flag)

! !DESCRIPTION:
! User-supplied routine for PDAF.
! Used in the filters: SEIK/LSEIK/ETKF/LETKF/ESTKF/LESTKF
!
! The routine is called when the filter is
! initialized in PDAF\_filter\_init.  
!
! This template shows how the ensemble of dim\_ens 
! states can be initializated by exact 2nd order 
! sampling.  State vectors of the form
!   $x_i = x + sqrt(FAC) eofV (\Omega C^{-1})^T$
! fulfill the condition
!   $P = 1/(FAC)  \sum_{i=1}^{dim\_ens} (x_i - x)(x_i - x)^T$
! The matrix is initialized in the form of
! singular values and singular vectors.
!
! The routine is called by all filter processes and 
! initializes the ensemble for the local domain.
!
! !REVISION HISTORY:
! 2004-10 - Lars Nerger - Initial code
! Later revisions - see svn log
!
! !USES:
  IMPLICIT NONE

! !ARGUMENTS:
  INTEGER, INTENT(in) :: filtertype              ! Type of filter to initialize
  INTEGER, INTENT(in) :: dim_p                   ! PE-local state dimension
  INTEGER, INTENT(in) :: dim_ens                 ! Size of ensemble
  REAL, INTENT(out)   :: state_p(dim_p)          ! PE-local model state
  REAL, INTENT(out)   :: Uinv(dim_ens-1,dim_ens-1) ! Array not referenced for SEIK
  REAL, INTENT(out)   :: ens_p(dim_p, dim_ens)   ! PE-local state ensemble
  INTEGER, INTENT(inout) :: flag                 ! PDAF status flag

! !CALLING SEQUENCE:
! Called by: PDAF_filter_init    (as U_ens_init)
! Calls: PDAF_sampleens
! Calls: dgemm (BLAS)
! Calls: MPI_send 
! Calls: MPI_recv
!EOP

! *** local variables ***
  INTEGER :: i, row, col              ! counters
  INTEGER, SAVE :: allocflag = 0      ! Flag for memory counting
  REAL, ALLOCATABLE :: ens(:,:)       ! global ensemble
  REAL, ALLOCATABLE :: state(:)       ! global state vector
  REAL, ALLOCATABLE :: eofV(:,:)      ! matrix of eigenvectors V 
  REAL, ALLOCATABLE :: svals(:)       ! singular values
  INTEGER :: rank     ! Rank of approximated covariance matrix
  REAL :: fac         ! Square-root of dim_ens-1 or dim_ens
  ! variables and arrays for domain decomposition
  INTEGER :: offset   ! Row-offset according to domain decomposition
  INTEGER :: domain   ! domain counter
  REAL,ALLOCATABLE :: ens_p_tmp(:,:) ! Temporary ensemble for some PE-domain
  REAL,ALLOCATABLE :: state_p_tmp(:) ! Temporary state vector for some PE-domain


! **********************
! *** INITIALIZATION ***
! **********************

  ! *** Rank of matrix is ensemble size minus one
  rank = dim_ens - 1
  
  ! *** Generate full ensemble on filter-PE 0 ***
!   mype0: IF (mype_filter == 0) THEN
!      WRITE (*, '(/9x, a)') 'Generate state ensemble from covariance matrix'
!      WRITE (*, '(9x, a)') &
!           '--- use rank reduction and 2nd order exact sampling (SEIK type)'
!      WRITE (*, '(9x, a, i5)') '--- Ensemble size:  ', dim_ens
!      WRITE (*, '(9x, a, i5)') '--- number of EOFs: ', rank

     ! allocate memory for temporary fields
!      ALLOCATE(eofV(dim_state, rank))
!      ALLOCATE(svals(rank))


! *************************************************
! *** Initialize initial state and covar matrix ***
! *************************************************

  ! We show an example here, in which the ensemble is
  ! generated by second-order exact sampling from a 
  ! state estimate together with an error estimate 
  ! based on singular values and vectors. The full ensemble
  ! is first generated on process 0 only. Subsequently the
  ! ensemble sub-states are distributed.

  ! For this initialization, the mean state, the singular 
  ! values, and the singluar vectors have to be initialized
   
     ! Allocate global ensemble and state
!      ALLOCATE(ens(dim_state, dim_ens))
!      ALLOCATE(state(dim_state))

!   state(:) = ??
!   svals(1:rank) = ??
!   eofV(:,:) = ??


! *****************************************************
! *** DECOMPOSE COVARIANCE                          ***
! ***                                               ***
! *** P = eofV U eofV^T                             ***
! ***   = eofV C^(-1)^T Omega^T Omega C^(-1) eofV^T ***
! *** where U^(-1) = C C^T                          ***
! ***                                               ***
! *** Since the matrix is already initialized in    ***
! *** decomposed form we directly have the          ***
! *** inverses of C given by the singular values    ***
! *****************************************************


! *************************************************
! *** Generate ensemble of interpolating states ***
! *************************************************

     ! Very simple method here: We generate the full 
     ! ensemble on the filter PE with rank 0. Afterwards
     ! we distribute sub-states to other filter PEs

     WRITE (*, '(9x, a)') '--- generate ensemble of model states'

     ! Generate ensemble using PDAF sampling routine
!      CALL PDAF_SampleEns(dim_state, dim_ens, eofV, svals, state, &
!           ens, flag)
  

! ****************************
! *** Distribute substates ***
! ****************************

!   mype0b: IF (mype_filter == 0) THEN
     ! *** Initialize and send sub-state on PE 0 ***

     offset = 0

!      DO domain = 1, npes_filter
      
!         whichdomain: IF (domain == 1) THEN
           ! Initialize sub-state and sub_ensemble for PE 0

           ! perform reordering of mode matrix for PE 0
!            DO col = 1, dim_ens
!               DO i=1, local_dims(1)
!                  ens_p(i, col) = ens(i, col)
!               END DO
!            END DO
           ! perform reordering of state for PE 0
!            DO i = 1, local_dims(1)
!               state_p(i) = state(i)
!            END DO
    
!         ELSE whichdomain
           ! Initialize sub-state and sub_ensemble for other PEs
           ! and send sub-arrays

           ! allocate temporary sub-arrays
!            ALLOCATE(ens_p_tmp(local_dims(domain), dim_ens))
!            ALLOCATE(state_p_tmp(local_dims(domain)))

           ! perform reordering of mode matrix
!            DO col = 1, dim_ens
!               DO i = 1, local_dims(domain)
!                  ens_p_tmp(i, col) = ens(i + offset, col)
!               END DO
!            END DO
           ! perform reordering of state
!            DO i = 1, local_dims(domain)
!               state_p_tmp(i) = state(i + offset)
!            END DO

           ! Send sub-arrays
!            CALL MPI_send(ens_p_tmp, dim_ens * local_dims(domain), &
!                 MPI_DOUBLE_PRECISION, domain - 1, 1, COMM_filter, MPIerr)
!            CALL MPI_send(state_p_tmp, local_dims(domain), &
!                 MPI_DOUBLE_PRECISION, domain - 1, 2, COMM_filter, MPIerr)
! 
!            DEALLOCATE(ens_p_tmp, state_p_tmp)

!         END IF whichdomain

        ! Increment offset
!         offset = offset + local_dims(domain)

!      END DO

!   ELSE mype0b
     ! *** Receive substate on filter-PEs with rank > 0 ***

!      CALL MPI_recv(ens_p, dim_p * dim_ens, MPI_DOUBLE_PRECISION, &
!           0, 1, COMM_filter, MPIstatus, MPIerr)
!      CALL MPI_recv(state_p, dim_p, MPI_DOUBLE_PRECISION, &
!           0, 2, COMM_filter, MPIstatus, MPIerr)
     
!   END IF mype0b


! ****************
! *** clean up ***
! ****************

!   IF (mype_filter == 0) THEN
!      DEALLOCATE(svals, eofV)
!      DEALLOCATE(ens, state)
!   END IF

END SUBROUTINE init_seik

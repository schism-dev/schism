import numpy as np
import netCDF4 as nc
import os
import datetime
import argparse
######################################
# model time range from param.nml

######################################
# model time range from param.nml
parser = argparse.ArgumentParser(description='''Download and process GLOFAS forecast for source_sink files, uses preprocessed glofas location information.
      ''')
parser.add_argument(dest='glofasdir', type=str, help='location of preproc-glofas.npz')
parser.add_argument(dest='outdir', type=str, help='location to write source_sink files')
parser.add_argument('-s','--startdate',dest='startdate', default=None,type=str, help='run start YYYY-MM-DD, defaults to today')
parser.add_argument('-r','--rndays',dest='rnday', default=5, type=int, help='length of run in days')
parser.add_argument(dest='glofasfiles', type=str, help='glofas forecast files, comma separated list to allow composites across separate downloads')
parser.add_argument('-p','--plotbounds',dest='plotbounds',type=str, default='Columbia:235.5,238,44.5,47.5;VancIs:231,237,48.25,52.1',help='regions for sanity-check plots, only used if imagedir specified, format is "name1:minx,maxx,miny,maxy;name2...";')
parser.add_argument('-i','--imagedir',dest='imagedir', type=str, default=None, help='location to place sanity check images, no images generated by default or if matplotlib is unavialable')
parser.add_argument('-t','--tag',dest='tag', type=str, default='', help='suffix for static npz filename and output image name prefix, defaults to empty string, mainly useful for testing')
args = parser.parse_args()
glofasdir = args.glofasdir # location of preproc-glofas.npz
glofasfiles = args.glofasfiles.split(',') # glofas download data
outdir = args.outdir # source_sink files written here
#param = pl.read(paramfile)
#modelstartdate = datetime.datetime(int(param['start_year']), int(param['start_month']),int(param['start_day']))
#rnday = int(param['rnday'])
if args.startdate is not None:
   mdate = [int(x) for x  in args.startdate.split('-')]
else:
   now = datetime.datetime.now()
   mdate = [now.year,now.month,now.day]
modelstartdate = datetime.datetime(mdate[0],mdate[1],mdate[2])
rnday = args.rnday
modelenddate = modelstartdate + datetime.timedelta(days=rnday)
imagedir = args.imagedir # optional images written here if location is provided
if imagedir is None:
    processplot = False
else:
    processplot = True

tag = args.tag

# plotting areas for sanity checks
#plotbounds = {'Columbia':[235.5,238,44.5,47.5],'VancIs':[231,237, 48.25, 52.1]}
#plotarea = 'VancIs'
plotbounds = {}
if processplot:
   try:
      import matplotlib.pyplot as plt
      for bstr in args.plotbounds.split(';'):
         name, bndstr = bstr.split(':')
         plotbounds[name] = np.array([float(x) for x in bndstr.split(',')])
   except ModuleNotFoundError:
      print('matplotlib not available, no plots will be generated')
      processplot = False
      plotbounds = {}

preproc = np.load(os.path.join(glofasdir,f'glofas_prep{tag}.npz'))
Erivers=preproc["Erivers"];idxs=preproc["idxs"];ind0N=preproc["ind0N"];ind1N=preproc["ind1N"]; lonN=preproc["lonN"];latN=preproc["latN"];lon=preproc["lon"];lat=preproc["lat"];areaN=preproc["areaN"];final=preproc["final"]
xctr = preproc["xctr"]
yctr= preproc["yctr"]
elnode = preproc["elnode"]
ne = preproc["ne"]
uniqErivers=preproc['uniqErivers']
singles=preproc['singles']
uniqEriversInd=preproc['uniqEriversInd'] 
dups=preproc['dups']

# read in spatial subsets of GLOFAS data
riverCoordsSubset = np.zeros((Erivers.shape[0],2))
discharge = None # set after reading first file and determining length of times
if glofasfiles is None:
   try:
     import cdsapi
   except ModuleNotFoundError as e:
     raise ModuleNotFoundError('cdsapi not available, please download glofas separately and specify datafile at command line') from e
   bnds = [np.malonN(latN)+0.1,np.min(lonN)-0.1,np.min(latN)-0.1,np.malonN(lonN)+0.1]
   # download GLOFAS forecast data
   dataset = "cems-glofas-forecast"
   request = {
     "system_version": ["operational"],
     "hydrological_model": ["lisflood"],
     "product_type": ["control_forecast"],
     "variable": "river_discharge_in_the_last_24_hours",
     "year": [mdate[0]],
     "month": [mdate[1]],
     "day": [mdate[2]],
     "leadtime_hour": [ '%s' % (24*d) for d in range(1,rnday+1)
     ],
     "data_format": "netcdf",
     "download_format": "unarchived",
     "area": bnds
   }
   fname = os.path.join(outdir,'GLOFAS-today-full.nc')
   client = cdsapi.Client(url='https://ewds.climate.copernicus.eu/api')
   req = client.retrieve(dataset, request, fname)
   glofasfiles = [fname] 

for fname in glofasfiles:
   ncid = nc.Dataset(fname)
   p0 = np.searchsorted(lat, ncid.variables['latitude'][0], sorter=np.arange(len(lat)-1, -1, -1)) + 1 # lat is in decreasing order
   p1 = np.searchsorted(lon, ncid.variables['longitude'][0]) -1
   print(p0,p1,lon,lat,ncid.variables['latitude'][0], ncid.variables['longitude'][0] )
   ind0N_sub = ind0N - (len(lat)-p0)
   ind1N_sub = ind1N -p1
   g = np.where(np.logical_and.reduce((ind0N_sub>=0, ind1N_sub>=0, ind0N_sub < ncid.variables['latitude'].shape[0], ind1N_sub < ncid.variables['longitude'].shape[0])))[0]
   print(f'found {g.shape} locations in area, out of {ind0N.shape}')
   Rlon = ncid.variables['longitude'][ind1N_sub[g]]
   Rlat = ncid.variables['latitude'][ind0N_sub[g]]
   riverCoordsSubset[g,:] = np.c_[Rlon,Rlat]
   T = ncid.variables['valid_time'][:]
   time_units = ncid.variables['valid_time'].units
   try:
      GLOFASstart = datetime.datetime.strptime(time_units,'seconds since %Y-%m-%dT%H:%M:%S')
   except:
      GLOFASstart = datetime.datetime.strptime(time_units,'seconds since %Y-%m-%d')
   GLOFASreftime = ncid.variables['forecast_reference_time'][0]
   relmodstart = (modelstartdate - GLOFASstart).total_seconds()
   relmodend = (modelenddate - GLOFASstart).total_seconds()
   if len(T.shape)>0:
      timeind = np.argwhere(np.logical_and(T>=relmodstart,T<=relmodend)).ravel()
      T = T[timeind]-relmodstart
   else:
      timeind = np.array([0])
      T = np.array([T.data-relmodstart])
   discharge = np.zeros((timeind.shape[0],ind0N.shape[0])) * np.nan
   dis24 = ncid.variables['dis24'][timeind,0,:,:]
   for i in g:
     discharge[:,i] = dis24[:,ind0N_sub[i],ind1N_sub[i]]

while T[0] > 0:
   T = np.r_[T[0]-86400,T]
   discharge = np.r_[discharge[0,:][np.newaxis,:], discharge]
   print(f'WARNING: mismatch between start of GloFAS data and run starttime, padding start of files with first available GloFAS data.')
while T[-1] < relmodend-relmodstart:
   T = np.r_[T,T[-1]+86400]
   discharge = np.r_[discharge,discharge[-1,:][np.newaxis,:]]
   print(f'WARNING: mismatch between end of GloFAS data and run endtime, padding end of files with last available GloFAS data.')
maxdischarge = np.max(discharge,axis=0)
# test plot showing successful alignment of main grid and subgrid methods
for plotarea in plotbounds.keys():
  f,ax = plt.subplots(1,1)
  ax.plot(riverCoordsSubset[:,0],riverCoordsSubset[:,1],'+m')
  c = ax.scatter(lonN,latN,np.log2(areaN)*8,np.log10(areaN))
  plt.colorbar(c,label='log2 watershed area')
  ax.axis(plotbounds[plotarea])
  f.savefig(os.path.join(imagedir,f'glofas_{plotarea}_{tag}_watershedarea.png'))
  f,ax = plt.subplots(1,1)
  ax.plot(riverCoordsSubset[:,0],riverCoordsSubset[:,1],'+m')
  c = ax.scatter(lonN,latN,np.log2(maxdischarge)*8,np.log10(maxdischarge))
  plt.colorbar(c,label='log2 discharge')
  ax.plot(xctr[Erivers],yctr[Erivers],'kd')
  ax.axis(plotbounds[plotarea])
  f.savefig(os.path.join(imagedir,f'glofas_{plotarea}_{tag}_end.png'))
  dx = [1,10, 100,500,1e6]
  cs = ['y','c','g','b','r']
  plt.close(f)
  f,ax = plt.subplots(1,1)
  for i in range(len(dx)-1):
     gb =  np.logical_and.reduce((g,areaN>=dx[i], areaN<dx[i+1]))
     ax.plot(T/86400,np.sum(discharge[:,gb],axis=1),c=cs[i],label=f'{dx[i]} - {dx[i+1]}')
  ax.legend(title=f'discharge range in {plotarea}')
  ax.set_xlabel('days')
  ax.set_ylabel('Q (m^3/s)')
  f.savefig(os.path.join(imagedir,f'glofas_{plotarea}_{tag}_discharge_by_area.png'))
  plt.close(f)
  f,ax = plt.subplots(1,1)
  for i in range(len(dx)-1):
     gb =  np.logical_and.reduce((g,areaN>=dx[i], areaN<dx[i+1]))
     ax.plot(np.sum(areaN[gb]),np.max(np.sum(discharge[:,gb],axis=1)),c=cs[i],label=f'{dx[i]} - {dx[i+1]}',marker='.')
  ax.legend(title=f'discharge range in {plotarea}')
  ax.set_xlabel('area (km)')
  ax.set_ylabel('max Q (m^3/s)')
  f.savefig(os.path.join(imagedir,f'glofas_{plotarea}_{tag}_mxdischarge_vs_area.png'))


# merge river values from duplicate elements
dischargeE = np.zeros((discharge.shape[0],uniqErivers.shape[0]))
dischargeE[:,singles] = discharge[:,uniqEriversInd[singles]]
for d in dups:
   ind = np.where(Erivers == uniqErivers[d])[0]
   for i in ind:
       dischargeE[:,d] += discharge[:,i]

empty = np.unique(np.argwhere(np.isnan(dischargeE))[:,1])
if empty.shape[0]>0:
   # write vsource.bp as sanity check
  props = np.zeros((empty.shape[0],4))
  props[:,0] = np.arange(empty.shape[0])+1
  props[:,1:3] = np.c_[xctr[uniqErivers[empty]],yctr[uniqErivers[empty]]]
  with open(os.path.join(outdir,f'{tag}empty_rivers.bp'),'w') as f:
    f.write('GLOFAS river locations not covered in data files\n%s\n' % props.shape[0])
    np.savetxt(f,props,fmt='%d %.8f %.8f %.1f')
  dischargeE[:,empty] = 0  # fill missing rivers with 0 flow to avoid null values in .th files

# write output files containing 1-indexed list of elements source_sink.in, source_sink.prop file, and source_sink.bp file (2nd and 3rd for testing)
with open(os.path.join(outdir,f'{tag}source_sink.in'),'w') as f:
  f.write('%d\n' % len(uniqErivers))
  np.savetxt(f,uniqErivers+1,fmt='%d')
  f.write('\n')
  f.write('0\n')

# write vsource.th from discharge and valid_time (converted to seconds since start of run)
vsource = np.c_[T,dischargeE]
with open(os.path.join(outdir,f'{tag}vsource.th'),'w') as f:
  np.savetxt(f,vsource)

# write msource.th from discharge and valid_time (converted to seconds since start of run)
salval = 0 
msource = np.c_[T,dischargeE*0+salval,dischargeE[:,1:]*0-999]
with open(os.path.join(outdir,f'{tag}msource.th'),'w') as f:
  np.savetxt(f,msource)

# write vsource.prop as sanity check
props = np.zeros((ne,2),dtype = int)
props[:,0] = np.arange(ne)+1
props[uniqErivers,1] = (np.round(np.max(dischargeE,axis=0))).astype(int)
with open(os.path.join(outdir,f'{tag}vsource.prop'),'w') as f:
  np.savetxt(f,props,fmt='%d')

# write vsource.bp as sanity check
props = np.zeros((len(uniqErivers),4))
props[:,0] = np.arange(len(uniqErivers))+1
props[:,1:3] = np.c_[xctr[uniqErivers],yctr[uniqErivers]]
props[:,3] = np.max(dischargeE,axis=0)
with open(os.path.join(outdir,f'{tag}vsource.bp'),'w') as f:
  f.write('GLOFAS river locations\n%s\n' % props.shape[0])
  np.savetxt(f,props,fmt='%d %.8f %.8f %.1f')

xuniq = xctr[uniqErivers]
yuniq = yctr[uniqErivers]
if processplot:
  vanc = np.where(np.logical_and.reduce((xuniq < plotbounds[plotarea][0],xuniq>plotbounds[plotarea][1], yuniq >plotbounds[plotarea][2], yuniq < plotbounds[plotarea][3])))[0]
  f,ax = plt.subplots(1,1)
  ax.plot(T,dischargeE[:,vanc],c='grey')
  ax.set_title(f'GLOFAS discharge around {plotarea}')
  f.savefig(os.path.join(imagedir,f'glofas_{plotarea}_{tag}_tseries.png'))
  plt.close(f)

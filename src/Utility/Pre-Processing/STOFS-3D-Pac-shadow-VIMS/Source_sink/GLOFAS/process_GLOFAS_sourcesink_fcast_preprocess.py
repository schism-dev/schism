import geopandas
import shapely as shl
import pylib as pl
import numpy as np
import rasterio as ras
import rasterio.features as rasfeat
import rasterio.plot as rasplot
import netCDF4 as nc
import scipy.ndimage as ndimage
from scipy.spatial import cKDTree
import matplotlib.pyplot as plt
import os
import datetime as dt
import sys
import argparse
parser = argparse.ArgumentParser(description='''Pre-process GLOFAS static files to generate a static setup file for GLOFAS download processing for source_sink files.''')
parser.add_argument(dest='glofasdir', type=str, help='location of uparea_glofas_v4_0.nc and hydroMESH shapefile')
parser.add_argument(dest='rundir', type=str, help='location of hgrid.gr3 or hgrid.npz')
parser.add_argument(dest='outdir', type=str, help='location to write static preprocessing file')
parser.add_argument('-t','--tag',dest='tag', type=str, default = None, help='identifier (combined with minarea) appended to output image and filenames, left blank by default')
parser.add_argument('-r','--regions',dest='regfiles', type=str, default = None, help='comma separated list of region files representing areas where glofas should not be used, always uses three hardcoded regions in addition to ones specified here. files should be in glofasdir')
parser.add_argument('-a','--minarea',dest='minarea', type=float, default = 500.0, help='minimum wateshed areas to convert to sources, defaults to 500')
parser.add_argument('-i','--imagedir',dest='imagedir', type=str, default=None, help='location to place sanity check images, no images generated by default')
parser.add_argument('-p','--plotbounds',dest='plotbounds',type=str, default='Columbia:235.5,238,44.5,47.5;VancIs:231,237,48.25,52.1',help='regions for sanity-check plots, only used if imagedir specified, format is "name1:minx,maxx,miny,maxy;name2...";')
args = parser.parse_args()
glofasdir = args.glofasdir # location of uparea_glofas_v4_0.nc and hydroMESH shapefile
rundir = args.rundir # location of hgrid.gr3 or hgrid.npz
outdir = args.outdir # location of hgrid.gr3 or hgrid.npz
tag = args.tag # name 
minarea = args.minarea # minimum area of watersheds to include in output
imagedir = args.imagedir # optional images written here if location is provided
if imagedir is None:
    processplot = False
else:
    processplot = True
# plotting areas for sanity checks
plotbounds = {}
if processplot :
    for bstr in args.plotbounds.split(';'):
       name, bndstr = bstr.split(':')
       plotbounds[name] = np.array([float(x) for x in bndstr.split(',')])

# for NEW22/NEW23 grids, always use region files for lewis, cowlitz and alsea rivers, revisit whether these are still needed in future grids
regfiles = ['lewis_larger.reg','cowlitz_larger.reg','no_alsea_wo_fix.reg']
# add additional blackout regions, e.g. NWM coverage areas if using NWM + GloFAS
if args.regfiles is not None:
  for reg in args.regfiles.split(','):
     regfiles.append(reg)

if tag is not None:
   outsuffix = f'{tag}{int(minarea)}km'
else: outsuffix =''
# conformal projection for distance measurements and plotting
prjstr = 'PROJCS["Pacific_Lambert_Conformal_Conic_WGS84",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Lambert_Conformal_Conic"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",180.0],PARAMETER["Standard_Parallel_1",-15.0],PARAMETER["Standard_Parallel_2",50.0],PARAMETER["Latitude_Of_Origin",-30.0],UNIT["Meter",1.0]]' # lambert conformal conic covering Pacific basin, used for visualization and distance calculation, some distortion in low to mid-latitudes
# glofas static uparea file
upareafile = os.path.join(glofasdir,'uparea_glofas_v4_0.nc')
# read hgrid
print('reading hgrid')
try:
  hgrid = pl.read(os.path.join(rundir,'hgrid.npz'))
except:
  hgrid = pl.read(os.path.join(rundir,'hgrid.gr3'))
hgrid.compute_bnd()
I = hgrid.bndinfo
prj='epsg:4326'
x = I.x
nbn = I.nbn
y = I.y
ring = np.array([x[0:nbn[0]], y[0:nbn[0]]]).T
holes = []
for i in range(1,I.nb):
  st = np.sum(nbn[:i])
  en = np.sum(nbn[:i+1])
  hole = np.array([x[st:en],y[st:en]]).T
  holes.append(hole)
# shapely polygon used to burn in model domain on GloFAS raster
poly = shl.Polygon(ring,holes=holes) 

print('processing GLOFAS')
# read in GLOFAS upriver basin area
uparea = ras.open(upareafile)
band0 = uparea.read(1,masked=True)
# convert from -180 -180 to 0-360a
band1 = np.c_[band0[:,3600:],band0[:,:3600]] # swap order of hemispheres
tr = np.array(uparea.transform)
if tr[2] == -180:
  tr[2] = 0  # shift starting point of transform from 
transf360 = ras.Affine(*tr) # create new Affine transform
for plotarea in plotbounds.keys():
  f,ax = plt.subplots(1,1)
  rasplot.show(band1,transform=transf360,vmin=0,vmax=10000e6,ax=ax)
  ax.axis(plotbounds[plotarea])
  ax.set_title(f'GLOFAS discharge around {plotarea}')
  f.savefig(os.path.join(imagedir,f'glofas_{plotarea}_{outsuffix}_step0.png'))
  plt.close(f)
  
# mask area covered by SCHISM grid

rasfeat.rasterize([(poly,-3.4028235e+38)],transform=transf360, all_touched=True, out=band1)
for plotarea in plotbounds.keys():
  f,ax = plt.subplots(1,1)
  rasplot.show(band1,transform=transf360,vmin=0,vmax=10000e6,ax=ax)
  ax.axis(plotbounds[plotarea])
  ax.set_title('burn in SCHISM mesh')
  f.savefig(os.path.join(imagedir,f'glofas_{plotarea}_{outsuffix}_step0.png'))
  plt.close(f)

nbh = 3
upmax = ndimage.maximum_filter(band1,nbh) # 3x3 windowed max onto uparea
maxima = upmax==band1 # find local maxima in uparea
riverendA = maxima * band1/1e6 #  convert from m^2 to km^2
ind0,ind1 = np.where(riverendA > minarea) # limit river ends to watersheds > [minarea] km ^2
lon, lat = ras.transform.xy(transf360,ind0,ind1) # get lat-lon of riverends
riverendarea = riverendA[ind0,ind1]
riverends = shl.points(np.array(list(zip(lon,lat)))) # contruct shapely set of points of river ends
gdfpoly = geopandas.GeoDataFrame({ 'geometry':poly,'A':[0]}, crs="EPSG:4326") # construct geopandas dataframe for plotting purposes
gdfpoly_paclcc = gdfpoly.to_crs(prjstr)
print('processing hydroSHED')
sttimer = dt.datetime.now()
# get hydroSHED rivers
riverlines = geopandas.read_file(os.path.join(glofasdir,'HydroRIVERS_v10_pacifiic_last200km_upland100km2_wEndorheic.shp'))
riverlines_paclcc = riverlines.to_crs(prjstr)
# cut hydroSHED rivers using mesh boundary polygon
# this stage is slow , ~11 minutes on older CRITFC system
outsiderivers_paclcc  = geopandas.overlay(riverlines_paclcc,gdfpoly_paclcc,how='difference') # remove river segments inside model mesh
outsiderivers = outsiderivers_paclcc.to_crs("EPSG:4326")
print(f'{(dt.datetime.now()-sttimer).seconds} seconds to process hydroSHED rivers')
sttimer = dt.datetime.now()

# find distance from riverends to polygon
gdfriver = geopandas.GeoDataFrame({ 'geometry':riverends,'gid':np.arange(0,len(riverends))}, crs="EPSG:4326") # construct geopandas dataframe for plotting purposes
gdfriver_paclcc = gdfriver.to_crs(prjstr)
gdfriver_paclcc = gdfriver_paclcc.sjoin_nearest(gdfpoly_paclcc,max_distance=100000,distance_col='Pdistance').reset_index().drop_duplicates(subset=['gid'], keep="first")

nearriversall = np.where(gdfriver_paclcc.Pdistance.values < 50000)[0] # limit riverends to within 1 degree from schism grid

gdfriverN = gdfriver.iloc[gdfriver_paclcc.iloc[nearriversall].gid.values].reset_index()
gdfriverN_paclcc = gdfriverN.to_crs(prjstr)

def convertSeries(S):
    try:
        S = S.values[0]
    except AttributeError:
        pass
    except IndexError:
        S = 0
    return S

# find nearest river line segment to GLOFAS river ends
nearestrivers_paclcc  = gdfriverN_paclcc.sjoin_nearest(outsiderivers_paclcc,max_distance=50000,distance_col='distance')
# exclude endorheic rivers
endorheicglofas = np.unique(nearestrivers_paclcc.iloc[np.where(nearestrivers_paclcc.ENDORHEIC == 1) [0]].index.values)
# remove from list of glofas rivers near polygon
nearrivers = np.delete(nearriversall,endorheicglofas)
nearrivers = gdfriver_paclcc.iloc[nearrivers].gid.values
# regenerated glofas rivers near polygon, excluding  endorheic rivers 
gdfriverN = gdfriver.iloc[nearrivers].reset_index()
gdfriverN_paclcc = gdfriverN.to_crs(prjstr)
gdfriverN_paclcc.assign(nearind=np.arange(gdfriverN_paclcc.shape[0]))
# refind nearest rivers excluding the glofas watersheds that match endorheic rivers
nearestrivers_paclcc  = gdfriverN_paclcc.sjoin_nearest(outsiderivers_paclcc,max_distance=50000,distance_col='distance')
lonN = lon[nearrivers]
latN = lat[nearrivers]
# sjoin_nearest creates duplicate nearest rows if multiple rows are equidistant, keep the first
nearestrivers_paclcc = nearestrivers_paclcc.reset_index().drop_duplicates(subset=['gid'], keep="first")
# sjoin_nearest drops rows that don't have a match, need to capture those missing indexes to adjust GloFAS source list

# for each river line segment, walk downstream using NEXT_DOWN value, as there may be misleading fragments further downstream (e.g. Sandy and Columbia)
nearestlist = []
for ni,row in enumerate(nearestrivers_paclcc.itertuples()):
    i = convertSeries(row.index_right)
    matchrivid =  convertSeries(row.MAIN_RIV)
    # check for closest match having multilinestring
    rivtype = convertSeries(outsiderivers_paclcc.iloc[[i]].geometry).geom_type
    nearestrivid = convertSeries(outsiderivers_paclcc.iloc[[i]].MAIN_RIV)
    if rivtype == 'MultiLineString':
       nextriv = 0
       splitriv = outsiderivers_paclcc.iloc[[i]].explode()
       final = splitriv.iloc[[0]]
    else:
       nextriv = convertSeries(outsiderivers_paclcc.iloc[i].NEXT_DOWN)
       final = outsiderivers_paclcc.iloc[[i]]
    ind = np.array([i])
    while nextriv > 0:
       prevind = ind
       i0 = np.where(nextriv == outsiderivers_paclcc.HYRIV_ID) [0]
       if i0.shape[0] > 0:
          nextriv = convertSeries(outsiderivers_paclcc.iloc[i0].NEXT_DOWN)
          if nextriv > 0: 
             rivtype = convertSeries(outsiderivers_paclcc.iloc[i0].geometry).geom_type
             if rivtype == 'MultiLineString':
                nextriv = 0
                splitriv = outsiderivers_paclcc.iloc[i0].explode()
                final = splitriv.iloc[[0]]
             else:
                ind = i0
          else:
             final = outsiderivers_paclcc.iloc[ind] 
       else:
          final = outsiderivers_paclcc.iloc[ind]
          nextriv = 0
    dendlcc = convertSeries(final.geometry).coords[-1]
    final = final.to_crs("EPSG:4326")
    dend = convertSeries(final.geometry).coords[-1]
    nearestlist.append([dend[0],dend[1],dendlcc[0],dendlcc[1]])
nearest = np.array(nearestlist)
riverCoords = np.c_[lonN,latN]
riverCoordspaclcc = np.c_[gdfriverN_paclcc.geometry.x.values, gdfriverN_paclcc.geometry.y.values]
# replace GLOFAS end locations with river end locations where rivers exist (hydroSHED v1 is missing Hawaii and other Pacific islands)
riverCoords[nearestrivers_paclcc.level_0,:] = nearest[:,:2]
riverCoordspaclcc[nearestrivers_paclcc.level_0,:] = nearest[:,2:]
# shift to 0 360 to match hgrid
neg = riverCoords[:,0] < 0
riverCoords[neg,0] +=360
print(f'{(dt.datetime.now()-sttimer).seconds} seconds to align glofas endpoints to hydroSHED river ends')
sttimer = dt.datetime.now()
for plotarea in plotbounds.keys():
  f,ax = plt.subplots(1,1)
  rasplot.show(riverendA,transform=transf360,vmin=0,vmax=10000,ax=ax)
  plt.plot(lonN,latN,'m*')
  ax.axis(plotbounds[plotarea])
  ax.set_title(f'river ends {plotarea}')
  f.savefig(os.path.join(imagedir,f'glofas_{plotarea}_{outsuffix}_step2.png'))
  plt.close(f)
for plotarea in plotbounds.keys():
  f,ax = plt.subplots(1,1)
  gdfpoly_paclcc.plot(ax=ax,color='grey')
  riverlines_paclcc.plot(ax=ax,color='y')
  outsiderivers_paclcc.plot(ax=ax,color='k')
  nearestrivers_paclcc.plot(ax=ax,color='c',marker='*')
  outsiderivers_paclcc.loc[ nearestrivers_paclcc.index_right].plot(ax=ax,color='c')
  gdfriverN_paclcc.plot(ax=ax,edgecolor='g',marker='o',facecolor='none')
  ax.plot(riverCoordspaclcc[:,0],riverCoordspaclcc[:,1],'rd')
  f.savefig(os.path.join(imagedir,f'glofas_{plotarea}_{outsuffix}_hydroSHED_matching.png'))
  plt.close(f)

  f,ax = plt.subplots(1,1)
  gdfpoly.plot(ax=ax,color='grey')
  ax.plot(np.c_[lonN, riverCoords[:,0]].T,np.c_[latN,riverCoords[:,1]].T,'r*')
  ax.plot(np.c_[lonN, riverCoords[:,0]].T-360,np.c_[latN,riverCoords[:,1]].T,'r*')
  f.savefig(os.path.join(imagedir,f'glofas_pacific-ll_{outsuffix}_hydroSHED_matchinglines.png'))
  plt.close(f)

# find nearest element side center to the hydroSHEDS river end point, this maps the GLOFAS watershed end point to the model mesh side nearest the connecting river
# find boundary element side-center nearest each river, maintaining connection to element id
hgrid.compute_ctr() # compute element centers, used for finding elements in region
hgrid.compute_side(2)   # compute table of side elements and side center coordinates
# 2) Generate element centroid KDTree
boundedges = np.where(hgrid.isdel[:,1] == -1)[0]  # isdel is the table of elements for each side, sides that only have 1 element have -1 as the second element, and are boundary sides
sidecenters = np.c_[hgrid.xcj[boundedges], hgrid.ycj[boundedges]]   # xcj,ycj is the side center point
# create a KDTree for boundary side centers
tree = cKDTree(sidecenters) 

# search for nearest boundary side center for all river
_, idxs = tree.query(np.vstack(riverCoords), workers=-1)
# idxs is the index of the side nearest to the river end points in the data subset
# plug idxs back into boundedges and isdel to get the element that contains the sides
Erivers = hgrid.isdel[boundedges[idxs],0]
######################################
print(f'{(dt.datetime.now()-sttimer).seconds} seconds to find sidecenters for rivers')
sttimer = dt.datetime.now()


# indices for final rivers into original full domain, including openbnd
ind0N = ind0[nearrivers]
ind1N = ind1[nearrivers]
lonN = lon[nearrivers]
latN = lat[nearrivers]
areaN = riverendarea[nearrivers]

# raster of final locations, including open boundaries, just used for process visualization
final =band1*0
final[ind0N,ind1N] = band1[ind0N,ind1N]
#
#

print(f'{(dt.datetime.now()-sttimer).seconds} seconds to read discharge')
sttimer = dt.datetime.now()
# need to remove rivers near open boundaries (mostly an issue for river open boundaries, but probably also good for ocean open boundaries
Enodes = hgrid.elnode[Erivers,:]
openbnd = np.array([],dtype=int)
for b in hgrid.iobn :
   Eind = np.argwhere(np.any(np.isin(Enodes,b),axis=1))
   if len(Eind)>0:
       openbnd = np.r_[openbnd,Eind.ravel()[:]]

# loop over regions to manually remove any rivers that aren't caught by the automated method (e.g. Lewis River in Pacific model)
# read regions from list of regions
ctr = np.c_[hgrid.xctr[Erivers],hgrid.yctr[Erivers]]
for r in regfiles:
   print(r)
   reg  = pl.read(os.path.join(glofasdir,r))
   # find Ecenters in  region polygon and add elements to openbnd list
   Eind = np.argwhere(pl.inside_polygon(ctr,reg.x,reg.y))[:,0]
   if len(Eind)>0:
       openbnd = np.r_[openbnd,Eind]
# remove duplicates
openbnd = np.unique(openbnd)
# remove rivers along open boundaries and in black-out regions
Erivers = np.delete(Erivers,openbnd)
ind0N = np.delete(ind0N,openbnd)
ind1N = np.delete(ind1N,openbnd)
lonN = np.delete(lonN,openbnd)
latN = np.delete(latN,openbnd)
areaN = np.delete(areaN,openbnd)

# merge river values from duplicate elements
uniqErivers, uniqEriversInd, DeuniqEriversInd, uniqEriversCount = np.unique(Erivers,return_index=True, return_inverse=True, return_counts=True)
dups = np.where(uniqEriversCount>1)[0]
singles = np.where(uniqEriversCount==1)[0]

xctr = hgrid.xctr
yctr = hgrid.yctr
elnode = hgrid.elnode
ne = hgrid.ne
# get uparea lon lat in simple form, not through rasterio
print(f'opening {upareafile}')
ncid = nc.Dataset(upareafile)
lon = ncid.variables['longitude'][:]
g = lon<=0
lon[g] += 360
lon = np.r_[lon[~g],lon[g]] # rearrange longitude to match data files
lat = ncid.variables['latitude'][:]

# save static file for daily forecast processing of GloFAS download
print(f'saving glofas_prep{outsuffix}.npz')
np.savez(os.path.join(outdir,f'glofas_prep{outsuffix}.npz'), Erivers=Erivers, uniqErivers=uniqErivers, ind0N=ind0N, ind1N=ind1N, final=final, minarea=minarea, singles=singles, uniqEriversInd=uniqEriversInd, dups=dups,
idxs=idxs,lonN=lonN,latN=latN,lon=lon,lat=lat,areaN=areaN,
xctr = xctr,
yctr= yctr,
elnode = elnode,
ne = ne,
regfiles = regfiles)


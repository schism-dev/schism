The information presented in this chapter is mostly intended for developers or anyone who wishes to work on the code. To know more about how to contribute your code see [CONTRIBUTING.md](https://github.com/schism-dev/schism/blob/master/CONTRIBUTING.md) on SCHISM github repo. 

## General info
SCHISM was written in MPI FORTRAN 90. After svn revision 5225, we have migrated to github: https://github.com/schism-dev. Figure 1 shows the directory structure of the SCHISM github repository schism. General public have access to all branches.

<figure markdown>
![SCHISM github repository](assets/github-fs.png)
<figcaption>SCHISM github repository.</figcaption>
</figure>

Figure 2 shows its main work flow and major code blocks. Two files inside `src/` (`Hydro/schism_init.F90` and `Hydro/schism_step.F90`) represent bulk of the hydro code, and are driven by a master program (`Driver/schism_driver.F90`). The global variables are defined in `Core/schism_glbl.F90`, and the message passing routines are defined in `Core/schism_msgp.F90`.

<figure markdown>
![SCHISM code work flow. The percentages are estimates from a test case with an earlier version and may not be up to date.](assets/schism-loop.png)
<figcaption>SCHISM code work flow. The percentages are estimates from a test case with an earlier version and may not be up to date.</figcaption>
</figure>

The domain decomposition is done using ParMETIS graph partitioning library (included in the `src/`). Figure 3 shows an example of sub-domains generated by this lib.

<figure markdown>
![Domain decomposition. Each color represents a sub-domain (‘resident domain’) taken by a MPI process and the thick black polygon represents the ‘augmented’ (=resident+ghost) domain of process 6.](assets/domain-decomposition.png)
<figcaption>Domain decomposition. Each color represents a sub-domain (‘resident domain’) taken by a MPI process and the thick black polygon represents the ‘augmented’ (=resident+ghost) domain of process 6.</figcaption>
</figure>

The Utility dir has a lot of useful utility scripts for pre- and post-processing. The header of each program generally has info on its purpose and instructions on how to use it.

- `ACE`: source code and install notes for ACE tools; the manual can be found on the web site.
- `Combining_Scripts`: FORTRAN and perl scripts used to gather outputs from SCHISM (e.g., `outputs/schout_0*_[stack number].nc` etc) into one binary file (`schout_[stack_number].nc`).
- `Grid_Scripts`: FORTRAN codes to interpolate depths from DEM files in either structured grid (raster) or unstructured grid format. While ACE/xmgredit5 can do similar things, these scripts are mostly for interpolating from very large DEM files.
- `Gen_Hotstart`: scripts for preparing `hotstart.nc` from e.g., netcdf outputs from a structured-grid model.
- `Pre-Processing`: various scripts for pre-processing (checking, viz etc)
- `OneWayNestScripts`: scripts for 1-way nesting, by preparing `*[23]D.th.nc` (elevation, horizontal velocity, salinity and temperature boundary condition) that can be used for the 'small-domain' run.
- `Particle_Tracking`: particle tracking code that uses SCHISM's outputs for 3D tracking.
- `Post-Processing-Fortran`: FORTRAN codes for extracting time series at selected 3D points (including transects). You can modify these codes for your own purposes.
- `Sflux_nc`: matlab scripts useful for preparing your own .nc files for `sflux/`. `NARR_util/` has scripts to prepare .nc files from NCEP's NARR products.
- `SMS`: scripts to convert between `.2dm` of SMS and `.gr3`.
- `Vis_Matlab`: matlab scripts for viz. At the moment, these scripts have not been updated to handle $LSC^2$ grid.


## Domain partitioning

- Working on your own code

## Arrays and constant

## I/O channels in SCHISM

## General code guide
Here are some house rules for preparing your own code - 

1. No spaces between `#` (pre-processor) and `if/else/end` for CPP flag;
2. Try to use the I/O channel number directly, e.g., `read(61, etc)` instead of assigning a number to a variable (e.g. `read(ich,)`. This'd facilitate others searching for conflicts;
3. Avoid using tabs in editor as they mess up with the appearance. Use space instead and strictly align code blocks for easy read.
4. Do not use automatic arrays of ≥2 dimensions. It’s often tempting to grab dimensions directly from the module `schism_glbl` and use them to define arrays in a routine; e.g. `vel_sd(nvrt,nsa)`. This causes trouble with some compilers and may result in segfault. Use either of the following 2 approaches instead: 
    1.  allocatable arrays (and always remember to deallocate them at the end of the routine);
    2. pass on the dimensions explicitly as dummy arguments (e.g. `subroutine routine1(nvrt2,nsa2, vel_sd..)`, where `nvrt2=nvrt` and `nsa2=nsa`, and then use these to define: `vel_sd (nvrt2,nsa2)`).

{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Semi-implicit Cross-scale Hydroscience Integrated System Model (SCHISM) \u00b6 SCHISM modeling system is a derivative work from the original SELFE model (v3.1dc as of Dec. 13 , 2014). SCHISM has been implemented by Dr. Joseph Zhang (College of William & Mary) and other developers around the world, and licensed under Apache. SELFE was developed at the Oregon Health Sciences University. However, there are now significant differences between the two models. SCHISM (Semi-implicit Cross-scale Hydroscience Integrated System Model) is an open-source community-supported modeling system based on unstructured grids, designed for seamless simulation of 3D baroclinic circulation across creek-lake-river-estuary-shelf-ocean scales. It uses a highly efficient and accurate semi-implicit finite-element/finite-volume method with Eulerian-Lagrangian algorithm to solve the Navier-Stokes equations (in hydrostatic form), in order to addresses a wide range of physical and biological processes. The numerical algorithm judiciously mixes higher-order with lower-order methods, to obtain stable and accurate results in an efficient way. Mass conservation is enforced with the finite-volume transport algorithm. It also naturally incorporates wetting and drying of tidal flats. SCHISM modelling framework. The SCHISM system has been extensively tested against standard ocean/coastal benchmarks and applied to a number of regional seas/bays/estuaries around the world (see 'Case study') in the context of general circulation, tsunami and storm-surge inundation, water quality, oil spill, sediment transport, coastal ecology, and wave-current interaction. SCHISM now includes many upgrades of the original SELFE code (v3.1dc); the major differences are summarized in Zhang et al. (Seamless cross-scale modeling with SCHISM, Ocean Modelling, 2016; see Publications). The source code and user manual can be downloaded from this web site. The plot above (Figure 1 ) shows a snapshot of various modules inside SCHISM. Major Characteristics of SCHISM \u00b6 Finite element/volume formulation Unstructured mixed triangular/quadrangular grid in the horizontal dimension Hybrid SZ coordinates or new \\(LSC^2\\) in the vertical dimension Polymorphism: a single grid can mimic 1D/2DV/2DH/3D configurations Semi-implicit time stepping (no mode splitting): no CFL stability constraints \u2192 numerical efficiency Robust matrix solver Higher-order Eulerian-Lagrangian treatment of momentum advection (with ELAD filter) Natural treatment of wetting and drying suitable for inundation studies Mass conservative, monotone, higher-order transport solver: TVD2; WENO No bathymetry smoothing necessary Very tolerant of bad-quality meshes in the non-eddying regime Modeling system & application areas \u00b6 3D baroclinic cross-scale lake-river-estuary-plume-shelf-ocean circulations Tsunami hazards Storm surge Sediment transport Biogeochemistry/ecology/water quality Oil spill Short wave-current interaction Citation \u00b6 We suggest the following language for citing the model: SCHISM (Semi-implicit Cross-scale Hydroscience Integrated System Model) is a derivative product built from the original SELFE (v3.1dc; Zhang and Baptista 2008) and distributed with an open-source Apache v2 license, with many enhancements and upgrades including new extension to large-scale eddying regime and a seamless cross-scale capability from creek to ocean (Zhang et al. 2016). Zhang, Y. and Baptista, A.M. (2008) SELFE: A semi-implicit Eulerian-Lagrangian finite-element model for cross-scale ocean circulation\", Ocean Modelling, 21(3-4), 71-96. Zhang, Y., Ye, F., Stanev, E.V., Grashorn, S. (2016) Seamless cross-scale modeling with SCHISM, Ocean Modelling, 102, 64-81.","title":"Home"},{"location":"index.html#semi-implicit-cross-scale-hydroscience-integrated-system-model-schism","text":"SCHISM modeling system is a derivative work from the original SELFE model (v3.1dc as of Dec. 13 , 2014). SCHISM has been implemented by Dr. Joseph Zhang (College of William & Mary) and other developers around the world, and licensed under Apache. SELFE was developed at the Oregon Health Sciences University. However, there are now significant differences between the two models. SCHISM (Semi-implicit Cross-scale Hydroscience Integrated System Model) is an open-source community-supported modeling system based on unstructured grids, designed for seamless simulation of 3D baroclinic circulation across creek-lake-river-estuary-shelf-ocean scales. It uses a highly efficient and accurate semi-implicit finite-element/finite-volume method with Eulerian-Lagrangian algorithm to solve the Navier-Stokes equations (in hydrostatic form), in order to addresses a wide range of physical and biological processes. The numerical algorithm judiciously mixes higher-order with lower-order methods, to obtain stable and accurate results in an efficient way. Mass conservation is enforced with the finite-volume transport algorithm. It also naturally incorporates wetting and drying of tidal flats. SCHISM modelling framework. The SCHISM system has been extensively tested against standard ocean/coastal benchmarks and applied to a number of regional seas/bays/estuaries around the world (see 'Case study') in the context of general circulation, tsunami and storm-surge inundation, water quality, oil spill, sediment transport, coastal ecology, and wave-current interaction. SCHISM now includes many upgrades of the original SELFE code (v3.1dc); the major differences are summarized in Zhang et al. (Seamless cross-scale modeling with SCHISM, Ocean Modelling, 2016; see Publications). The source code and user manual can be downloaded from this web site. The plot above (Figure 1 ) shows a snapshot of various modules inside SCHISM.","title":"Semi-implicit Cross-scale Hydroscience Integrated System Model (SCHISM)"},{"location":"index.html#major-characteristics-of-schism","text":"Finite element/volume formulation Unstructured mixed triangular/quadrangular grid in the horizontal dimension Hybrid SZ coordinates or new \\(LSC^2\\) in the vertical dimension Polymorphism: a single grid can mimic 1D/2DV/2DH/3D configurations Semi-implicit time stepping (no mode splitting): no CFL stability constraints \u2192 numerical efficiency Robust matrix solver Higher-order Eulerian-Lagrangian treatment of momentum advection (with ELAD filter) Natural treatment of wetting and drying suitable for inundation studies Mass conservative, monotone, higher-order transport solver: TVD2; WENO No bathymetry smoothing necessary Very tolerant of bad-quality meshes in the non-eddying regime","title":"Major Characteristics of SCHISM"},{"location":"index.html#modeling-system-application-areas","text":"3D baroclinic cross-scale lake-river-estuary-plume-shelf-ocean circulations Tsunami hazards Storm surge Sediment transport Biogeochemistry/ecology/water quality Oil spill Short wave-current interaction","title":"Modeling system &amp; application areas"},{"location":"index.html#citation","text":"We suggest the following language for citing the model: SCHISM (Semi-implicit Cross-scale Hydroscience Integrated System Model) is a derivative product built from the original SELFE (v3.1dc; Zhang and Baptista 2008) and distributed with an open-source Apache v2 license, with many enhancements and upgrades including new extension to large-scale eddying regime and a seamless cross-scale capability from creek to ocean (Zhang et al. 2016). Zhang, Y. and Baptista, A.M. (2008) SELFE: A semi-implicit Eulerian-Lagrangian finite-element model for cross-scale ocean circulation\", Ocean Modelling, 21(3-4), 71-96. Zhang, Y., Ye, F., Stanev, E.V., Grashorn, S. (2016) Seamless cross-scale modeling with SCHISM, Ocean Modelling, 102, 64-81.","title":"Citation"},{"location":"case-study.html","text":"Hydrologic flow \u00b6 Simulation of hydrologic flow in watershed, with bottom elevation above sea level (thus strong wetting and drying) and with complex river channel network, is challenging. The discussions below are taken from a training course on compound flooding simulation. A common, convenient method for introducing river flows into watershed in SCHISM mesh is via the point source/sinks as shown in Figure 8 . Together with proper parameter choices (e.g., a small minimum depth of 10-5m, a fully implicit scheme, a large bottom friction with proper vertical grid to allow for 2D representation in the watershed etc) this usually works fine for smaller rivers. For large rivers, the open-boundary approach (i.e., river channels as open boundary segments) is the preferred method. In general, the point source approach injects flow via the continuity equation alone without providing extra momentum (note that the volume sources/sinks are added to the RHS of Eqs. 2 and 3 but not in the momentum Eqs. 1 , and thus it will take the system some time to adjust internally to set up the flow from the pressure gradient. Because of this drawback, large elevations may be found near the injection points, especially during initial ramp up or during high and rapidly varying flow periods. This symptom can be exacerbated by the following missteps: Pairs of source and sink in close proximity (Figure 9 a). Users should combine these pairs; Steep slopes near boundary with coarse resolution (Figure 9 b); Inverted bed slopes near the injection location (so the flow has to overcome gravity; Figure 9 c); Poorly ventilated \u2018dead-end\u2019 (Figure 9 d); Undulating channel (\u2018water fall\u2019; Figure 9 e). The model is stable, but interpretation of results may be problematic in those cases. Besides more grid work in those spots, using open-boundary segments can help. Also one should really exclude transient responses during ramp-up period in computing the maximum elevation to allow the system time to adjust. Also don\u2019t forget that sometimes the rainfall (which can also be introduced as sources) on high mountains should result in high surface elevations there, which are realistic. To get accurate results in the hydrologic regime, it is also important to resolve channels to avoid blocking flows. Semi-automatic mesh generation tools have been developed specifically for this purpose; see this chapter . Coupling of hydrologic model (National Water Model in this case) with SCHISM. The river network (lines) intersects SCHISM land boundary, and the river flow is introduced at the intersection points (sources for inflow and sinks for outflow). Pathologic cases for hydrologic flows. Tsunami simulations \u00b6 Your can diwnload a sample tsunami run (impact of Alaska tsunami waves on Cannon Beach, OR) at http://www.ccrm.vims.edu/yinglong/wiki_files/tsunami_ex15.tgz Note that the files are compatible with the serial version of SCHISM, but the idea for parallel version is similar. The operational time step for tsunami applications is generally in the range of a few seconds because of the constraint from shorter wavelength and inundation processes. You'll need higher mesh resolution also to satisfy the inverse CFL criterion ( CFL>0.2 ). The inundation results may also be sensitive to the min. depth used in the run (1cm in this example). If you use the newer parallel version, you can also use a 2D model with a proper Manning coefficient. Typically you need to follow these 2 steps in tsunami simulations: Deformation run (EX15/Def/ in the sample run): this simulates the earthquake and the set-up of the initial surface waves. For this you need: a) `bdef.gr3` (refer to the user manual) which specifies the total seafloor deformation. b) turn on the hotstart output handle, and `dt=1s, ibdef=10, rnday=1.158e-4` c) We typically run this stage for 10 sec duration and at the end of the run you'll find an output files called `10_hotstart` which is then used as hotstart.in for the next (propagation and inundation) stage. d) In addition, use `mod_depth.f` (inside the bundle), which takes info in `bdef.gr3` and `hgrid.gr3` (pre-earthquake depths) to generate hgrid.new (post-earthquake depths). The latter is used in the next stage. For completeness you need to attach the boundary condition part (`b.tmp` in the bundle) of `hgrid.gr3` to the end of `hgrid.new`; Propagation and inundation stage (EX15/ in the sample run): this run continues from the deformation run above with no further seafloor movement. You'll notice that many input files are identical to the Def/ run, but be careful of differences in hgrid.gr3 (linked to Def/hgrid.new) and param.in (imm=0 etc). a) For this run we also turn off the advection in the open ocean (up to say 60m isobath) because it's negligible there (`adv.gr3`) - this bypasses the inverse CFL criterion and allows you to use a coarser resolution in deeper ocean. b) Also note that `hotstart.in` is from the previous stage. After the run is done you can look at global outputs (elevation, depth-averaged velocity etc). The maximum elevation ( maxelev.gr3 ) and depth-averaged velocity ( maxdahv.gr3 ) are also part of the outputs (for parallel versions, use /src/Utility/Combining_Scripts/combine_gr3.f90 ). The maximum inundation can be easily computed from maxelev.gr3 .","title":"Case studies"},{"location":"case-study.html#hydrologic-flow","text":"Simulation of hydrologic flow in watershed, with bottom elevation above sea level (thus strong wetting and drying) and with complex river channel network, is challenging. The discussions below are taken from a training course on compound flooding simulation. A common, convenient method for introducing river flows into watershed in SCHISM mesh is via the point source/sinks as shown in Figure 8 . Together with proper parameter choices (e.g., a small minimum depth of 10-5m, a fully implicit scheme, a large bottom friction with proper vertical grid to allow for 2D representation in the watershed etc) this usually works fine for smaller rivers. For large rivers, the open-boundary approach (i.e., river channels as open boundary segments) is the preferred method. In general, the point source approach injects flow via the continuity equation alone without providing extra momentum (note that the volume sources/sinks are added to the RHS of Eqs. 2 and 3 but not in the momentum Eqs. 1 , and thus it will take the system some time to adjust internally to set up the flow from the pressure gradient. Because of this drawback, large elevations may be found near the injection points, especially during initial ramp up or during high and rapidly varying flow periods. This symptom can be exacerbated by the following missteps: Pairs of source and sink in close proximity (Figure 9 a). Users should combine these pairs; Steep slopes near boundary with coarse resolution (Figure 9 b); Inverted bed slopes near the injection location (so the flow has to overcome gravity; Figure 9 c); Poorly ventilated \u2018dead-end\u2019 (Figure 9 d); Undulating channel (\u2018water fall\u2019; Figure 9 e). The model is stable, but interpretation of results may be problematic in those cases. Besides more grid work in those spots, using open-boundary segments can help. Also one should really exclude transient responses during ramp-up period in computing the maximum elevation to allow the system time to adjust. Also don\u2019t forget that sometimes the rainfall (which can also be introduced as sources) on high mountains should result in high surface elevations there, which are realistic. To get accurate results in the hydrologic regime, it is also important to resolve channels to avoid blocking flows. Semi-automatic mesh generation tools have been developed specifically for this purpose; see this chapter . Coupling of hydrologic model (National Water Model in this case) with SCHISM. The river network (lines) intersects SCHISM land boundary, and the river flow is introduced at the intersection points (sources for inflow and sinks for outflow). Pathologic cases for hydrologic flows.","title":"Hydrologic flow"},{"location":"case-study.html#tsunami-simulations","text":"Your can diwnload a sample tsunami run (impact of Alaska tsunami waves on Cannon Beach, OR) at http://www.ccrm.vims.edu/yinglong/wiki_files/tsunami_ex15.tgz Note that the files are compatible with the serial version of SCHISM, but the idea for parallel version is similar. The operational time step for tsunami applications is generally in the range of a few seconds because of the constraint from shorter wavelength and inundation processes. You'll need higher mesh resolution also to satisfy the inverse CFL criterion ( CFL>0.2 ). The inundation results may also be sensitive to the min. depth used in the run (1cm in this example). If you use the newer parallel version, you can also use a 2D model with a proper Manning coefficient. Typically you need to follow these 2 steps in tsunami simulations: Deformation run (EX15/Def/ in the sample run): this simulates the earthquake and the set-up of the initial surface waves. For this you need: a) `bdef.gr3` (refer to the user manual) which specifies the total seafloor deformation. b) turn on the hotstart output handle, and `dt=1s, ibdef=10, rnday=1.158e-4` c) We typically run this stage for 10 sec duration and at the end of the run you'll find an output files called `10_hotstart` which is then used as hotstart.in for the next (propagation and inundation) stage. d) In addition, use `mod_depth.f` (inside the bundle), which takes info in `bdef.gr3` and `hgrid.gr3` (pre-earthquake depths) to generate hgrid.new (post-earthquake depths). The latter is used in the next stage. For completeness you need to attach the boundary condition part (`b.tmp` in the bundle) of `hgrid.gr3` to the end of `hgrid.new`; Propagation and inundation stage (EX15/ in the sample run): this run continues from the deformation run above with no further seafloor movement. You'll notice that many input files are identical to the Def/ run, but be careful of differences in hgrid.gr3 (linked to Def/hgrid.new) and param.in (imm=0 etc). a) For this run we also turn off the advection in the open ocean (up to say 60m isobath) because it's negligible there (`adv.gr3`) - this bypasses the inverse CFL criterion and allows you to use a coarser resolution in deeper ocean. b) Also note that `hotstart.in` is from the previous stage. After the run is done you can look at global outputs (elevation, depth-averaged velocity etc). The maximum elevation ( maxelev.gr3 ) and depth-averaged velocity ( maxdahv.gr3 ) are also part of the outputs (for parallel versions, use /src/Utility/Combining_Scripts/combine_gr3.f90 ). The maximum inundation can be easily computed from maxelev.gr3 .","title":"Tsunami simulations"},{"location":"changelog.html","text":"Following is a curated changelog of the code. The IDs starts with R represents the svn era id, others are git hash. To find all the changes between tag releases, search for 'Tag'. Bug fixes and major algorithmic changes \u00b6 R5178 : fix bug of saturate DO in ICM R5187 : incorporated dry bnd treatment from bndry (c/o Jens Wyrwa). However, to get good volume conservation it's best to keep all open flow bnd's wet all the time as before; R5191 : fixed a bug in iwind_form (accidentally re-init'ed after reading); R5202 : fixed a bug on negative ICM tracer concentration - check negative values before sending back to hydro. R5204 : a new option to control behavior of btrack when trajectory hots an open bnd (set vel=0 and exit). Goal is to eventually use this as default; 64b7181 : fixed an efficiency issue and added nc checks in ptrack3 (c/o Marcel Rieker) 2138e77 : Fixed a major bug introduced during reshuffling of _init for PDAF: need to call nodavel before sflux, as uu2,vv20 are needed there. 5ff2198 : revamped AGE module. B.C. now all should use 0. Only 0 and 1 should be used in AGE_hvar_[1:ntr/2].ic , where ntr is @ of age tracers, and the code will 'hold' concentration at 1 at those prisms (level specified in param.nml) that have 1 as i.c. I.C. in AGE_hvar_[ntr/2+1:ntr].ic should =0 . Injecting '1' at dry elem's is allowed but results may be harder to interpret. 6cec698 : bug fix for spherical coord in WWM (around dateline); c46c7bd (Feb 14, 2020): Fei tweaked WENO solver (wrt upwind); d3adb2c (Feb 14, 2020): changed to bilinear interp for HYCOM hot and nudging scripts (to speed up); 7506147 (Mar 1, 2020): add limiter for settling vel to avoid char line out of bnd; 5665418 (Mar 18, 2020): PR from Baptiste mengual for SED3D ( sed_frition.F90 merged after the rest). eb00a00 (Mar 31, 2020): added 12th tracer model ( USE_DVD of Klingbeil) aaf1306 (April 4, 2020): added hybrid ELM transport for efficiency (via branch hybrid_ELM); 40955ab (April 16, 2020): replaced the fatal error in nadv=2 (aptivity trap) with exit; e703189 (May 6, 2020): reverted to old simple approach for depositional mass (c/o Baptiste Mengual); 14e201f (May 7, 2020): switched to ParMETIS v4.0.3; 33fb37f (Jun 30, 2020): fixed a bug in ielm_transport (Fei Y.); 55910d1 (July 31, 2020; via branch mem_leak_nc4): reverted the change in schism_io (close/open nc output after/b4 each write, to accommodate PDAF's flexible mode), as this has caused a lot of mem leaking (discovered by Nicole C. when testing ICM). eaf9093 (Aug 2020): Baptiste M. modified the computation of the bottom shear stress under combined waves and currents in SED3D 4ac56df (Aug 2020): Paul Ryan and Claire Trenham (CSIRO) fixed some init array issues in hydro and WWM. 7e9ff0a (Aug 20, 2020): Fei Y fixed a msource bug (init of msource at 0 at elem's not in source_sink.in led to ice rain; f311026 (Aug. 27, 2020): reverted init of msource to 0 for tracers other than T,S, c/o Nicole Cai. Using ambient values for other tracers can lead to artificial and additional accumulation of nutrients; 00b6f16 (Nov. 9, 2020): PR #21 from Kijin merged (SED): changed method to compute near bottom vel for \\(LSC^2\\) . 8083cfa (Nov. 10, 2020): added option for transport solver only ( itransport_only ) 6dc44d3 (Dec 14, 2020): Fixed a bug, thanks to Kevin Kartin, on vortex formulism of wave force (missing a factor of area() in \\(I_4\\) ); 28ff9d1 (Dec 16, 2020): added optional self-attraction loading tides. The option shares some constants with tidal potential: freq names and cut-off depth; b1bcaa0 (April 20, 2021): removed most of goto . Remaining ones: harm.F90 , lap.F90 , WWM ; 0cec024 (April 21, 2021): bug fix in misc_subs c/o of Fei ( inunfl=1 : nodeA in final extrap stage may be interface node); fb30239 (April 22, 2021): bug fix for ellipsoidal earth (tensor frames). fb79cdc (May 26, 2021): in interpolate_depth_structured2* , added an option to shift 1/2 cell for ll corner (c/o Charles Seaton); 5e87c24 (June 9, 2021): more changes in interpolate_depth_structured2* to extrap also into right/upper sides. 843c40f (19 June, 2021): fixed a bug in ptrack3 (pt_in_poly3; c/o Jilian Xiong) that affects quads; b2cf92b (29 June, 2021): fixed a bug in station outputs in basin scale cases ics=2 (local proj is not accurate if the station is far away from the local frame); Tag v5.9.0: 657157a (1 July, 2021) a9f8f6c (8 July, 2021): fixed a bug in iloadtide=1 (index error). Also revamped reading of input files for large core counts. ab46def (20 July, 2021): merged multi ice model (CICE) from Qian Wang. 70db927 (11 Aug 2021): bug fixes from Qian Wang on ice matrix (ghost nodes) 8efc374 (30 Aug 2021): first version of scribe dictated I/O (as an option) 53689f4 (12 Sept 2021): fixed a bug in weno transport introduced in e794d8c (23 Aug 2021). c7dd516 (27 Sept 2021): AGE module tweaked (clamped @ i.c. at injection points for both concentrations). (19 Oct 2021): filtered isolated wet nodes during outputs (should not change other results); 7455d5d (30 Dec 2021): added a new option nws=-1 (PaHM, Parametric Hurricane Model); 7455d5d (30 Dec 2021): added Fariall air-sea exchange (USE_BULK_FAIRALL) c/o Jerome Lefevre; e288f9a (31 Jan 2022): removed the restriction of counter-clockwise orientation in sflux grid; dde345f (7 April 2022): fixed a bug in sflux, invoked only if nws=2, ihconsv=1, and iwind_form=0: uninit'ed stress values. 6524e19 (27 April 2022): merged with La Rochelle group on WWM (VOR); cd0b2a3 (14 Aug 2022): [via Qian_pole_treatment] changed nodalvel() under ics=2; commented out a frame transformation for better vel near poles. 510874ec (19 Sep 2022): upgraded all nf_ to nf90_ (in sflux) 24a2723 (27 Sep 2022): PR merge with LRU's modifications for WWM (mostly related to vegetation effects on WWM) 1828489 (10 Oct 2022): bug fix on msource (mismatch in bcast array dimension) 87c7611f (21 Oct 2022): PR91 merge from Dr. Jerome Lefevre a) Add GAHM (Generalized Asymmetric Holland Model) in PaHM/parwind.F90 as a second alternative to Holland Model (see details https://wiki.adcirc.org/Generalized_Asymmetric_Holland_Model and https://noaa-ocs-modeling.github.io/PaHM/pahm_manual.pdf); b) Add support for Hurricanes in both South and North Hemisphere (in HM and GAHM models); c) Test using Niran, SW Pacific: (See inside src/Core/PaHM/inputs/ : a track for Cyclone Niran \"niran2021-bdeck.dat\" and my comparison with HM and GAHM versus a weather model output); d) CAUTION // CAUTION : To switch from HM (1) or GAHM (10), the user still need to change the value of \"modelType\" in Pahm_Utilities.F90 (line 3210) and recompile schism; e) CAUTION / CAUTION : Unlike in noaa-ocs-modeling.github.io/PaHM, there is not Control File support in SCHISM/PaHM yet. 6108700 (Feb 24, 2023): Laura L. fixed a bug in wwm_friction 46767d2 (April 24, 2023): changed hybrid ELM-WENO, by augmenting ELM elem with 1 layer of extra ELM elements to reduce 'shocks' experienced by WENO stencil to help dispersion issue; 594bf10 (May 9, 2023): deflated global nc and hotstart scribe outputs. However, deflate is not done in combine_hotstart7.f90 as it seems to cause hang in restart; a6fd5cb (May 15, 2023): revamped nws=4 to allow more variables for 3D. The input needed is 'atmos.nc'. a832e4fd (Aug 15, 2023): renamed LAP routines and tridag to avoid conflicts with other ESMs. Changes in input and output format \u00b6 The info below can also be found in src/Readme.beta_notes. Most changes are made in param.in (now renamed as param.nml ). Tag stofs3d-atl.v2.1.0 (identical to v5.11.0): for NOAA STOFS3D Atlantic operational forecast release Tag v5.11.0: (Aug 2022) ae1c210 (14 June 2023): ishapiro=2 now needs shapiro.gr3 (variable coefficients); a6fd5cb (15 May, 2023): revamped nws=4; input is 'atmos'nc'. It needs wind and air pressure at least. If ihconsv/=0, it should also contain 2 heat fluxes ('solar' and 'downwardNetFlux'; the latter is the net surface heat flux). If isconsv/=0, it should also contain 2 salt fluxes: 'prate' and 'evap'. ae67c5e1 (24 April 2023): add USE_NWM_BMI (with if_source/=0) for NWM work; a248ce1d (24 April 2023): replaced nws=3 with USE_ATMOS (together with nws=2); f8e15ee (11 Oct 2022): added lev_tr_source(:)=0 option to allow source injecton to the entire water column; bc113eb2 (30 Sep 2022): added a new flag 'iflux_out_format' to control flux.out format; 24a2723 (27 Sep 2022): [merged PR from LRU] new options related to vegetation effects on WWM. Added iof_wwm(31) as dissipation due to vegetation. Also nws=-3: surface stress formulation from Donelan et al. (1993) based on the wave age; c94b2ca (1 Sep 2022): added 'iof_ugrid' to output UGRID metadata for 3D outputs; a0960ed (25 Aug 2022): added 'iprecip_off_bnd' to optionally turn off precip near land bnd (to avoid some spurious plumes near tropical islands etc); ed26f60 (25 Aug 2022): removed 'impose_net_flux' and replaced it with IMPOSE_NET_FLUX (so this won't be actively supported); Tag stofs3d-atl.v1.1.0 (identical to v5.10.0): for NOAA STOFS3D Atlantic operational forecast release Tag v5.10.0: (13 July, 2022) d03830e (16 May 2022): removed the 2 extra lines required in partition.prop (so it's identical to global_to_local.prop now); a71ea69 (12 May 2022): removed ioffline_partition and replaced it with CPP ( NO_PARMETIS ) to allow build without ParMETIS lib; renamed global_to_local.in as partition.prop ; da90a33 (2 May 2022): removed itr_met=1,2 ; 2165224 (29 April 2022): added optional offline partitioning ioffline_partition to bypass ParMETIS; if on, needs global_to_local.in ; 567b612 (28 April 2022): added new WWM outputs and re-ordered after iof_wwm(26) ; zCoordinate outputs made optional (for performance test); 6524e19 (27 April 2022): a few more WWM related parameters under VOR ( turbinjds,alpha,wfwvor_streaming ) and new WWM outputs, after merging with lrdev_updates ; d44dbdf (1 April, 2022): added an optional threshold inflation ratio for mass conversation for ICM: rinflation_icm 6f367d0 (30 Mar 2022): added optional vertical levels to inject source tracer conventration: lev_tr_source ; 7cc7f27 (30 Mar 2022): added an optional threshold depth for mass conversation for ICM: h_massconsv ; 1788867 (16 Mar 2022): added optional parameters for S exchange (split from heat exchange): i_hmin_salt_ex,hmin_salt_ex ; dcd5356 (31 Jan 2022): removed ramp flags except nramp_elev (use dramp* <=0 to turn off ramp): nramp, nrampbc, nrampwind, nrampwafo,nramp_ss ; removed the optional input shapiro_min.gr3 ; 80f1caa (26 Jan 2022): added 4 parameters in ice.nml : albsn,albsnm, albi,albm d792ed0 (18 Jan 2022): added 2 new ice parameters: ice_atmos_stress_form and cdwin0 ; b4d2214 (7 Jan 2022): added a new parameter nu_sum_mult to allow sum/product of final relax constants for tracer nudging; f9f0844 (3 Jan 2022): ICE module, added 2 new parameters: lead_closing, Saterm . Also changed ice-wind stress formula; 7455d5d (30 Dec 2021): added a new option nws=-1 (PaHM, Parametric Hurricane Model); 91c91a7 (17 Dec 2021): ICE module, added new parameters: ncyc_fct, depth_ice_fct . Also requires ice_fct.gr3 now; 0e2f90e (17 Dec 2021): added a new parameter in ice.nml mevp_coef and 2 related ones: mevp_alpha[34] 2a7647d (24&29 Nov 2021): added a new parmater loadtide_coef for iloadtide=2,3 ; a7a0b2b (17 Oct 2021): restored iwindoff ; afc7b1a (11 Oct 2021): changed vgrid.in format for ivcor=1 to facilitate parallel read (use change_vgrid.f90 to convert) e9aec89 (1 Oct 2021): added most module outputs; order of flags changed in: ICE, ANALYSIS, SED; 85b585a (1 Sept 2021): add zcor output flag as iof_hydro(25) ; rest of hydro output flags ( iof_hydro ) shifted by 1; 8efc374 (30 Aug 2021): first version of scribe dictated I/O (as an option); 1902c1e (16 July 2021): changed hotstart.nc : added nsteps_from_cold and cumsum_eta for DA; Tag v5.9.0: 657157a (1 July, 2021) e281d94 (25 June 2021): added a new option for SAL (Stepanov & Hughes 2004): iloadtide=3 ; bfb4afc (18 June, 2021): added an optional input shapiro_min.gr3 to be used with ishapiro=2 ; d07d75d (April 21, 2021): added T,S in required inputs for offline transport (to use hydro only results); b66e554 (April 14, 2021): added ishapiro=2 - Smagorinsky like filter option. In this option, shapiro0 is the coefficient; b43afea (April 2, 2021): changed x,y to double in nc outputs (for newer visIT); 9150d86 (Mar 31, 2021): added a new SAL option ( iloadtide=2 ) using a simple scaling; 084e149 (Feb 25, 2021): Removed parameters: ibtrack_openbnd , iwindoff , dzb_decay (with hardwire); also removed option for negative roughness. Fixed race condition for marsh module. 3576c9c (Jan 24, 2021): added new option for source/sink input: if_source=-1 requires source.nc (which includes elem list inside; allows different time steps and # of records for volume/mass source/sinks. Also, now the source/sink values in .th must be single precision (not double); bcdfce6 (Jan 6, 2021): added main switch for nc output nc_out (useful for other programs to control outputs); 28ff9d1 (Dec 16, 2020): added optional self-attraction loading tides; if iloadtide=1 , need amp/phases in loadtide_[FREQ].gr3 (freq's shared with tidal potential); f8ba470 (Dec 3, 2020): Added a new option ( meth_sink ) to treat net sink: if an elem is dry with a net sink, vsource is reset to 0; f9043e2 (Nov. 12, 2020): merged with LRU branch wwm_lr ; removed sav_cd ( isav=1 now requires sav_cd.gr3 ). New parameters related to WWM: fwvor_advxy_stokes , fwvor_advz_stokes , fwvor_advz_stokes , fwvor_breaking , cur_wwm , wafo_obcramp ; Changes in WWM .nml: ALPBJ ->B_ALP , BRHD->BRCR . 8083cfa (Nov. 10, 2020): added option for offline transport solver only ('itransport_only'); 7e9ff0a (Aug 20, 2020): added two options (selected by i_hmin_airsea_ex ) for locally turning off heat/salt exchange. i_hmin_airsea_ex=1 : exchange turned off if local grid depth<hmin_airsea_ex; i_hmin_airsea_ex=2 : exchange turned off if local water depth<hmin_airsea_ex This replaces the change made by adde1aa (July 8, 2020): added a new parameter hmin_airsea_ex (min total water depth for heat/salt exchange); 2f7bab1 (Jun 28,2020): reorganized ICM process (rates/fluxes) and added output flag in param.nml . 1477780 (May 8, 2020): changed sediment.in to sediment.nml. BEDLOAD_COEFF \\(\\rightarrow\\) bedload_coeff , NEWLAYER_THICK \\(\\rightarrow\\) newlayer_thick , IMETH_BED_EVOL \\(\\rightarrow\\) imeth_bed_evol SAND_SD50 \\(\\rightarrow\\) Sd50 , SAND_ERATE \\(\\rightarrow\\) Erate , SED_TYPE \\(\\rightarrow\\) iSedtype , SAND_SRHO \\(\\rightarrow\\) Srho , SAND_WSED \\(\\rightarrow\\) Wsed , SAND_TAU_CE \\(\\rightarrow\\) tau_ce , sed_morph_fac \\(\\rightarrow\\) morph_fac , poro_cst \\(\\rightarrow\\) porosity );","title":"Changelog"},{"location":"changelog.html#bug-fixes-and-major-algorithmic-changes","text":"R5178 : fix bug of saturate DO in ICM R5187 : incorporated dry bnd treatment from bndry (c/o Jens Wyrwa). However, to get good volume conservation it's best to keep all open flow bnd's wet all the time as before; R5191 : fixed a bug in iwind_form (accidentally re-init'ed after reading); R5202 : fixed a bug on negative ICM tracer concentration - check negative values before sending back to hydro. R5204 : a new option to control behavior of btrack when trajectory hots an open bnd (set vel=0 and exit). Goal is to eventually use this as default; 64b7181 : fixed an efficiency issue and added nc checks in ptrack3 (c/o Marcel Rieker) 2138e77 : Fixed a major bug introduced during reshuffling of _init for PDAF: need to call nodavel before sflux, as uu2,vv20 are needed there. 5ff2198 : revamped AGE module. B.C. now all should use 0. Only 0 and 1 should be used in AGE_hvar_[1:ntr/2].ic , where ntr is @ of age tracers, and the code will 'hold' concentration at 1 at those prisms (level specified in param.nml) that have 1 as i.c. I.C. in AGE_hvar_[ntr/2+1:ntr].ic should =0 . Injecting '1' at dry elem's is allowed but results may be harder to interpret. 6cec698 : bug fix for spherical coord in WWM (around dateline); c46c7bd (Feb 14, 2020): Fei tweaked WENO solver (wrt upwind); d3adb2c (Feb 14, 2020): changed to bilinear interp for HYCOM hot and nudging scripts (to speed up); 7506147 (Mar 1, 2020): add limiter for settling vel to avoid char line out of bnd; 5665418 (Mar 18, 2020): PR from Baptiste mengual for SED3D ( sed_frition.F90 merged after the rest). eb00a00 (Mar 31, 2020): added 12th tracer model ( USE_DVD of Klingbeil) aaf1306 (April 4, 2020): added hybrid ELM transport for efficiency (via branch hybrid_ELM); 40955ab (April 16, 2020): replaced the fatal error in nadv=2 (aptivity trap) with exit; e703189 (May 6, 2020): reverted to old simple approach for depositional mass (c/o Baptiste Mengual); 14e201f (May 7, 2020): switched to ParMETIS v4.0.3; 33fb37f (Jun 30, 2020): fixed a bug in ielm_transport (Fei Y.); 55910d1 (July 31, 2020; via branch mem_leak_nc4): reverted the change in schism_io (close/open nc output after/b4 each write, to accommodate PDAF's flexible mode), as this has caused a lot of mem leaking (discovered by Nicole C. when testing ICM). eaf9093 (Aug 2020): Baptiste M. modified the computation of the bottom shear stress under combined waves and currents in SED3D 4ac56df (Aug 2020): Paul Ryan and Claire Trenham (CSIRO) fixed some init array issues in hydro and WWM. 7e9ff0a (Aug 20, 2020): Fei Y fixed a msource bug (init of msource at 0 at elem's not in source_sink.in led to ice rain; f311026 (Aug. 27, 2020): reverted init of msource to 0 for tracers other than T,S, c/o Nicole Cai. Using ambient values for other tracers can lead to artificial and additional accumulation of nutrients; 00b6f16 (Nov. 9, 2020): PR #21 from Kijin merged (SED): changed method to compute near bottom vel for \\(LSC^2\\) . 8083cfa (Nov. 10, 2020): added option for transport solver only ( itransport_only ) 6dc44d3 (Dec 14, 2020): Fixed a bug, thanks to Kevin Kartin, on vortex formulism of wave force (missing a factor of area() in \\(I_4\\) ); 28ff9d1 (Dec 16, 2020): added optional self-attraction loading tides. The option shares some constants with tidal potential: freq names and cut-off depth; b1bcaa0 (April 20, 2021): removed most of goto . Remaining ones: harm.F90 , lap.F90 , WWM ; 0cec024 (April 21, 2021): bug fix in misc_subs c/o of Fei ( inunfl=1 : nodeA in final extrap stage may be interface node); fb30239 (April 22, 2021): bug fix for ellipsoidal earth (tensor frames). fb79cdc (May 26, 2021): in interpolate_depth_structured2* , added an option to shift 1/2 cell for ll corner (c/o Charles Seaton); 5e87c24 (June 9, 2021): more changes in interpolate_depth_structured2* to extrap also into right/upper sides. 843c40f (19 June, 2021): fixed a bug in ptrack3 (pt_in_poly3; c/o Jilian Xiong) that affects quads; b2cf92b (29 June, 2021): fixed a bug in station outputs in basin scale cases ics=2 (local proj is not accurate if the station is far away from the local frame); Tag v5.9.0: 657157a (1 July, 2021) a9f8f6c (8 July, 2021): fixed a bug in iloadtide=1 (index error). Also revamped reading of input files for large core counts. ab46def (20 July, 2021): merged multi ice model (CICE) from Qian Wang. 70db927 (11 Aug 2021): bug fixes from Qian Wang on ice matrix (ghost nodes) 8efc374 (30 Aug 2021): first version of scribe dictated I/O (as an option) 53689f4 (12 Sept 2021): fixed a bug in weno transport introduced in e794d8c (23 Aug 2021). c7dd516 (27 Sept 2021): AGE module tweaked (clamped @ i.c. at injection points for both concentrations). (19 Oct 2021): filtered isolated wet nodes during outputs (should not change other results); 7455d5d (30 Dec 2021): added a new option nws=-1 (PaHM, Parametric Hurricane Model); 7455d5d (30 Dec 2021): added Fariall air-sea exchange (USE_BULK_FAIRALL) c/o Jerome Lefevre; e288f9a (31 Jan 2022): removed the restriction of counter-clockwise orientation in sflux grid; dde345f (7 April 2022): fixed a bug in sflux, invoked only if nws=2, ihconsv=1, and iwind_form=0: uninit'ed stress values. 6524e19 (27 April 2022): merged with La Rochelle group on WWM (VOR); cd0b2a3 (14 Aug 2022): [via Qian_pole_treatment] changed nodalvel() under ics=2; commented out a frame transformation for better vel near poles. 510874ec (19 Sep 2022): upgraded all nf_ to nf90_ (in sflux) 24a2723 (27 Sep 2022): PR merge with LRU's modifications for WWM (mostly related to vegetation effects on WWM) 1828489 (10 Oct 2022): bug fix on msource (mismatch in bcast array dimension) 87c7611f (21 Oct 2022): PR91 merge from Dr. Jerome Lefevre a) Add GAHM (Generalized Asymmetric Holland Model) in PaHM/parwind.F90 as a second alternative to Holland Model (see details https://wiki.adcirc.org/Generalized_Asymmetric_Holland_Model and https://noaa-ocs-modeling.github.io/PaHM/pahm_manual.pdf); b) Add support for Hurricanes in both South and North Hemisphere (in HM and GAHM models); c) Test using Niran, SW Pacific: (See inside src/Core/PaHM/inputs/ : a track for Cyclone Niran \"niran2021-bdeck.dat\" and my comparison with HM and GAHM versus a weather model output); d) CAUTION // CAUTION : To switch from HM (1) or GAHM (10), the user still need to change the value of \"modelType\" in Pahm_Utilities.F90 (line 3210) and recompile schism; e) CAUTION / CAUTION : Unlike in noaa-ocs-modeling.github.io/PaHM, there is not Control File support in SCHISM/PaHM yet. 6108700 (Feb 24, 2023): Laura L. fixed a bug in wwm_friction 46767d2 (April 24, 2023): changed hybrid ELM-WENO, by augmenting ELM elem with 1 layer of extra ELM elements to reduce 'shocks' experienced by WENO stencil to help dispersion issue; 594bf10 (May 9, 2023): deflated global nc and hotstart scribe outputs. However, deflate is not done in combine_hotstart7.f90 as it seems to cause hang in restart; a6fd5cb (May 15, 2023): revamped nws=4 to allow more variables for 3D. The input needed is 'atmos.nc'. a832e4fd (Aug 15, 2023): renamed LAP routines and tridag to avoid conflicts with other ESMs.","title":"Bug fixes and major algorithmic changes"},{"location":"changelog.html#changes-in-input-and-output-format","text":"The info below can also be found in src/Readme.beta_notes. Most changes are made in param.in (now renamed as param.nml ). Tag stofs3d-atl.v2.1.0 (identical to v5.11.0): for NOAA STOFS3D Atlantic operational forecast release Tag v5.11.0: (Aug 2022) ae1c210 (14 June 2023): ishapiro=2 now needs shapiro.gr3 (variable coefficients); a6fd5cb (15 May, 2023): revamped nws=4; input is 'atmos'nc'. It needs wind and air pressure at least. If ihconsv/=0, it should also contain 2 heat fluxes ('solar' and 'downwardNetFlux'; the latter is the net surface heat flux). If isconsv/=0, it should also contain 2 salt fluxes: 'prate' and 'evap'. ae67c5e1 (24 April 2023): add USE_NWM_BMI (with if_source/=0) for NWM work; a248ce1d (24 April 2023): replaced nws=3 with USE_ATMOS (together with nws=2); f8e15ee (11 Oct 2022): added lev_tr_source(:)=0 option to allow source injecton to the entire water column; bc113eb2 (30 Sep 2022): added a new flag 'iflux_out_format' to control flux.out format; 24a2723 (27 Sep 2022): [merged PR from LRU] new options related to vegetation effects on WWM. Added iof_wwm(31) as dissipation due to vegetation. Also nws=-3: surface stress formulation from Donelan et al. (1993) based on the wave age; c94b2ca (1 Sep 2022): added 'iof_ugrid' to output UGRID metadata for 3D outputs; a0960ed (25 Aug 2022): added 'iprecip_off_bnd' to optionally turn off precip near land bnd (to avoid some spurious plumes near tropical islands etc); ed26f60 (25 Aug 2022): removed 'impose_net_flux' and replaced it with IMPOSE_NET_FLUX (so this won't be actively supported); Tag stofs3d-atl.v1.1.0 (identical to v5.10.0): for NOAA STOFS3D Atlantic operational forecast release Tag v5.10.0: (13 July, 2022) d03830e (16 May 2022): removed the 2 extra lines required in partition.prop (so it's identical to global_to_local.prop now); a71ea69 (12 May 2022): removed ioffline_partition and replaced it with CPP ( NO_PARMETIS ) to allow build without ParMETIS lib; renamed global_to_local.in as partition.prop ; da90a33 (2 May 2022): removed itr_met=1,2 ; 2165224 (29 April 2022): added optional offline partitioning ioffline_partition to bypass ParMETIS; if on, needs global_to_local.in ; 567b612 (28 April 2022): added new WWM outputs and re-ordered after iof_wwm(26) ; zCoordinate outputs made optional (for performance test); 6524e19 (27 April 2022): a few more WWM related parameters under VOR ( turbinjds,alpha,wfwvor_streaming ) and new WWM outputs, after merging with lrdev_updates ; d44dbdf (1 April, 2022): added an optional threshold inflation ratio for mass conversation for ICM: rinflation_icm 6f367d0 (30 Mar 2022): added optional vertical levels to inject source tracer conventration: lev_tr_source ; 7cc7f27 (30 Mar 2022): added an optional threshold depth for mass conversation for ICM: h_massconsv ; 1788867 (16 Mar 2022): added optional parameters for S exchange (split from heat exchange): i_hmin_salt_ex,hmin_salt_ex ; dcd5356 (31 Jan 2022): removed ramp flags except nramp_elev (use dramp* <=0 to turn off ramp): nramp, nrampbc, nrampwind, nrampwafo,nramp_ss ; removed the optional input shapiro_min.gr3 ; 80f1caa (26 Jan 2022): added 4 parameters in ice.nml : albsn,albsnm, albi,albm d792ed0 (18 Jan 2022): added 2 new ice parameters: ice_atmos_stress_form and cdwin0 ; b4d2214 (7 Jan 2022): added a new parameter nu_sum_mult to allow sum/product of final relax constants for tracer nudging; f9f0844 (3 Jan 2022): ICE module, added 2 new parameters: lead_closing, Saterm . Also changed ice-wind stress formula; 7455d5d (30 Dec 2021): added a new option nws=-1 (PaHM, Parametric Hurricane Model); 91c91a7 (17 Dec 2021): ICE module, added new parameters: ncyc_fct, depth_ice_fct . Also requires ice_fct.gr3 now; 0e2f90e (17 Dec 2021): added a new parameter in ice.nml mevp_coef and 2 related ones: mevp_alpha[34] 2a7647d (24&29 Nov 2021): added a new parmater loadtide_coef for iloadtide=2,3 ; a7a0b2b (17 Oct 2021): restored iwindoff ; afc7b1a (11 Oct 2021): changed vgrid.in format for ivcor=1 to facilitate parallel read (use change_vgrid.f90 to convert) e9aec89 (1 Oct 2021): added most module outputs; order of flags changed in: ICE, ANALYSIS, SED; 85b585a (1 Sept 2021): add zcor output flag as iof_hydro(25) ; rest of hydro output flags ( iof_hydro ) shifted by 1; 8efc374 (30 Aug 2021): first version of scribe dictated I/O (as an option); 1902c1e (16 July 2021): changed hotstart.nc : added nsteps_from_cold and cumsum_eta for DA; Tag v5.9.0: 657157a (1 July, 2021) e281d94 (25 June 2021): added a new option for SAL (Stepanov & Hughes 2004): iloadtide=3 ; bfb4afc (18 June, 2021): added an optional input shapiro_min.gr3 to be used with ishapiro=2 ; d07d75d (April 21, 2021): added T,S in required inputs for offline transport (to use hydro only results); b66e554 (April 14, 2021): added ishapiro=2 - Smagorinsky like filter option. In this option, shapiro0 is the coefficient; b43afea (April 2, 2021): changed x,y to double in nc outputs (for newer visIT); 9150d86 (Mar 31, 2021): added a new SAL option ( iloadtide=2 ) using a simple scaling; 084e149 (Feb 25, 2021): Removed parameters: ibtrack_openbnd , iwindoff , dzb_decay (with hardwire); also removed option for negative roughness. Fixed race condition for marsh module. 3576c9c (Jan 24, 2021): added new option for source/sink input: if_source=-1 requires source.nc (which includes elem list inside; allows different time steps and # of records for volume/mass source/sinks. Also, now the source/sink values in .th must be single precision (not double); bcdfce6 (Jan 6, 2021): added main switch for nc output nc_out (useful for other programs to control outputs); 28ff9d1 (Dec 16, 2020): added optional self-attraction loading tides; if iloadtide=1 , need amp/phases in loadtide_[FREQ].gr3 (freq's shared with tidal potential); f8ba470 (Dec 3, 2020): Added a new option ( meth_sink ) to treat net sink: if an elem is dry with a net sink, vsource is reset to 0; f9043e2 (Nov. 12, 2020): merged with LRU branch wwm_lr ; removed sav_cd ( isav=1 now requires sav_cd.gr3 ). New parameters related to WWM: fwvor_advxy_stokes , fwvor_advz_stokes , fwvor_advz_stokes , fwvor_breaking , cur_wwm , wafo_obcramp ; Changes in WWM .nml: ALPBJ ->B_ALP , BRHD->BRCR . 8083cfa (Nov. 10, 2020): added option for offline transport solver only ('itransport_only'); 7e9ff0a (Aug 20, 2020): added two options (selected by i_hmin_airsea_ex ) for locally turning off heat/salt exchange. i_hmin_airsea_ex=1 : exchange turned off if local grid depth<hmin_airsea_ex; i_hmin_airsea_ex=2 : exchange turned off if local water depth<hmin_airsea_ex This replaces the change made by adde1aa (July 8, 2020): added a new parameter hmin_airsea_ex (min total water depth for heat/salt exchange); 2f7bab1 (Jun 28,2020): reorganized ICM process (rates/fluxes) and added output flag in param.nml . 1477780 (May 8, 2020): changed sediment.in to sediment.nml. BEDLOAD_COEFF \\(\\rightarrow\\) bedload_coeff , NEWLAYER_THICK \\(\\rightarrow\\) newlayer_thick , IMETH_BED_EVOL \\(\\rightarrow\\) imeth_bed_evol SAND_SD50 \\(\\rightarrow\\) Sd50 , SAND_ERATE \\(\\rightarrow\\) Erate , SED_TYPE \\(\\rightarrow\\) iSedtype , SAND_SRHO \\(\\rightarrow\\) Srho , SAND_WSED \\(\\rightarrow\\) Wsed , SAND_TAU_CE \\(\\rightarrow\\) tau_ce , sed_morph_fac \\(\\rightarrow\\) morph_fac , poro_cst \\(\\rightarrow\\) porosity );","title":"Changes in input and output format"},{"location":"code-contribution.html","text":"The information presented in this chapter is mostly intended for developers or anyone who wishes to work on the code. To know more about how to contribute your code see CONTRIBUTING.md on SCHISM github repo. General info \u00b6 SCHISM was written in MPI FORTRAN 90. After svn revision 5225, we have migrated to github . Figure 1 shows the directory structure of the SCHISM github repository schism. General public have access to all branches. SCHISM github repository. Figure 2 shows its main work flow and major code blocks. Two files inside src/ ( Hydro/schism_init.F90 and Hydro/schism_step.F90 ) represent bulk of the hydro code, and are driven by a master program ( Driver/schism_driver.F90 ). The global variables are defined in Core/schism_glbl.F90 , and the message passing routines are defined in Core/schism_msgp.F90 . SCHISM code work flow. The percentages are estimates from a test case with an earlier version and may not be up to date. The domain decomposition is done using ParMETIS graph partitioning library (included in the src/ ). Figure 3 shows an example of sub-domains generated by this lib. Domain decomposition. Each color represents a sub-domain (\u2018resident domain\u2019) taken by a MPI process and the thick black polygon represents the \u2018augmented\u2019 (=resident+ghost) domain of process 6. The Utility dir has a lot of useful utility scripts for pre- and post-processing. The header of each program generally has info on its purpose and instructions on how to use it. ACE : source code and install notes for ACE tools; the manual can be found on Forum . Combining_Scripts : FORTRAN and perl scripts used to gather outputs from SCHISM (e.g., outputs/schout_0*_[stack number].nc etc) into one binary file ( schout_[stack_number].nc ). Grid_Scripts : FORTRAN codes to interpolate depths from DEM files in either structured grid (raster) or unstructured grid format. While ACE/xmgredit5 can do similar things, these scripts are mostly for interpolating from very large DEM files. Gen_Hotstart : scripts for preparing hotstart.nc from e.g., netcdf outputs from a structured-grid model. Pre-Processing : various scripts for pre-processing (checking, viz etc) OneWayNestScripts : scripts for 1-way nesting, by preparing *[23]D.th.nc (elevation, horizontal velocity, salinity and temperature boundary condition) that can be used for the 'small-domain' run. Particle_Tracking : particle tracking code that uses SCHISM's outputs for 3D tracking. Post-Processing-Fortran : FORTRAN codes for extracting time series at selected 3D points (including transects). You can modify these codes for your own purposes. Sflux_nc : matlab scripts useful for preparing your own .nc files for sflux/ . NARR_util/ has scripts to prepare .nc files from NCEP's NARR products. SMS : scripts to convert between .2dm of SMS and .gr3 . Vis_Matlab : matlab scripts for viz. At the moment, these scripts have not been updated to handle \\(LSC^2\\) grid. Domain partitioning \u00b6 The domain is first portioned into non-overlapping sub-domains (in element sense; see Figure 3 ) using ParMETIS. Then each sub-domain is augmented with 1 layer of ghost elements. This is accomplished by the call partition_hgrid() early in the main program. After calling aquire_hgrid(.true.) immediately after that, the elements, nodes, sides in each augmented and non-augmented (i.e., without ghosts) domains are shown in Figure 3 . The corresponding variable denoting number of Elements, Nodes, and Sides are given in the following table. Intuition is typically followed although there are exceptions as will be described below. Global Local non-augmented Ghost Augmented Elements ne_global ne neg nea=ne+neg Nodes np_global np npg npa=np+npg Sides ns_global ns nsg nsa=ns+nsg The call to ParMETIS routine is as follows - call ParMETIS_V3_PartGeomKway ( vtxdist , xadj , adjncy , vwgt , adjwgt , wgtflag , & numflag , ndims , xyz , ncon , nproc , tpwgts , ubvec , options , & edgecut , part , comm ) p : # of processors; n : total # of vertices (local) in graph sense; m : total # of neighboring vertices (\"edges\"); double counted between neighboring vertice u and v. ncon : # of weights for each vertex. int(in) vtxdist(p+1) : Processor j stores vertices vtxdist(j):vtxdist(j+1)-1 int (in) xadj(n+1), adjncy(m) : locally, vertex j 's neighboring vertices are adjncy(xadj(j):xadj(j+1)-1) . adjncy points to global index; int(in) vwgt(ncon*n), adjwgt(m) : weights at vertices and \"edges\". Format of adjwgt follows adjncy; int(in) wgtflag : 0 : none ( vwgt and adjwgt are NULL); 1 : edges ( vwgt is NULL ); 2 :vertices ( adjwgt is NULL ); 3 : both vertices & edges; int(in) numflag : 0 : C-style numbering from 0; 1 : FORTRAN style from 1; int(in) ndims : 2 or 3 (D); float(in) xyz(ndims*n) : coordinate for vertex j is xyz(j*ndims:(j+1)*ndims-1) (C style); ndims*(j-1)+1: ndims*j (FORTRAN style); int(in) nparts : # of desired sub-domains (usually nproc ); float(in) tpwgts(ncon*nparts) : =1/nparts if sub-domains are to be of same size for each vertex weight; float(in) ubvec(ncon) : imbalance tolerance for each weight; int(in) options : additonal parameters for the routine (see above); int(out) edgecut : # of edges that are cut by the partitioning; int(out) part() : array size = # of local vertices. It stores indices of local vertices. Arrays and constant \u00b6 llist_type :: iegl(iegb) : iegb is a global element #. If the element is resident (not ghost), iegl(iegb)%rank=myrank , and iegl(iegb)%id = local element index , and iegl%next=null . If iegb is a ghost, then iegl list has two entries: myrank and the rank where iegb is resident. All processors have this info, but the lists are different (1st entry is usually myrank etc). llist_type :: ipgl(ipgb) : ipgb is a global node #. Use this list only when the node is resident (not ghost); it\u2019s confusing when ipgb is ghost. If ipgb is resident, ipgl(ipgb)%rank=myrank , and ipgl(ipgb)%id = local node index . ipgl%next%next%next.... is the linked list, with ranks in ascending order. Unless ipgb is an interface node (i.e., resident in more than 1 process), the list has only 1 entry. All processors have this info, but the lists are different (1st entry is usually myrank etc). llist_type :: isgl(isgb) : isgb is a global side #. Similar to ipgl , if the side is resident (not ghost), isgl(isgb)%rank=myrank , and isgl(isgb)%id = local side index . isgl%next%next... is the list, with ranks in ascending order. All processors have this info, but the lists are different (1st entry is usually myrank etc). int :: ielg(ie), iplg(ip), islg(isd) : The global element index of local element ie in the augmented domain. Similar for the other two (nodes/sides). int :: iegrpv(iegb) : The rank # for global element iegb (before augmenting the domain). Used mainly in partitioning the grid. Arrays that have similar meaning between global and local aug. domains, i.e., they do not have problem of getting outside the aug. domain: i34 , elnode (old name: nm ), elside ( js ), ssign , snx , sny . Arrays that need special attention in the aug. domain - int :: ic3(1:i34(), ie) \u2013 positive if the neighbor element is inside the aug. domain as well (and in this case it is the local index of the neighbor element); 0 if (global) boundary; negative if the neighbor element is outside the aug. domain and in this case, the absolute value is the global element index. int :: nne(ip) \u2013 total # of neighbor elements around local node ip , including those outside the aug. domain (i.e., same as nnegb() ). int :: indel(1: nne(ip),ip) \u2013 surrounding element indices. If inside aug. domain, this is the local element index; if outside, this is the negative of the global element index. int :: iself(1: nne(ip),ip) \u2013 same as global iselfgb , i.e., the elemental local index for node ip in neighbor element indel() (even if it is outside). int :: nnp(ip) \u2013 total # of surrounding nodes for node ip , excluding all nodes outside the aug. domain. For SCHISM, include all nodes outside. int :: indnd(1: nnp(ip),ip) \u2013 list of surrounding nodes, excluding all nodes outside the aug. domain. For SCHISM, all nodes outside will have negative global index returned. int :: isdel(1:2,isd) & isidenode(1:2,isd) \u2013 order of the two adjacent elements follows global indices, and so the vector from node 1 to 2 in isidenode(1:2,isd) forms local y-axis while the vector from element 1 to 2 in isdel(1:2,isd) forms local x-axis. Therefore either of isdel(1:2,isd) can be negative. The element index is local (positive) if it is inside the aug. domain; otherwise the minus of global element index is returned. The local side isd is on the boundary if and only if isdel(2,isd)=0 , and in this case, isdel(1,isd) must be inside the aug. domain (i.e., positive) (if isd is resident). If isd is resident and not ghost, isdel() has the same meaning as serial code, i.e., is(1,isd)>0 (inside the aug. domain), and isdel(2,isd)>=0 , and isd is on the boundary if and only if isdel(2,isd)=0 . double :: delj(isd) \u2013 meaningful only if isd is resident. Boundary arrays : Most arrays point to global bnd segment #. Most B.C. arrays are global as well. nope_global \u2013 total # of open bnd segements in the global domain. nope \u2013 total # of open bnd segements in the aug. domain. iopelg(1:nope) \u2013 returns global open bnd segment # for a local open bnd segment. iopegl(0,k) - # of local fragmentations of global open bnd segment k. iopegl(j,k) - local segment # of jth ( 1<=j<=iopegl(0,k) ) fragmentation of global open bnd segment k. nond(1:nope) \u2013 total # of open bnd nodes on each segment. The corresponding global array is nond_global() . iond(nope,1: nond(1:nope)) \u2013 list of local node indices on each open bnd segment. The corresponding global array is iond_global() . nland - total # of land bnd segements in the aug. domain. nland_global is global. nlnd(1:nland) - total # of land bnd nodes on each segment. ilnd(nland,1: nlnd(1:nland)) \u2013 list of local node indices on each land bnd segment. nosd(nope) (ELCIRC) - # of open bnd sides on each segment. iosd(nope, 1: nosd(nope)) (ELCIRC) \u2013 list of open bnd side on each segment. noe(nope) (ELCIRC) - # of open bnd elements on each segment. ioe(nope, 1: noe(nope)) (ELCIRC) \u2013 list of open bnd elements on each segment. isbe(2,1:nea) (ELCIRC) \u2013 if the element is on the local open bnd, this returns the local segment # and element #. 0 otherwise. isbs() (ELCIRC) \u2013 similar to isbe . isbnd(-2:2,ip) (SCHISM) - If ip is on 1 open bnd only, isbnd(1,ip) points to the global segment # of that open bnd and isbnd(2,ip)=0 ; if ip is on 2 open bnds, isbnd(1:2,ip) point to the global segment #s for the 2 open bnds. If ip is on land bnd only (i.e., not on open bnd), isbnd(1,ip)= 1 and isbnd(2,ip)=0 . If ip is an internal node, isbnd(1:2,ip)=0 . Therefore, ip is on open bnd if isbnd(1,ip)>0 (and in this case isbnd(2,ip) may also be positive, even though isbnd(2,ip) may be outside the aug. domain), on land bnd (not on any open bnd) if isbnd(1,ip)= 1 , and an internal node if isbnd(1,ip)=0 . If on open bnd, isbnd(-2:-1,ip) are global index (i.e., isbnd(-1,ip) th node on the isbnd(1,ip) th open bnd); isbs(nsa) - positive if a local side is on the global open bnd (in this case, isbs() is the global segment #); 1 if it is on land bnd; 0 if internal side. iettype , ifltype , itetype , and isatype all take global bnd segment as argument; other b.c. arrays ( eth etc) are also global. uth(nvrt,nsa) , vth(nvrt,nsa) \u2013 local b.c. for ifltype/=0 for a local side. uthnd(nvrt,mnond_global, nope_global) , vthnd() \u2013 global arrays. elbc(ip) \u2013 ip is a local node. Arrays defined in elfe_msgp.F90 nnbr - # of neighbor processors (excluding myrank ). nbrrank(nnbr) \u2013 rank of each neighbor processor. int :: ranknbr(0:nproc-1) \u2013 neighbor # for each processor (0 if not neighbor). nerecv(nnbr) - # of elements to be received from each neighbor. ierecv(1: nerecv(nnbr),nnbr) \u2013 list of element indices (ghost in myrank ) to be received from each neighbor (where the elements are resident and not ghost). nesend(nnbr) - # of elements to be sent to each neighbor. iesend(1: nesend(nnbr),nnbr) \u2013 list of element indices (local resident in myrank ) to be sent to each neighbor (where the elements are ghost). Similar for nodes/side ( nprecv , iprecv etc). A note on ghost exchange Since the message exchanges between processors have to wait for each other in order to communicate collectively, it's not necessary to synchronize the processes. Important MPI routines \u00b6 MPI_Recv int MPI_Recv ( void * buf , int count , MPI_Datatype datatype , int source , int tag , MPI_Comm comm , MPI_Status * status ) !Inputs: ! count - maximum number of elements in receive buffer (integer); ! datatype - datatype of each receive buffer element (handle); ! source - rank of source (integer); ! tag - message tag (integer); ! comm - communicator (handle). !Outputs: ! buf - initial address of receive buffer (choice); ! status - status object (Status). MPI_Irecv : nonblock receive. int MPI_Irecv ( void * buf , int count , MPI_Datatype datatype , int source , int tag , MPI_Comm comm , MPI_Request * request ) !Inputs: ! buf - initial address of receive buffer (choice); ! count - number of elements in receive buffer (integer); ! datatype - datatype of each receive buffer element (handle); ! source - rank of source (integer); ! Tag - message tag (integer); ! comm - communicator (handle). !Output: ! request - communication request (handle) MPI_Send int MPI_Send ( void * buf , int count , MPI_Datatype datatype , int dest , int tag , MPI_Comm comm ) !Inputs: ! buf - initial address of send buffer (choice); ! count - number of elements in send buffer (nonnegative integer); ! datatype - datatype of each send buffer element (handle); ! dest - rank of destination (integer); ! tag - message tag (integer); ! comm - communicator (handle). MPI_Isend : non-block send int MPI_Isend ( void * buf , int count , MPI_Datatype datatype , int dest , int tag , MPI_Comm comm , MPI_Request * request ) ! Inputs: ! buf - initial address of send buffer (choice); ! count - number of elements in send buffer (integer); ! datatype - datatype of each send buffer element (handle); ! dest - rank of destination (integer); ! tag - message tag (integer); ! comm - communicator (handle). !Output: ! request - communication request (handle). MPI_Allreduce : Combines values from all processes and distribute the result back to all processes int MPI_Allreduce ( void * sendbuf , void * recvbuf , int count , MPI_Datatype datatype , MPI_Op op , MPI_Comm comm ) ! Inputs: ! sendbuf - starting address of send buffer (choice); ! count - number of elements in send buffer (integer). Also the size of the output ! (i.e., ith elements from each processor are summed up and returned as ith element of output); ! datatype - data type of elements of send buffer (handle); ! op - operation (handle) (e.g., MPI_SUM, MPI_LOR); ! comm - communicator (handle). ! Output: ! recvbuf - starting address of receive buffer (choice). MPI_Reduce int MPI_Reduce ( void * sendbuf , void * recvbuf , int count , MPI_Datatype datatype , MPI_Op op , int root , MPI_Comm comm ) ! only difference from MPI_Allreduce is that the result is sent to rank \"root\". MPI_Gather : Gathers together values from a group of processes. int MPI_Gather ( void * sendbuf , int sendcnt , MPI_Datatype sendtype , void * recvbuf , int recvcount , MPI_Datatype recvtype , int root , MPI_Comm comm ) ! Inputs: ! sendbuf - starting address of send buffer (choice) ! sendcount - number of elements in send buffer (integer) ! sendtype - data type of send buffer elements (handle) ! recvcount - number of elements for any single receive (integer, significant ! only at root) ! recvtype - data type of recv buffer elements (significant only at root) (handle) ! root - rank of receiving process (integer) ! comm - communicator (handle) ! Output: ! Recvbuf - address of receive buffer (choice, significant only at root). The received values ! are stacked according to the rank number (i.e., first recvcount are from rank 0 etc). MPI_Allgatherv : Gathers data from all tasks and deliver it to all. int MPI_Allgatherv ( void * sendbuf , int sendcount , MPI_Datatype sendtype , void * recvbuf , int * recvcounts , int * displs , MPI_Datatype recvtype , MPI_Comm comm ) !Inputs: ! sendbuf - starting address of send buffer (choice); ! sendcount - number of elements in send buffer (integer) ! sendtype - data type of send buffer elements (handle); ! recvcounts - integer array (of length group size) containing the number of elements ! that are received from each process; ! displs - integer array (of length group size). Entry i specifies the displacement ! (relative to recvbuf) at which to place the incoming data from process i; ! recvtype - data type of receive buffer elements (handle); ! comm. - communicator (handle). ! Output: ! recvbuf - address of receive buffer (choice). MPI_Type_indexed : Creates an indexed datatype; the corresponding routine in MPI2 is mpi_type_create_indexed_block() . int MPI_Type_indexed ( int count , int blocklens [], int indices [], MPI_Datatype old_type , MPI_Datatype * newtype ) ! Inputs: ! count - number of blocks -- also number of entries in indices and blocklens; ! blocklens - number of elements in each block (array of nonnegative integers); ! indices - displacement of each block in multiples of old_type (array of integers); ! old_type - old datatype (handle). ! Output: ! newtype - new datatype (handle) Note The new MPI type treats multi-dimensional arrays in FORTRAN as 1D array, expanding with 1st index varying before 2nd etc. So this routine can be used to grab discontiguous data blocks from multi- dimensional arrays. So if a 2D array is a(nvrt,nea) the corresponding 1D array is illustrated below: \\[\\begin{equation*} nea \\stackrel{nvrt}{ \\begin{bmatrix} (1, 1) & (2, 1) & \\cdots & (nvrt, 1)\\\\ (1, 2) & (2, 2) & \\cdots & (nvrt, 2)\\\\ \\vdots & \\vdots & \\vdots & \\vdots\\\\ (1, nea) & (2, nea) & \\cdots & (nvrt, nea) \\end{bmatrix} } \\end{equation*}\\] Now suppose we need to grab all ghost elements iesend(1:nesend), these will correspond to rows iesend(i) of the table. In this case the # of blocks is nesend, block length is nvrt, and displacement of ith block is (iesend(i)-1)*nvrt. MPI_Barrier : Blocks until all process have reached this routine. int MPI_Barrier ( MPI_Comm comm ) ! Input: comm. - communicator (handle) MPI_Type_struct : Creates a struct datatype. int MPI_Type_struct ( int count , int blocklens [], MPI_Aint indices [], MPI_Datatype old_types [], MPI_Datatype * newtype ) ! Inputs: ! count - number of blocks (integer) ! also number of entries in arrays array_of_types, array_of_displacements and array_of_blocklengths; ! blocklens - number of elements in each block (array); ! indices \u2013 byte displacement of each block relative to the start of the type (array); ! old_types - type of elements in each block (array of handles to datatype objects). ! Output: ! newtype - new datatype (handle) MPI_Alltoall : Sends data from all to all processes. int MPI_Alltoall ( void * sendbuf , int sendcount , MPI_Datatype sendtype , void * recvbuf , int recvcnt , MPI_Datatype recvtype , MPI_Comm comm ) ! Inputs: ! sendbuf - starting address of send buffer (choice); ! sendcount - number of elements to send to each process (integer); ! sendtype - data type of send buffer elements (handle); ! recvcount- number of elements received from any process (integer); ! recvtype - data type of receive buffer elements (handle); ! comm. - communicator (handle). ! Outputs ! recvbuf - address of receive buffer (choice) I/O channels in SCHISM \u00b6 You need to exercise caution when dealing with parallel I/O especially for writing. For writing outputs, you\u2019d generally let only 1 process do the job, e.g. if ( myrank == 0 ) write ( 10 , * ) If you do need to have all processes write e.g. debug messages, you\u2019d consider using channel 12 which has been pre-set to point to multiple files from each MPI process (see below). Here are all I/O channel numbers currently used in different sub-models of SCHISM (and so you\u2019d avoid using them). A good way to find out if a channel is available is to issue the following cmd from src/ - grep \"(61\" */*.F90 # Looks for '(61' Please contact lead developer after you have selected a channel number to use in your module. Hydro/ : Channels between 8 and 200 are used by various codes for I/O. In particular - 101 to 100+noutputs (inclusive of both): reserved for global outputs (including from tracers like sediment, EcoSim, ICM, as well as WWM); 201-250: non-standard outputs (e.g. at sidecenters, prism centers); 251 to 259: reserved for station outputs; 16: this channel points to mirror.out (on rank 0), the main message output about the run. You should use it with if(myrank==0) . WWM 1100 to 1200: handles for inputs/outputs etc EcoSim 600: outputting some messages ICM 301 to 323: reading channels for non-point source inputs for ICM Sediment (SED and SED2D) 26, 2626 Following are some generic channels - 10, 31, 32 : used for one-off I/O \u2013 can be used by other sub-models as long as you close them immediately after use; 12 : this channel is initialized by different processes to point to files outputs/nonfatal_xxxx , where \u201cxxxx\u201d are the process IDs. Therefore it\u2019s very useful for debugging purpose; you can use it anywhere in your part of the code to dump messages to these files. Example code \u00b6 If you are working on the code you may be confused about the exchanges inside SCHISM. When should you use these? The first thing you need to remember when writing MPI code with domain decomposition is that a rank (or MPI 'process') only has info in its 'augmented' (=resident + ghost) domain, and knows absolutely nothing outside this region. Domain decomposition for code example. Consider Figure 4 . For example, you want to do averaging at each node of the sub-domain around its ball of elements. do i = 1 , np !not 'npa' sum1 = 0 sum_a = 0 do j = 1 , nne ( i ) ie = indel ( j , i ) sum1 = sum1 + stokes ( ie ) * area ( ie ) sum_a = sum_a + area ( ie ) enddo !j stokes_nd ( i ) = sum1 / sum_a enddo !i call exchange_p2d ( stokes_nd ) Notice that you'd use np instead of npa ( =np+npg ; augmented domain) here. For any resident node P , indel() is well defined (because again, Rank 1 has info in its augmented domain including the ghost zone), and so the loops make sense. As long as all ranks have same info in each others' ghost zones (which is the purpose of exchange routines), stokes_nd at an interface node (e.g. P ) will be same across ranks. However, for a ghost node Q , some surrounding elements are located outside the augmented domain (and in this case, indel() are actually negative!), and so if you use the same operation, erroneous values at ghost nodes would be generated. Therefore you cannot use npa in the outer loop. Now, after this loop is executed, what happens to the ghost nodes like Q ? Since they are excluded on Rank 1, the stokes_nd will be wrong there. Fortunately, some neighboring ranks have the correct values for these nodes, which are resident nodes in those neighboring ranks; e.g., Q is a resident node of Rank 0. So now different ranks will have different values at some overlapping nodes, and this needs to be avoided. In order to make sure each rank has correct (and up-to-date) values in its augmented domain, you need to follow this loop with an exchange routine. Remember that for the exchange routines to work, you need to define the exchanged array in the augmented domain - allocate ( stokes_nd ( npa )) !not 'np' in order to allow each rank to receive info in the ghost zone. Description of all exchange routines used in SCHISM can be found in schism_msgp.F90 . The above is just one example of when exchanges are needed. Usually this involves some kind of queries into a neighborhood, but beware that there are other circumstances where exchanges are necessary. The most important thing to remember A rank only has info in its 'augmented' domain, and knows absolutely nothing outside this region. In MPI code, it's crucial to make sure all ranks have identical values in overlapping zone. Now let's consider an example where no exchanges are needed. Say you want to simply go through all elements and update some arrays defined at elements: do i = 1 , nea !not 'ne' qdl_e ( i ) = cde ( i ) * dte / area ( i ) enddo !i Since all ranks have info of cde and area locally available, qdl_e will be correctly calculated even inside the ghost zones, and its values are the same cross ranks there (since cde and area are same cross ranks in the overlapping zones). So in this case you'd use nea instead of ne in the loop. Of course, there is nothing wrong with using ne in the loop followed by an exchange routine, but doing so would be less efficient and incur unnecessary communication cost. General code guide \u00b6 Here are some house rules for preparing your own code - No spaces between # (pre-processor) and if/else/end for CPP flag; Try to use the I/O channel number directly, e.g., read(61, etc) instead of assigning a number to a variable (e.g. read(ich,) . This'd facilitate others searching for conflicts; Avoid using tabs in editor as they mess up with the appearance. Use space instead and strictly align code blocks for easy read. Do not use automatic arrays of \u22652 dimensions. It\u2019s often tempting to grab dimensions directly from the module schism_glbl and use them to define arrays in a routine; e.g. vel_sd(nvrt,nsa) . This causes trouble with some compilers and may result in segfault. Use either of the following 2 approaches instead: allocatable arrays (and always remember to deallocate them at the end of the routine); pass on the dimensions explicitly as dummy arguments (e.g. subroutine routine1(nvrt2,nsa2, vel_sd..) , where nvrt2=nvrt and nsa2=nsa , and then use these to define: vel_sd (nvrt2,nsa2) ).","title":"Code structure"},{"location":"code-contribution.html#general-info","text":"SCHISM was written in MPI FORTRAN 90. After svn revision 5225, we have migrated to github . Figure 1 shows the directory structure of the SCHISM github repository schism. General public have access to all branches. SCHISM github repository. Figure 2 shows its main work flow and major code blocks. Two files inside src/ ( Hydro/schism_init.F90 and Hydro/schism_step.F90 ) represent bulk of the hydro code, and are driven by a master program ( Driver/schism_driver.F90 ). The global variables are defined in Core/schism_glbl.F90 , and the message passing routines are defined in Core/schism_msgp.F90 . SCHISM code work flow. The percentages are estimates from a test case with an earlier version and may not be up to date. The domain decomposition is done using ParMETIS graph partitioning library (included in the src/ ). Figure 3 shows an example of sub-domains generated by this lib. Domain decomposition. Each color represents a sub-domain (\u2018resident domain\u2019) taken by a MPI process and the thick black polygon represents the \u2018augmented\u2019 (=resident+ghost) domain of process 6. The Utility dir has a lot of useful utility scripts for pre- and post-processing. The header of each program generally has info on its purpose and instructions on how to use it. ACE : source code and install notes for ACE tools; the manual can be found on Forum . Combining_Scripts : FORTRAN and perl scripts used to gather outputs from SCHISM (e.g., outputs/schout_0*_[stack number].nc etc) into one binary file ( schout_[stack_number].nc ). Grid_Scripts : FORTRAN codes to interpolate depths from DEM files in either structured grid (raster) or unstructured grid format. While ACE/xmgredit5 can do similar things, these scripts are mostly for interpolating from very large DEM files. Gen_Hotstart : scripts for preparing hotstart.nc from e.g., netcdf outputs from a structured-grid model. Pre-Processing : various scripts for pre-processing (checking, viz etc) OneWayNestScripts : scripts for 1-way nesting, by preparing *[23]D.th.nc (elevation, horizontal velocity, salinity and temperature boundary condition) that can be used for the 'small-domain' run. Particle_Tracking : particle tracking code that uses SCHISM's outputs for 3D tracking. Post-Processing-Fortran : FORTRAN codes for extracting time series at selected 3D points (including transects). You can modify these codes for your own purposes. Sflux_nc : matlab scripts useful for preparing your own .nc files for sflux/ . NARR_util/ has scripts to prepare .nc files from NCEP's NARR products. SMS : scripts to convert between .2dm of SMS and .gr3 . Vis_Matlab : matlab scripts for viz. At the moment, these scripts have not been updated to handle \\(LSC^2\\) grid.","title":"General info"},{"location":"code-contribution.html#domain-partitioning","text":"The domain is first portioned into non-overlapping sub-domains (in element sense; see Figure 3 ) using ParMETIS. Then each sub-domain is augmented with 1 layer of ghost elements. This is accomplished by the call partition_hgrid() early in the main program. After calling aquire_hgrid(.true.) immediately after that, the elements, nodes, sides in each augmented and non-augmented (i.e., without ghosts) domains are shown in Figure 3 . The corresponding variable denoting number of Elements, Nodes, and Sides are given in the following table. Intuition is typically followed although there are exceptions as will be described below. Global Local non-augmented Ghost Augmented Elements ne_global ne neg nea=ne+neg Nodes np_global np npg npa=np+npg Sides ns_global ns nsg nsa=ns+nsg The call to ParMETIS routine is as follows - call ParMETIS_V3_PartGeomKway ( vtxdist , xadj , adjncy , vwgt , adjwgt , wgtflag , & numflag , ndims , xyz , ncon , nproc , tpwgts , ubvec , options , & edgecut , part , comm ) p : # of processors; n : total # of vertices (local) in graph sense; m : total # of neighboring vertices (\"edges\"); double counted between neighboring vertice u and v. ncon : # of weights for each vertex. int(in) vtxdist(p+1) : Processor j stores vertices vtxdist(j):vtxdist(j+1)-1 int (in) xadj(n+1), adjncy(m) : locally, vertex j 's neighboring vertices are adjncy(xadj(j):xadj(j+1)-1) . adjncy points to global index; int(in) vwgt(ncon*n), adjwgt(m) : weights at vertices and \"edges\". Format of adjwgt follows adjncy; int(in) wgtflag : 0 : none ( vwgt and adjwgt are NULL); 1 : edges ( vwgt is NULL ); 2 :vertices ( adjwgt is NULL ); 3 : both vertices & edges; int(in) numflag : 0 : C-style numbering from 0; 1 : FORTRAN style from 1; int(in) ndims : 2 or 3 (D); float(in) xyz(ndims*n) : coordinate for vertex j is xyz(j*ndims:(j+1)*ndims-1) (C style); ndims*(j-1)+1: ndims*j (FORTRAN style); int(in) nparts : # of desired sub-domains (usually nproc ); float(in) tpwgts(ncon*nparts) : =1/nparts if sub-domains are to be of same size for each vertex weight; float(in) ubvec(ncon) : imbalance tolerance for each weight; int(in) options : additonal parameters for the routine (see above); int(out) edgecut : # of edges that are cut by the partitioning; int(out) part() : array size = # of local vertices. It stores indices of local vertices.","title":"Domain partitioning"},{"location":"code-contribution.html#arrays-and-constant","text":"llist_type :: iegl(iegb) : iegb is a global element #. If the element is resident (not ghost), iegl(iegb)%rank=myrank , and iegl(iegb)%id = local element index , and iegl%next=null . If iegb is a ghost, then iegl list has two entries: myrank and the rank where iegb is resident. All processors have this info, but the lists are different (1st entry is usually myrank etc). llist_type :: ipgl(ipgb) : ipgb is a global node #. Use this list only when the node is resident (not ghost); it\u2019s confusing when ipgb is ghost. If ipgb is resident, ipgl(ipgb)%rank=myrank , and ipgl(ipgb)%id = local node index . ipgl%next%next%next.... is the linked list, with ranks in ascending order. Unless ipgb is an interface node (i.e., resident in more than 1 process), the list has only 1 entry. All processors have this info, but the lists are different (1st entry is usually myrank etc). llist_type :: isgl(isgb) : isgb is a global side #. Similar to ipgl , if the side is resident (not ghost), isgl(isgb)%rank=myrank , and isgl(isgb)%id = local side index . isgl%next%next... is the list, with ranks in ascending order. All processors have this info, but the lists are different (1st entry is usually myrank etc). int :: ielg(ie), iplg(ip), islg(isd) : The global element index of local element ie in the augmented domain. Similar for the other two (nodes/sides). int :: iegrpv(iegb) : The rank # for global element iegb (before augmenting the domain). Used mainly in partitioning the grid. Arrays that have similar meaning between global and local aug. domains, i.e., they do not have problem of getting outside the aug. domain: i34 , elnode (old name: nm ), elside ( js ), ssign , snx , sny . Arrays that need special attention in the aug. domain - int :: ic3(1:i34(), ie) \u2013 positive if the neighbor element is inside the aug. domain as well (and in this case it is the local index of the neighbor element); 0 if (global) boundary; negative if the neighbor element is outside the aug. domain and in this case, the absolute value is the global element index. int :: nne(ip) \u2013 total # of neighbor elements around local node ip , including those outside the aug. domain (i.e., same as nnegb() ). int :: indel(1: nne(ip),ip) \u2013 surrounding element indices. If inside aug. domain, this is the local element index; if outside, this is the negative of the global element index. int :: iself(1: nne(ip),ip) \u2013 same as global iselfgb , i.e., the elemental local index for node ip in neighbor element indel() (even if it is outside). int :: nnp(ip) \u2013 total # of surrounding nodes for node ip , excluding all nodes outside the aug. domain. For SCHISM, include all nodes outside. int :: indnd(1: nnp(ip),ip) \u2013 list of surrounding nodes, excluding all nodes outside the aug. domain. For SCHISM, all nodes outside will have negative global index returned. int :: isdel(1:2,isd) & isidenode(1:2,isd) \u2013 order of the two adjacent elements follows global indices, and so the vector from node 1 to 2 in isidenode(1:2,isd) forms local y-axis while the vector from element 1 to 2 in isdel(1:2,isd) forms local x-axis. Therefore either of isdel(1:2,isd) can be negative. The element index is local (positive) if it is inside the aug. domain; otherwise the minus of global element index is returned. The local side isd is on the boundary if and only if isdel(2,isd)=0 , and in this case, isdel(1,isd) must be inside the aug. domain (i.e., positive) (if isd is resident). If isd is resident and not ghost, isdel() has the same meaning as serial code, i.e., is(1,isd)>0 (inside the aug. domain), and isdel(2,isd)>=0 , and isd is on the boundary if and only if isdel(2,isd)=0 . double :: delj(isd) \u2013 meaningful only if isd is resident. Boundary arrays : Most arrays point to global bnd segment #. Most B.C. arrays are global as well. nope_global \u2013 total # of open bnd segements in the global domain. nope \u2013 total # of open bnd segements in the aug. domain. iopelg(1:nope) \u2013 returns global open bnd segment # for a local open bnd segment. iopegl(0,k) - # of local fragmentations of global open bnd segment k. iopegl(j,k) - local segment # of jth ( 1<=j<=iopegl(0,k) ) fragmentation of global open bnd segment k. nond(1:nope) \u2013 total # of open bnd nodes on each segment. The corresponding global array is nond_global() . iond(nope,1: nond(1:nope)) \u2013 list of local node indices on each open bnd segment. The corresponding global array is iond_global() . nland - total # of land bnd segements in the aug. domain. nland_global is global. nlnd(1:nland) - total # of land bnd nodes on each segment. ilnd(nland,1: nlnd(1:nland)) \u2013 list of local node indices on each land bnd segment. nosd(nope) (ELCIRC) - # of open bnd sides on each segment. iosd(nope, 1: nosd(nope)) (ELCIRC) \u2013 list of open bnd side on each segment. noe(nope) (ELCIRC) - # of open bnd elements on each segment. ioe(nope, 1: noe(nope)) (ELCIRC) \u2013 list of open bnd elements on each segment. isbe(2,1:nea) (ELCIRC) \u2013 if the element is on the local open bnd, this returns the local segment # and element #. 0 otherwise. isbs() (ELCIRC) \u2013 similar to isbe . isbnd(-2:2,ip) (SCHISM) - If ip is on 1 open bnd only, isbnd(1,ip) points to the global segment # of that open bnd and isbnd(2,ip)=0 ; if ip is on 2 open bnds, isbnd(1:2,ip) point to the global segment #s for the 2 open bnds. If ip is on land bnd only (i.e., not on open bnd), isbnd(1,ip)= 1 and isbnd(2,ip)=0 . If ip is an internal node, isbnd(1:2,ip)=0 . Therefore, ip is on open bnd if isbnd(1,ip)>0 (and in this case isbnd(2,ip) may also be positive, even though isbnd(2,ip) may be outside the aug. domain), on land bnd (not on any open bnd) if isbnd(1,ip)= 1 , and an internal node if isbnd(1,ip)=0 . If on open bnd, isbnd(-2:-1,ip) are global index (i.e., isbnd(-1,ip) th node on the isbnd(1,ip) th open bnd); isbs(nsa) - positive if a local side is on the global open bnd (in this case, isbs() is the global segment #); 1 if it is on land bnd; 0 if internal side. iettype , ifltype , itetype , and isatype all take global bnd segment as argument; other b.c. arrays ( eth etc) are also global. uth(nvrt,nsa) , vth(nvrt,nsa) \u2013 local b.c. for ifltype/=0 for a local side. uthnd(nvrt,mnond_global, nope_global) , vthnd() \u2013 global arrays. elbc(ip) \u2013 ip is a local node. Arrays defined in elfe_msgp.F90 nnbr - # of neighbor processors (excluding myrank ). nbrrank(nnbr) \u2013 rank of each neighbor processor. int :: ranknbr(0:nproc-1) \u2013 neighbor # for each processor (0 if not neighbor). nerecv(nnbr) - # of elements to be received from each neighbor. ierecv(1: nerecv(nnbr),nnbr) \u2013 list of element indices (ghost in myrank ) to be received from each neighbor (where the elements are resident and not ghost). nesend(nnbr) - # of elements to be sent to each neighbor. iesend(1: nesend(nnbr),nnbr) \u2013 list of element indices (local resident in myrank ) to be sent to each neighbor (where the elements are ghost). Similar for nodes/side ( nprecv , iprecv etc). A note on ghost exchange Since the message exchanges between processors have to wait for each other in order to communicate collectively, it's not necessary to synchronize the processes.","title":"Arrays and constant"},{"location":"code-contribution.html#important-mpi-routines","text":"MPI_Recv int MPI_Recv ( void * buf , int count , MPI_Datatype datatype , int source , int tag , MPI_Comm comm , MPI_Status * status ) !Inputs: ! count - maximum number of elements in receive buffer (integer); ! datatype - datatype of each receive buffer element (handle); ! source - rank of source (integer); ! tag - message tag (integer); ! comm - communicator (handle). !Outputs: ! buf - initial address of receive buffer (choice); ! status - status object (Status). MPI_Irecv : nonblock receive. int MPI_Irecv ( void * buf , int count , MPI_Datatype datatype , int source , int tag , MPI_Comm comm , MPI_Request * request ) !Inputs: ! buf - initial address of receive buffer (choice); ! count - number of elements in receive buffer (integer); ! datatype - datatype of each receive buffer element (handle); ! source - rank of source (integer); ! Tag - message tag (integer); ! comm - communicator (handle). !Output: ! request - communication request (handle) MPI_Send int MPI_Send ( void * buf , int count , MPI_Datatype datatype , int dest , int tag , MPI_Comm comm ) !Inputs: ! buf - initial address of send buffer (choice); ! count - number of elements in send buffer (nonnegative integer); ! datatype - datatype of each send buffer element (handle); ! dest - rank of destination (integer); ! tag - message tag (integer); ! comm - communicator (handle). MPI_Isend : non-block send int MPI_Isend ( void * buf , int count , MPI_Datatype datatype , int dest , int tag , MPI_Comm comm , MPI_Request * request ) ! Inputs: ! buf - initial address of send buffer (choice); ! count - number of elements in send buffer (integer); ! datatype - datatype of each send buffer element (handle); ! dest - rank of destination (integer); ! tag - message tag (integer); ! comm - communicator (handle). !Output: ! request - communication request (handle). MPI_Allreduce : Combines values from all processes and distribute the result back to all processes int MPI_Allreduce ( void * sendbuf , void * recvbuf , int count , MPI_Datatype datatype , MPI_Op op , MPI_Comm comm ) ! Inputs: ! sendbuf - starting address of send buffer (choice); ! count - number of elements in send buffer (integer). Also the size of the output ! (i.e., ith elements from each processor are summed up and returned as ith element of output); ! datatype - data type of elements of send buffer (handle); ! op - operation (handle) (e.g., MPI_SUM, MPI_LOR); ! comm - communicator (handle). ! Output: ! recvbuf - starting address of receive buffer (choice). MPI_Reduce int MPI_Reduce ( void * sendbuf , void * recvbuf , int count , MPI_Datatype datatype , MPI_Op op , int root , MPI_Comm comm ) ! only difference from MPI_Allreduce is that the result is sent to rank \"root\". MPI_Gather : Gathers together values from a group of processes. int MPI_Gather ( void * sendbuf , int sendcnt , MPI_Datatype sendtype , void * recvbuf , int recvcount , MPI_Datatype recvtype , int root , MPI_Comm comm ) ! Inputs: ! sendbuf - starting address of send buffer (choice) ! sendcount - number of elements in send buffer (integer) ! sendtype - data type of send buffer elements (handle) ! recvcount - number of elements for any single receive (integer, significant ! only at root) ! recvtype - data type of recv buffer elements (significant only at root) (handle) ! root - rank of receiving process (integer) ! comm - communicator (handle) ! Output: ! Recvbuf - address of receive buffer (choice, significant only at root). The received values ! are stacked according to the rank number (i.e., first recvcount are from rank 0 etc). MPI_Allgatherv : Gathers data from all tasks and deliver it to all. int MPI_Allgatherv ( void * sendbuf , int sendcount , MPI_Datatype sendtype , void * recvbuf , int * recvcounts , int * displs , MPI_Datatype recvtype , MPI_Comm comm ) !Inputs: ! sendbuf - starting address of send buffer (choice); ! sendcount - number of elements in send buffer (integer) ! sendtype - data type of send buffer elements (handle); ! recvcounts - integer array (of length group size) containing the number of elements ! that are received from each process; ! displs - integer array (of length group size). Entry i specifies the displacement ! (relative to recvbuf) at which to place the incoming data from process i; ! recvtype - data type of receive buffer elements (handle); ! comm. - communicator (handle). ! Output: ! recvbuf - address of receive buffer (choice). MPI_Type_indexed : Creates an indexed datatype; the corresponding routine in MPI2 is mpi_type_create_indexed_block() . int MPI_Type_indexed ( int count , int blocklens [], int indices [], MPI_Datatype old_type , MPI_Datatype * newtype ) ! Inputs: ! count - number of blocks -- also number of entries in indices and blocklens; ! blocklens - number of elements in each block (array of nonnegative integers); ! indices - displacement of each block in multiples of old_type (array of integers); ! old_type - old datatype (handle). ! Output: ! newtype - new datatype (handle) Note The new MPI type treats multi-dimensional arrays in FORTRAN as 1D array, expanding with 1st index varying before 2nd etc. So this routine can be used to grab discontiguous data blocks from multi- dimensional arrays. So if a 2D array is a(nvrt,nea) the corresponding 1D array is illustrated below: \\[\\begin{equation*} nea \\stackrel{nvrt}{ \\begin{bmatrix} (1, 1) & (2, 1) & \\cdots & (nvrt, 1)\\\\ (1, 2) & (2, 2) & \\cdots & (nvrt, 2)\\\\ \\vdots & \\vdots & \\vdots & \\vdots\\\\ (1, nea) & (2, nea) & \\cdots & (nvrt, nea) \\end{bmatrix} } \\end{equation*}\\] Now suppose we need to grab all ghost elements iesend(1:nesend), these will correspond to rows iesend(i) of the table. In this case the # of blocks is nesend, block length is nvrt, and displacement of ith block is (iesend(i)-1)*nvrt. MPI_Barrier : Blocks until all process have reached this routine. int MPI_Barrier ( MPI_Comm comm ) ! Input: comm. - communicator (handle) MPI_Type_struct : Creates a struct datatype. int MPI_Type_struct ( int count , int blocklens [], MPI_Aint indices [], MPI_Datatype old_types [], MPI_Datatype * newtype ) ! Inputs: ! count - number of blocks (integer) ! also number of entries in arrays array_of_types, array_of_displacements and array_of_blocklengths; ! blocklens - number of elements in each block (array); ! indices \u2013 byte displacement of each block relative to the start of the type (array); ! old_types - type of elements in each block (array of handles to datatype objects). ! Output: ! newtype - new datatype (handle) MPI_Alltoall : Sends data from all to all processes. int MPI_Alltoall ( void * sendbuf , int sendcount , MPI_Datatype sendtype , void * recvbuf , int recvcnt , MPI_Datatype recvtype , MPI_Comm comm ) ! Inputs: ! sendbuf - starting address of send buffer (choice); ! sendcount - number of elements to send to each process (integer); ! sendtype - data type of send buffer elements (handle); ! recvcount- number of elements received from any process (integer); ! recvtype - data type of receive buffer elements (handle); ! comm. - communicator (handle). ! Outputs ! recvbuf - address of receive buffer (choice)","title":"Important MPI routines"},{"location":"code-contribution.html#io-channels-in-schism","text":"You need to exercise caution when dealing with parallel I/O especially for writing. For writing outputs, you\u2019d generally let only 1 process do the job, e.g. if ( myrank == 0 ) write ( 10 , * ) If you do need to have all processes write e.g. debug messages, you\u2019d consider using channel 12 which has been pre-set to point to multiple files from each MPI process (see below). Here are all I/O channel numbers currently used in different sub-models of SCHISM (and so you\u2019d avoid using them). A good way to find out if a channel is available is to issue the following cmd from src/ - grep \"(61\" */*.F90 # Looks for '(61' Please contact lead developer after you have selected a channel number to use in your module. Hydro/ : Channels between 8 and 200 are used by various codes for I/O. In particular - 101 to 100+noutputs (inclusive of both): reserved for global outputs (including from tracers like sediment, EcoSim, ICM, as well as WWM); 201-250: non-standard outputs (e.g. at sidecenters, prism centers); 251 to 259: reserved for station outputs; 16: this channel points to mirror.out (on rank 0), the main message output about the run. You should use it with if(myrank==0) . WWM 1100 to 1200: handles for inputs/outputs etc EcoSim 600: outputting some messages ICM 301 to 323: reading channels for non-point source inputs for ICM Sediment (SED and SED2D) 26, 2626 Following are some generic channels - 10, 31, 32 : used for one-off I/O \u2013 can be used by other sub-models as long as you close them immediately after use; 12 : this channel is initialized by different processes to point to files outputs/nonfatal_xxxx , where \u201cxxxx\u201d are the process IDs. Therefore it\u2019s very useful for debugging purpose; you can use it anywhere in your part of the code to dump messages to these files.","title":"I/O channels in SCHISM"},{"location":"code-contribution.html#example-code","text":"If you are working on the code you may be confused about the exchanges inside SCHISM. When should you use these? The first thing you need to remember when writing MPI code with domain decomposition is that a rank (or MPI 'process') only has info in its 'augmented' (=resident + ghost) domain, and knows absolutely nothing outside this region. Domain decomposition for code example. Consider Figure 4 . For example, you want to do averaging at each node of the sub-domain around its ball of elements. do i = 1 , np !not 'npa' sum1 = 0 sum_a = 0 do j = 1 , nne ( i ) ie = indel ( j , i ) sum1 = sum1 + stokes ( ie ) * area ( ie ) sum_a = sum_a + area ( ie ) enddo !j stokes_nd ( i ) = sum1 / sum_a enddo !i call exchange_p2d ( stokes_nd ) Notice that you'd use np instead of npa ( =np+npg ; augmented domain) here. For any resident node P , indel() is well defined (because again, Rank 1 has info in its augmented domain including the ghost zone), and so the loops make sense. As long as all ranks have same info in each others' ghost zones (which is the purpose of exchange routines), stokes_nd at an interface node (e.g. P ) will be same across ranks. However, for a ghost node Q , some surrounding elements are located outside the augmented domain (and in this case, indel() are actually negative!), and so if you use the same operation, erroneous values at ghost nodes would be generated. Therefore you cannot use npa in the outer loop. Now, after this loop is executed, what happens to the ghost nodes like Q ? Since they are excluded on Rank 1, the stokes_nd will be wrong there. Fortunately, some neighboring ranks have the correct values for these nodes, which are resident nodes in those neighboring ranks; e.g., Q is a resident node of Rank 0. So now different ranks will have different values at some overlapping nodes, and this needs to be avoided. In order to make sure each rank has correct (and up-to-date) values in its augmented domain, you need to follow this loop with an exchange routine. Remember that for the exchange routines to work, you need to define the exchanged array in the augmented domain - allocate ( stokes_nd ( npa )) !not 'np' in order to allow each rank to receive info in the ghost zone. Description of all exchange routines used in SCHISM can be found in schism_msgp.F90 . The above is just one example of when exchanges are needed. Usually this involves some kind of queries into a neighborhood, but beware that there are other circumstances where exchanges are necessary. The most important thing to remember A rank only has info in its 'augmented' domain, and knows absolutely nothing outside this region. In MPI code, it's crucial to make sure all ranks have identical values in overlapping zone. Now let's consider an example where no exchanges are needed. Say you want to simply go through all elements and update some arrays defined at elements: do i = 1 , nea !not 'ne' qdl_e ( i ) = cde ( i ) * dte / area ( i ) enddo !i Since all ranks have info of cde and area locally available, qdl_e will be correctly calculated even inside the ghost zones, and its values are the same cross ranks there (since cde and area are same cross ranks in the overlapping zones). So in this case you'd use nea instead of ne in the loop. Of course, there is nothing wrong with using ne in the loop followed by an exchange routine, but doing so would be less efficient and incur unnecessary communication cost.","title":"Example code"},{"location":"code-contribution.html#general-code-guide","text":"Here are some house rules for preparing your own code - No spaces between # (pre-processor) and if/else/end for CPP flag; Try to use the I/O channel number directly, e.g., read(61, etc) instead of assigning a number to a variable (e.g. read(ich,) . This'd facilitate others searching for conflicts; Avoid using tabs in editor as they mess up with the appearance. Use space instead and strictly align code blocks for easy read. Do not use automatic arrays of \u22652 dimensions. It\u2019s often tempting to grab dimensions directly from the module schism_glbl and use them to define arrays in a routine; e.g. vel_sd(nvrt,nsa) . This causes trouble with some compilers and may result in segfault. Use either of the following 2 approaches instead: allocatable arrays (and always remember to deallocate them at the end of the routine); pass on the dimensions explicitly as dummy arguments (e.g. subroutine routine1(nvrt2,nsa2, vel_sd..) , where nvrt2=nvrt and nsa2=nsa , and then use these to define: vel_sd (nvrt2,nsa2) ).","title":"General code guide"},{"location":"contribute-to-this-online-manual.html","text":"Overview \u00b6 All SCHISM developers are encouraged to keep this online manual up to date with their code development. This section serves as a brief guide for contributing to this manual. Directory structure \u00b6 All files used to build this manual are included in SCHISM's Git Repository . As of April 9, 2021, you automatically get a copy of them after you download the SCHISM code: git clone https://github.com/schism-dev/schism For you to update this online manual, the relavant files are The mkdoc configuration file: $your_dir/schism/mkdocs.yml The \"docs\" folder: $your_dir/schism/docs/ , which mainly contains markdown files: docs \u251c\u2500\u2500 schism \u2502 \u251c\u2500\u2500 barotropic-solver.md \u2502 \u251c\u2500\u2500 eulerian-lagrangian-method.md \u2502 \u251c\u2500\u2500 geometry-discretization.md \u2502 \u251c\u2500\u2500 momentum-equation.md \u2502 \u251c\u2500\u2500 overview.md \u2502 \u251c\u2500\u2500 physical-formulation.md \u2502 ... \u2514\u2500\u2500 verification-tests.md ... and assets files (such as *.png files) docs \u251c\u2500\u2500 assets \u2502 \u251c\u2500\u2500 bay-delta-schism-grid.png \u2502 \u251c\u2500\u2500 bnd-elem.png \u2502 \u251c\u2500\u2500 case-study-guam.png \u2502 ... Updating the manual \u00b6 Minor edits \u00b6 If you are only making minor changes on an existing manual page, the easiest way is probably directly editing the *.md file on Github. Simply click the \"edit\" button at the top-right corner of any manual page: It will take you to the Github page, where you can directly edit the *.md file then commit changes. We do ask you to provide a brief and sensible commit message. Adding a short content \u00b6 Follow these steps if your content is short enough to fit in a single page: Decide where your new page fits in this manual and specify it in the last section of \"mkdocs.yml\". For example, see how \"your-new-page\" is inserted in \"mkdocs.yml\" below: ... nav: - Home: index.md ... ... - Modules: - Overview: modules/overview.md - Generic tracer module: modules/generic-tracer.md - AGE: modules/age.md ... ... - Title of your new page: your-new-page.md ... ... - Contribute to this online manual: contribute-to-this-online-manual.md Please give a meaningful name to the *.md file associated with your new page. Put your *.md file directly under \"docs/\", for example: $your_dir/schism/docs/your-new-page.md and put any additional materials in $your_dir/schism/docs/assets/ Please give a sensible name to any additional materials, for example: \"your-new-page-some-figure.png\" Adding a content with multiple subsections \u00b6 Decide where your new content fits in this manual and specify it in the last section of \"mkdocs.yml\". For example, see how \"your-multi-page-content\" is inserted in \"mkdocs.yml\" below: ... nav: - Home: index.md ... ... - Modules: - Overview: modules/overview.md - Generic tracer module: modules/generic-tracer.md - AGE: modules/age.md ... ... - Title of your-multi-page-content: - Overview: your-multi-page-content/overview.md - Some topic: your-multi-page-content/some-topic.md ... - Contribute to this online manual: contribute-to-this-online-manual.md Make a subfolder under \"docs\", which will contain all new *.md files $your_dir/schism/docs/your-multi-page-content/ For each subsection, create one *.md file: $your_dir/schism/docs/your-multi-page-content/overview.md $your_dir/schism/docs/your-multi-page-content/some-topic.md ... Although other directory structures can be used to make multi-page contents, we kindly ask you to follow our convention. Preview your edits \u00b6 If you are making non-trivial changes, you may want to preview your edits before committing them to Git. To do this, you will have to install \"mkdocs\" on your local machine. This can be done system-wide using the system python installation (and associated pip command): pip install mike mkdocs mkdocs_material mkdocs-with-pdf Then, under $your_dir/schism/ do mkdocs serve If there are no errors, it will return an IP address of the manual under editing at the end of the initial command line message: INFO - Building documentation... WARNING - without generate PDF(set environment variable ENABLE_PDF_EXPORT to 1 to enable) INFO - Cleaning site directory WARNING - Both index.md and readme.md found. Skipping readme.md from /media/feiye/My Book/schism/docs WARNING - Documentation file 'contribute-to-this-online-manual.md' contains a link to '{{ site.baseurl }}{% link docs/compound-flood/compound-flood.md %}' which is not found in the documentation files. WARNING - Documentation file 'contribute-to-this-online-manual.md' contains a link to '{{ site.baseurl }}{% link docs/acetool-tips/acetool-tips.md %}' which is not found in the documentation files. INFO - Documentation built in 0.77 seconds INFO - [22:21:41] Watching paths for changes: 'docs', 'mkdocs.yml' INFO - [22:21:41] Serving on http://127.0.0.1:8000/ You can open it with a web browser and any changes in the source files will be reflected immediately. See more instructions here . Markdown \u00b6 A quick reference of the Markdown syntax . Cross-referencing \u00b6 Most equations, figures and papers in this document are labeled, so these can be referenced in another place in the same or different .md files. The general syntax is [ ] followed by (# ). Some examples are: [Zhang et al. 2016](#zhang2016) <--refers to #zhang2016 in same .md (Figure [5ab](./barotropic-solver.md#figure05)) <-- refers to figure05 inside barotropic-solver.md in the same dir More features \u00b6 If you need advanced features for your tutorial page, you can use some HTML syntax in your *.md files. However, we recommend that you keep the page layout and syntax as simple as possible.","title":"Contribute to this online manual"},{"location":"contribute-to-this-online-manual.html#overview","text":"All SCHISM developers are encouraged to keep this online manual up to date with their code development. This section serves as a brief guide for contributing to this manual.","title":"Overview"},{"location":"contribute-to-this-online-manual.html#directory-structure","text":"All files used to build this manual are included in SCHISM's Git Repository . As of April 9, 2021, you automatically get a copy of them after you download the SCHISM code: git clone https://github.com/schism-dev/schism For you to update this online manual, the relavant files are The mkdoc configuration file: $your_dir/schism/mkdocs.yml The \"docs\" folder: $your_dir/schism/docs/ , which mainly contains markdown files: docs \u251c\u2500\u2500 schism \u2502 \u251c\u2500\u2500 barotropic-solver.md \u2502 \u251c\u2500\u2500 eulerian-lagrangian-method.md \u2502 \u251c\u2500\u2500 geometry-discretization.md \u2502 \u251c\u2500\u2500 momentum-equation.md \u2502 \u251c\u2500\u2500 overview.md \u2502 \u251c\u2500\u2500 physical-formulation.md \u2502 ... \u2514\u2500\u2500 verification-tests.md ... and assets files (such as *.png files) docs \u251c\u2500\u2500 assets \u2502 \u251c\u2500\u2500 bay-delta-schism-grid.png \u2502 \u251c\u2500\u2500 bnd-elem.png \u2502 \u251c\u2500\u2500 case-study-guam.png \u2502 ...","title":"Directory structure"},{"location":"contribute-to-this-online-manual.html#updating-the-manual","text":"","title":"Updating the manual"},{"location":"contribute-to-this-online-manual.html#minor-edits","text":"If you are only making minor changes on an existing manual page, the easiest way is probably directly editing the *.md file on Github. Simply click the \"edit\" button at the top-right corner of any manual page: It will take you to the Github page, where you can directly edit the *.md file then commit changes. We do ask you to provide a brief and sensible commit message.","title":"Minor edits"},{"location":"contribute-to-this-online-manual.html#adding-a-short-content","text":"Follow these steps if your content is short enough to fit in a single page: Decide where your new page fits in this manual and specify it in the last section of \"mkdocs.yml\". For example, see how \"your-new-page\" is inserted in \"mkdocs.yml\" below: ... nav: - Home: index.md ... ... - Modules: - Overview: modules/overview.md - Generic tracer module: modules/generic-tracer.md - AGE: modules/age.md ... ... - Title of your new page: your-new-page.md ... ... - Contribute to this online manual: contribute-to-this-online-manual.md Please give a meaningful name to the *.md file associated with your new page. Put your *.md file directly under \"docs/\", for example: $your_dir/schism/docs/your-new-page.md and put any additional materials in $your_dir/schism/docs/assets/ Please give a sensible name to any additional materials, for example: \"your-new-page-some-figure.png\"","title":"Adding a short content"},{"location":"contribute-to-this-online-manual.html#adding-a-content-with-multiple-subsections","text":"Decide where your new content fits in this manual and specify it in the last section of \"mkdocs.yml\". For example, see how \"your-multi-page-content\" is inserted in \"mkdocs.yml\" below: ... nav: - Home: index.md ... ... - Modules: - Overview: modules/overview.md - Generic tracer module: modules/generic-tracer.md - AGE: modules/age.md ... ... - Title of your-multi-page-content: - Overview: your-multi-page-content/overview.md - Some topic: your-multi-page-content/some-topic.md ... - Contribute to this online manual: contribute-to-this-online-manual.md Make a subfolder under \"docs\", which will contain all new *.md files $your_dir/schism/docs/your-multi-page-content/ For each subsection, create one *.md file: $your_dir/schism/docs/your-multi-page-content/overview.md $your_dir/schism/docs/your-multi-page-content/some-topic.md ... Although other directory structures can be used to make multi-page contents, we kindly ask you to follow our convention.","title":"Adding a content with multiple subsections"},{"location":"contribute-to-this-online-manual.html#preview-your-edits","text":"If you are making non-trivial changes, you may want to preview your edits before committing them to Git. To do this, you will have to install \"mkdocs\" on your local machine. This can be done system-wide using the system python installation (and associated pip command): pip install mike mkdocs mkdocs_material mkdocs-with-pdf Then, under $your_dir/schism/ do mkdocs serve If there are no errors, it will return an IP address of the manual under editing at the end of the initial command line message: INFO - Building documentation... WARNING - without generate PDF(set environment variable ENABLE_PDF_EXPORT to 1 to enable) INFO - Cleaning site directory WARNING - Both index.md and readme.md found. Skipping readme.md from /media/feiye/My Book/schism/docs WARNING - Documentation file 'contribute-to-this-online-manual.md' contains a link to '{{ site.baseurl }}{% link docs/compound-flood/compound-flood.md %}' which is not found in the documentation files. WARNING - Documentation file 'contribute-to-this-online-manual.md' contains a link to '{{ site.baseurl }}{% link docs/acetool-tips/acetool-tips.md %}' which is not found in the documentation files. INFO - Documentation built in 0.77 seconds INFO - [22:21:41] Watching paths for changes: 'docs', 'mkdocs.yml' INFO - [22:21:41] Serving on http://127.0.0.1:8000/ You can open it with a web browser and any changes in the source files will be reflected immediately. See more instructions here .","title":"Preview your edits"},{"location":"contribute-to-this-online-manual.html#markdown","text":"A quick reference of the Markdown syntax .","title":"Markdown"},{"location":"contribute-to-this-online-manual.html#cross-referencing","text":"Most equations, figures and papers in this document are labeled, so these can be referenced in another place in the same or different .md files. The general syntax is [ ] followed by (# ). Some examples are: [Zhang et al. 2016](#zhang2016) <--refers to #zhang2016 in same .md (Figure [5ab](./barotropic-solver.md#figure05)) <-- refers to figure05 inside barotropic-solver.md in the same dir","title":"Cross-referencing"},{"location":"contribute-to-this-online-manual.html#more-features","text":"If you need advanced features for your tutorial page, you can use some HTML syntax in your *.md files. However, we recommend that you keep the page layout and syntax as simple as possible.","title":"More features"},{"location":"faq.html","text":"Besides the following info, you may also search archived messages from the SCHISM mailing list on the same web where you registered yourself for the mailing list. Just log in, and select 'Archive' from the left of the screen, and then on right side of screen select 'Advanced search'. My results show platform/compiler/CPU dependency Due to some intricate differences between different compilers/platforms some minor differences in results are expected. Bit-by-bit match of results using different numbers of CPUs is impossible also. But the differences should be small and should stabilize over time iteration. Run crashed with a fatal.error error message \"QUICKSEARCH: no intersecting edge....\" First you need to viz the results before the crash (e.g. surface velocity) to see if anything is outrageously wrong. Often times, errors such as this, related to the backtracking, come from other errors (e.g. NaN in inputs). Very rarely, the error originates from the underflow issue in the backtracking/ELM (and the results otherwise look reasonable). In the backtracking step, the code assumes that the path intersects sides of elements at 1 unique point that does not coincide with any node (cf. Fig. 1 ). Obviously this causes problem especially in some academic cases (e.g. the velocity aligns perfectly with grid line). To avoid this issue, the code nudges the starting position of backtracking (with parameter btrack_nudge ) toward the starting element's centroid. Occasionally, this is still insufficient when the velocity is large on very fine meshes. One way out of this is to reduce dtb_max and dtb_min to get more accurate trajectory. Run crashed with a fatal.error error message \"bktrk_subs: overflow...\" or \"MAIN: nbtrk > mxnbt\" The backtracking (ELM) in SCHISM is parallelized across MPI processes, and some arrays need to be allocated to store trajectories that exited the augmented domain. The dimension of those arrays is defined in mxnbt and mnbt, which are proportional to local # of side and # of levels, and the proportionality constants are defined in param.nml: s1_mxnbt = 0.5 , s2_mxnbt = 3.5 (Gradually) increasing these (to say 1, and 4) will solve the problem. Note that these constants only affect memory consumption and not accuracy. How to do a tidal simulation with SCHISM? The simplest way is to use SCHISM 2D. If you have to use SCHISM 3D, make sure the vertical grid is reasonable. My run crashed; how can I find out why? The best way to find out the reason for a crash is to visualize the surface velocity with VisIT. Usually you may see some large/noisy velocity somewhere, which may give you some hints on grid or forcing issues etc. Sometimes you want to visualize the problem right before the crash. You cannot use autocombine_MPI_elfe.pl as the last stack of output is incomplete. But you can use the FORTRAN combine script (e.g., combine_output* ) to directly combine an incomplete stack. Just follow the instruction in the header of this script to prepare the inputs and run. Then visualize the combined outputs. How to impose river discharge if the depth is negative there? See Grid generation . Run crashes with a dry boundary/depth error. SCHISM allows dry open-boundary nodes, but the entire open boundary segment cannot be dry at any given time if the velocity B.C. is imposed there. Either relocate the boundary or deepen some nodes to allow flow to come in. See Grid generation . I have large velocity at open boundary In hydrostatic models, the incoming velocity should be specified at open boundary. Over-specification i.e. elevation+velocity B.C. there usually avoids the problem, but the two B.C.\u2019s must be largely consistent with each other. The velocity B.C. can be generated using global circulation model (HYCOM etc) plus global tidal model (FES etc). fatal.error indicates \u201cCould not find suitable element in input\u201d This is likely because your sflux*.nc is not prepared properly: either the grid in .nc does not cover hgrid.ll , or the structured grid in .nc is not ordered counter-clockwise.","title":"Frequently Asked Questions"},{"location":"known_issues.html","text":"Freshwater injection stuck near injection place \u00b6 This can happen with the combined use of (1) point source/sink ( if_source =1); (2) LSC2 with 1-2 layers near injection places; (3) baroclinic model. The main symptom is that the freshwater seemingly gets stuck near the injection points and does not flow out as expected. The reason is that insufficient number of vertical layers cannot properly set up an exchange flow (that requires stratification), and as a result, the fresh/salt water interface oscillates instead of tilting as expects. Some work-arounds are: Change to open boundary condition approach Better salinity initial condition. If the salt intrusion should never reach the injection place, create a freswater zone near the injection in the I.C. Use more vertical layers near injection (one way to do this is to deepen the local depths to allow more layers) Nudge (inu_SAL=1 or 2) strongly in a region near injection Numerical dispersion with WENO \u00b6 The 3rd-order WENO scheme has numerical dispersion that needs to be controlled, usually by adjusting epsilon[12] in param.nml . This approach usually works well. Under some circumstances, e.g. watershed in the compound flooding cases, this adjustment is not enough, especially if hybrization with ELM transport is used ( ielm_transport=1 ). This is because ELM tracer results may introduce 'shocks' to the local WENO stencil, which in turn generate disperision. In those cases, the users need to adjust tvd.prop to make some areas upwind as well to ensure monotonicity, because upwind scheme handles shocks well. Figure 1 shows the result of disperion symptom from WENO, in the form of high salinity in some upriver regions of Chesapeake Bay. Higher-order WENO, 1st-order upwind and ELM solvers are applied in adjacent elements in close proximity in those upriver regions (note that h_tvd =5m in this case). Making those upriver elements upwind via tvd.prop resolves this issue; cf. Fig. 2 . Numerical dispersion in WENO led to high surface salinity in Chesapeake Bay (circled area). Making upstream rivers upwind resolved the high surface salinity issue in Chesapeake Bay.","title":"Known issues"},{"location":"known_issues.html#freshwater-injection-stuck-near-injection-place","text":"This can happen with the combined use of (1) point source/sink ( if_source =1); (2) LSC2 with 1-2 layers near injection places; (3) baroclinic model. The main symptom is that the freshwater seemingly gets stuck near the injection points and does not flow out as expected. The reason is that insufficient number of vertical layers cannot properly set up an exchange flow (that requires stratification), and as a result, the fresh/salt water interface oscillates instead of tilting as expects. Some work-arounds are: Change to open boundary condition approach Better salinity initial condition. If the salt intrusion should never reach the injection place, create a freswater zone near the injection in the I.C. Use more vertical layers near injection (one way to do this is to deepen the local depths to allow more layers) Nudge (inu_SAL=1 or 2) strongly in a region near injection","title":"Freshwater injection stuck near injection place"},{"location":"known_issues.html#numerical-dispersion-with-weno","text":"The 3rd-order WENO scheme has numerical dispersion that needs to be controlled, usually by adjusting epsilon[12] in param.nml . This approach usually works well. Under some circumstances, e.g. watershed in the compound flooding cases, this adjustment is not enough, especially if hybrization with ELM transport is used ( ielm_transport=1 ). This is because ELM tracer results may introduce 'shocks' to the local WENO stencil, which in turn generate disperision. In those cases, the users need to adjust tvd.prop to make some areas upwind as well to ensure monotonicity, because upwind scheme handles shocks well. Figure 1 shows the result of disperion symptom from WENO, in the form of high salinity in some upriver regions of Chesapeake Bay. Higher-order WENO, 1st-order upwind and ELM solvers are applied in adjacent elements in close proximity in those upriver regions (note that h_tvd =5m in this case). Making those upriver elements upwind via tvd.prop resolves this issue; cf. Fig. 2 . Numerical dispersion in WENO led to high surface salinity in Chesapeake Bay (circled area). Making upstream rivers upwind resolved the high surface salinity issue in Chesapeake Bay.","title":"Numerical dispersion with WENO"},{"location":"readme.html","text":"Documenting on mkdocs \u00b6 Installation (optional; for local development) \u00b6 The basic install only requires mkdocs and mkdocs_materials to be installed. This can be done system-wide using the system python installation (and associated pip command). pip install mkdocs mkdocs_material mkdocs-with-pdf To check where pip is located, use which pip in linux/unix system. If you are a conda/anaconda user, you can also create a new environment from the provided environment.yml file Writing markdown document \u00b6 Basic text Sections, subsections: # , ## etc. Bold: **Text** \\(\\rightarrow\\) Text Italic: _Text_ \\(\\rightarrow\\) Text Image <figure markdown id='figureXX'> ![ alt-text ]( relative/path/to/figure.png ) <figcaption>A good figure caption</figcaption> </figure> To reference this figure in the text, create a link [Figure XX](path/to/page.md#figureXX) . If the figure is referenced in the same page, the path/to/page.md can be omitted. Table | header 1| header 2| |---------|---------| | item 1 | item 2| will produce - header 1 header 2 item 1 item 2 Add a span before for a referencable caption <span id=\"table01\">Table caption</span> and refer using link notation Table [1](#table01) . Equations Equations can be added using standard latex \\begin{equation}\\label{eqxx}\\end{equation} block, or inline with $...$ block. Other latex command works inside these blocks. The equation inside equation block with label eqxx can be referred inline using $\\ref{eqxx}$ . References References can be added as link. For example [Zhang et al. 2016](#zhang2016) . An entry for this reference cab be added with html <span> in the end of each page as <span id=\"zhang2016\">Zhang, Y., Stanev, E.V. and S. Grashorn (2016) Unstructured-grid model for the North Sea and Baltic Sea: validation against observations, Ocean Modelling, 97, 91-108.</span> . Here id is what makes the link works. Build and deploy site \u00b6 mkdocs serve # to see locally mkdocs build # build site mkdocs gh-deploy --force # serve site to github on gh-page branch You will need github pages fully setup. See Github Pages for more information.","title":"Documenting on mkdocs"},{"location":"readme.html#documenting-on-mkdocs","text":"","title":"Documenting on mkdocs"},{"location":"readme.html#installation-optional-for-local-development","text":"The basic install only requires mkdocs and mkdocs_materials to be installed. This can be done system-wide using the system python installation (and associated pip command). pip install mkdocs mkdocs_material mkdocs-with-pdf To check where pip is located, use which pip in linux/unix system. If you are a conda/anaconda user, you can also create a new environment from the provided environment.yml file","title":"Installation (optional; for local development)"},{"location":"readme.html#writing-markdown-document","text":"Basic text Sections, subsections: # , ## etc. Bold: **Text** \\(\\rightarrow\\) Text Italic: _Text_ \\(\\rightarrow\\) Text Image <figure markdown id='figureXX'> ![ alt-text ]( relative/path/to/figure.png ) <figcaption>A good figure caption</figcaption> </figure> To reference this figure in the text, create a link [Figure XX](path/to/page.md#figureXX) . If the figure is referenced in the same page, the path/to/page.md can be omitted. Table | header 1| header 2| |---------|---------| | item 1 | item 2| will produce - header 1 header 2 item 1 item 2 Add a span before for a referencable caption <span id=\"table01\">Table caption</span> and refer using link notation Table [1](#table01) . Equations Equations can be added using standard latex \\begin{equation}\\label{eqxx}\\end{equation} block, or inline with $...$ block. Other latex command works inside these blocks. The equation inside equation block with label eqxx can be referred inline using $\\ref{eqxx}$ . References References can be added as link. For example [Zhang et al. 2016](#zhang2016) . An entry for this reference cab be added with html <span> in the end of each page as <span id=\"zhang2016\">Zhang, Y., Stanev, E.V. and S. Grashorn (2016) Unstructured-grid model for the North Sea and Baltic Sea: validation against observations, Ocean Modelling, 97, 91-108.</span> . Here id is what makes the link works.","title":"Writing markdown document"},{"location":"readme.html#build-and-deploy-site","text":"mkdocs serve # to see locally mkdocs build # build site mkdocs gh-deploy --force # serve site to github on gh-page branch You will need github pages fully setup. See Github Pages for more information.","title":"Build and deploy site"},{"location":"coupling/cesm.html","text":"The Community Earth System Model (CESM) is a fully coupled global climate model developed in collaboration with colleagues in the research community. CESM provides state of the art computer simulations of Earth's past, present, and future climate states. The CESM project is supported primarily by the National Science Foundation (NSF). Administration of the CESM is maintained by the Climate and Global Dynamics Laboratory (CGD) at the National Center for Atmospheric Research (NCAR). The SCHISM NUOPC can be integrated into the CESM as an ocean component in principle, once it is integrated into their Common Infrastructure for Modeling the Earth (CIME, see below). Obtaining CESM \u00b6 The version of CESM supporting SCHISM can be obtained as git clone https://github.com/mvertens/cesm.git -b feature/add_schism ./manage_externals/checkout_externals -v -o Obtaining and building with CIME \u00b6 CIME, pronounced \"SEAM\", primarily consists of a Case Control System that supports the configuration, compilation, execution, system testing and unit testing of an Earth System Model. The two main components of the Case Control System are: Scripts to enable simple generation of model executables and associated input files for different scientific cases, component resolutions and combinations of full, data and stub components with a handful of commands. Testing utilities to run defined system tests and report results for different configurations of the coupled system. A test case with SCHISM can be built with CIME by executing cd cime/scripts ./create_newcase --case test_schism --res TL319_rsfb --compset CSCHISM --run-unsupported --machine conda After the case is created, one needs to execute ./case.build and ./case.submit , but these currently do not yet work. Tasks are - fill in cime_config/buildlib - fill in cime_config/buildnml The development process is documented in https://github.com/schism-dev/schism-esmf/issues/20. Help is much appreciated.","title":"NCAR's Community Earth System Model"},{"location":"coupling/cesm.html#obtaining-cesm","text":"The version of CESM supporting SCHISM can be obtained as git clone https://github.com/mvertens/cesm.git -b feature/add_schism ./manage_externals/checkout_externals -v -o","title":"Obtaining CESM"},{"location":"coupling/cesm.html#obtaining-and-building-with-cime","text":"CIME, pronounced \"SEAM\", primarily consists of a Case Control System that supports the configuration, compilation, execution, system testing and unit testing of an Earth System Model. The two main components of the Case Control System are: Scripts to enable simple generation of model executables and associated input files for different scientific cases, component resolutions and combinations of full, data and stub components with a handful of commands. Testing utilities to run defined system tests and report results for different configurations of the coupled system. A test case with SCHISM can be built with CIME by executing cd cime/scripts ./create_newcase --case test_schism --res TL319_rsfb --compset CSCHISM --run-unsupported --machine conda After the case is created, one needs to execute ./case.build and ./case.submit , but these currently do not yet work. Tasks are - fill in cime_config/buildlib - fill in cime_config/buildnml The development process is documented in https://github.com/schism-dev/schism-esmf/issues/20. Help is much appreciated.","title":"Obtaining and building with CIME"},{"location":"coupling/coastalapp.html","text":"The NOAA Environmental Modeling System (NEMS) Coastal Application \"CoastalApp\" is a NUOPC-based coupled system using the NEMS coupler. The SCHISM NUOPC cap is currently being integrated as an ocean component of the CoastalApp; CoastalApp is available from a public repository https://github.com/noaa-ocs-modeling/CoastalApp , and its integration with SCHISM occurs in the develop-updates branch Obtaining and building CoastalApp \u00b6 export COASTALAPP_DIR=/my/path/to/coastalapp git clone https://github.com/noaa-ocs-modeling/CoastalApp -b develop $COASTALAPP_DIR cd $COASTALAPP_DIR git submodule update --init --recursive SCHISM/schism SCHISM/schism-esmf NEMS bash ./build.sh -component \"SCHISM\" You can add components like WW3 or ADCIRC , and you may be required to choose a -compiler or -platform , or set environment variables like PARMETIS or ESMFMKFILE . Consult ./build.sh -h for help and further information. A typical coupled system that we currently use for testing would, e.g., include the three components OCN-ATM-WAV: git submodule update --init --recursive SCHISM/schism SCHISM/schism-esmf NEMS WW3 ATMESH ./scripts/download_parmetis.sh bash ./build.sh -component \"SCHISM WW3 ATMESH\" --thirdparty parmetis Reporting bugs or requesting features \u00b6 The integration of SCHISM into CoastalApp is still in development. Please report any errors or annoyances in the upstream bug tracker on https://github.com/noaa-ocs-modeling/CoastalApp/issues .","title":"NOAA's CoastalApp"},{"location":"coupling/coastalapp.html#obtaining-and-building-coastalapp","text":"export COASTALAPP_DIR=/my/path/to/coastalapp git clone https://github.com/noaa-ocs-modeling/CoastalApp -b develop $COASTALAPP_DIR cd $COASTALAPP_DIR git submodule update --init --recursive SCHISM/schism SCHISM/schism-esmf NEMS bash ./build.sh -component \"SCHISM\" You can add components like WW3 or ADCIRC , and you may be required to choose a -compiler or -platform , or set environment variables like PARMETIS or ESMFMKFILE . Consult ./build.sh -h for help and further information. A typical coupled system that we currently use for testing would, e.g., include the three components OCN-ATM-WAV: git submodule update --init --recursive SCHISM/schism SCHISM/schism-esmf NEMS WW3 ATMESH ./scripts/download_parmetis.sh bash ./build.sh -component \"SCHISM WW3 ATMESH\" --thirdparty parmetis","title":"Obtaining and building CoastalApp"},{"location":"coupling/coastalapp.html#reporting-bugs-or-requesting-features","text":"The integration of SCHISM into CoastalApp is still in development. Please report any errors or annoyances in the upstream bug tracker on https://github.com/noaa-ocs-modeling/CoastalApp/issues .","title":"Reporting bugs or requesting features"},{"location":"coupling/esmf.html","text":"The Earth System Modeling Framework (ESMF) is a suite of software tools for developing high-performance, multi-component Earth science modeling applications. Such applications may include a few or dozens of components representing atmospheric, oceanic, terrestrial, or other physical domains, and their constituent processes (dynamical, chemical, biological, etc.). Often these components are developed by different groups independently, and must be \u201ccoupled\u201d together using software that transfers and transforms data among the components in order to form functional simulations. SCHISM can be such a model component within an ESMF-coupled system. A so-called \"cap\" wraps SCHISM and exposes it via the ESMF Application Programming Interface (API). The interfaces exposed through the API are (1) import of fields, (2) export of fields, and (3) control structure. Obtaining and building the cap \u00b6 The ESMF and the NUOPC caps are jointly hosted in a separate repository on https://github.com/schism-dev/schism-esmf . It requires that the SCHISM core is built and pointed to by the environment variable $SCHISM_BUILD_DIR export SCHISM_ESMF_DIR=/my/path/to/schism-esmf git clone https://github.com/schism-dev/schism-esmf.git $SCHISM_ESMF_DIR cd $SCHISM_ESMF_DIR make install-esmf The combined SCHISM and SCHISM-ESMF libraries will be available in the ./lib subdirectory. Pre-configured executables \u00b6 While the API exposed through the SCHISM-ESMF library is the core functionality of the cap, there are also several pre-configured simple coupled systems available for you to make or use as a template: concurrent_esmf_test.F90 multi_schism.F90 schism_driver_interfaces.F90 schism_pdaf.F90 triple_schism.F90 Have a look at the examples subdirectory! Applications \u00b6 (1) The SCHISM ESMF cap is used to couple SCHISM to the Parallel Data Assimilation Framework leveraging the control structures of ESMF, see the example schism_pdaf.F90 . (2) The SCHISM ESMF cap is used in the Modular System for Shelves and Coasts, see MOSSCO . Within that system, SCHISM can be flexibly coupled to components for the atmosphere, waves, ocean BGC, generic input/output, sediment. Publications \u00b6 Yu, H.-C., Zhang, Y. J., Nerger, L., Lemmen, C., Yu, J. C. S., Chou, T.-Y., Chu, C.-H., and Terng, C.-T.: Development of a flexible data assimilation method in a 3D unstructured-grid ocean model under Earth System Modeling Framework, EGUsphere [preprint], https://doi.org/10.5194/egusphere-2022-114 , 2022. Reporting bugs or requesting features \u00b6 The ESMF cap is still in development. Please report any errors or annoyances in our bug tracker on https://github.com/schism-dev/schism-esmf/issues. Also, please request features there, such as additional import or export fields.","title":"Earth System Modeling Framework"},{"location":"coupling/esmf.html#obtaining-and-building-the-cap","text":"The ESMF and the NUOPC caps are jointly hosted in a separate repository on https://github.com/schism-dev/schism-esmf . It requires that the SCHISM core is built and pointed to by the environment variable $SCHISM_BUILD_DIR export SCHISM_ESMF_DIR=/my/path/to/schism-esmf git clone https://github.com/schism-dev/schism-esmf.git $SCHISM_ESMF_DIR cd $SCHISM_ESMF_DIR make install-esmf The combined SCHISM and SCHISM-ESMF libraries will be available in the ./lib subdirectory.","title":"Obtaining and building the cap"},{"location":"coupling/esmf.html#pre-configured-executables","text":"While the API exposed through the SCHISM-ESMF library is the core functionality of the cap, there are also several pre-configured simple coupled systems available for you to make or use as a template: concurrent_esmf_test.F90 multi_schism.F90 schism_driver_interfaces.F90 schism_pdaf.F90 triple_schism.F90 Have a look at the examples subdirectory!","title":"Pre-configured executables"},{"location":"coupling/esmf.html#applications","text":"(1) The SCHISM ESMF cap is used to couple SCHISM to the Parallel Data Assimilation Framework leveraging the control structures of ESMF, see the example schism_pdaf.F90 . (2) The SCHISM ESMF cap is used in the Modular System for Shelves and Coasts, see MOSSCO . Within that system, SCHISM can be flexibly coupled to components for the atmosphere, waves, ocean BGC, generic input/output, sediment.","title":"Applications"},{"location":"coupling/esmf.html#publications","text":"Yu, H.-C., Zhang, Y. J., Nerger, L., Lemmen, C., Yu, J. C. S., Chou, T.-Y., Chu, C.-H., and Terng, C.-T.: Development of a flexible data assimilation method in a 3D unstructured-grid ocean model under Earth System Modeling Framework, EGUsphere [preprint], https://doi.org/10.5194/egusphere-2022-114 , 2022.","title":"Publications"},{"location":"coupling/esmf.html#reporting-bugs-or-requesting-features","text":"The ESMF cap is still in development. Please report any errors or annoyances in our bug tracker on https://github.com/schism-dev/schism-esmf/issues. Also, please request features there, such as additional import or export fields.","title":"Reporting bugs or requesting features"},{"location":"coupling/mossco.html","text":"The Modular System for Shelves and Coasts (MOSSCO) is a framework for coupling processes or domains that are originally developed in standalone numerical models. The software MOSSCO implements this infrastructure in the form of a library of components and couplers, and of example coupled applications. The components \"wrap\" external models used in coastal and shelf sciences; these wrapped components are then coupled to each other in the Earth System Modeling Framework (ESMF). The SCHISM ESMF cap integrates with MOSSCO. Obtaining and building MOSSCO \u00b6 export SCHISM_BUILD_DIR=/my/path/to/schism/build export SCHISM_ESMF_DIR=/my/path/to/schism-esmf export MOSSCO_DIR=/my/path/to/mossco git clone https://git.code.sf.net/p/mossco/code $MOSSCO_DIR cd $MOSSCO_DIR make all install Using SCHISM as part of a MOSSCO coupled system \u00b6 A simple preconfigured application is available in $MOSSCO_DIR/examples/esmf/schism . To build it, run make in that directory. You can use the resulting executable as a drop-in replacement for SCHISM's standalone pschism executable, but you need to add the mossco.cfg resource file which overrides param.nml for control parameters of the coupled system, like start and stop time. Reporting bugs or requesting features \u00b6 The integration of SCHISM into MOSSCO is still in development. Please report any errors or annoyances in the bug tracker on https://sourceforge.net/p/mossco/tickets/ .","title":"Modular System for Shelves and Coasts"},{"location":"coupling/mossco.html#obtaining-and-building-mossco","text":"export SCHISM_BUILD_DIR=/my/path/to/schism/build export SCHISM_ESMF_DIR=/my/path/to/schism-esmf export MOSSCO_DIR=/my/path/to/mossco git clone https://git.code.sf.net/p/mossco/code $MOSSCO_DIR cd $MOSSCO_DIR make all install","title":"Obtaining and building MOSSCO"},{"location":"coupling/mossco.html#using-schism-as-part-of-a-mossco-coupled-system","text":"A simple preconfigured application is available in $MOSSCO_DIR/examples/esmf/schism . To build it, run make in that directory. You can use the resulting executable as a drop-in replacement for SCHISM's standalone pschism executable, but you need to add the mossco.cfg resource file which overrides param.nml for control parameters of the coupled system, like start and stop time.","title":"Using SCHISM as part of a MOSSCO coupled system"},{"location":"coupling/mossco.html#reporting-bugs-or-requesting-features","text":"The integration of SCHISM into MOSSCO is still in development. Please report any errors or annoyances in the bug tracker on https://sourceforge.net/p/mossco/tickets/ .","title":"Reporting bugs or requesting features"},{"location":"coupling/nuopc.html","text":"The National Unified Operational Prediction Capability (NUOPC) is a consortium of Navy, NOAA, and Air Force modelers and their research partners. It aims to advance the weather prediction modeling systems used by meteorologists, mission planners, and decision makers. NUOPC partners are working toward a common model architecture - a standard way of building models - in order to make it easier to collaboratively build modeling systems. To this end, they have developed the NUOPC Layer that defines conventions and a set of generic components for building coupled models using the Earth System Modeling Framework (ESMF). SCHISM can be such a model component within an NUOPC-coupled system. A so-called \"cap\" wraps SCHISM and exposes it via the NUOPC Application Programming Interface (API). The interfaces exposed through the API are (1) import of fields, (2) export of fields, and (3) control structure. Obtaining and building the cap \u00b6 The NUOPC and the ESMF caps are jointly hosted in a separate repository on https://github.com/schism-dev/schism-esmf . It requires that the SCHISM core is built and pointed to by the environment variable $SCHISM_BUILD_DIR export SCHISM_ESMF_DIR=/my/path/to/schism-esmf git clone https://github.com/schism-dev/schism-esmf.git $SCHISM_ESMF_DIR cd $SCHISM_ESMF_DIR make install-nuopc The combined SCHISM and SCHISM-NUOPC libraries, as well as the NUOPC-compliant Makefile snippet schism.mk will be available in the ./lib subdirectory. Applications \u00b6 The SCHISM NUOPC cap is currently used in the development version of the NOAA Environmental Modeling System (NEMS) CoastalApp . Within that system, SCHISM is coupled to components for the atmosphere (data or WRF), waves (data or WaveWatch III), and inland water (National Water Model). Reporting bugs or requesting features \u00b6 The ESMF cap is still in development. Please report any errors or annoyances in our bug tracker here . Also, please request features there, such as additional import or export fields.","title":"National Unified Operational Prediction Capability"},{"location":"coupling/nuopc.html#obtaining-and-building-the-cap","text":"The NUOPC and the ESMF caps are jointly hosted in a separate repository on https://github.com/schism-dev/schism-esmf . It requires that the SCHISM core is built and pointed to by the environment variable $SCHISM_BUILD_DIR export SCHISM_ESMF_DIR=/my/path/to/schism-esmf git clone https://github.com/schism-dev/schism-esmf.git $SCHISM_ESMF_DIR cd $SCHISM_ESMF_DIR make install-nuopc The combined SCHISM and SCHISM-NUOPC libraries, as well as the NUOPC-compliant Makefile snippet schism.mk will be available in the ./lib subdirectory.","title":"Obtaining and building the cap"},{"location":"coupling/nuopc.html#applications","text":"The SCHISM NUOPC cap is currently used in the development version of the NOAA Environmental Modeling System (NEMS) CoastalApp . Within that system, SCHISM is coupled to components for the atmosphere (data or WRF), waves (data or WaveWatch III), and inland water (National Water Model).","title":"Applications"},{"location":"coupling/nuopc.html#reporting-bugs-or-requesting-features","text":"The ESMF cap is still in development. Please report any errors or annoyances in our bug tracker here . Also, please request features there, such as additional import or export fields.","title":"Reporting bugs or requesting features"},{"location":"getting-started/compilation.html","text":"Your system must have a FORTRAN and C compiler (and MPI wrapper like mpif90, mpicc), netcdf (version 4.4 or newer is required), python (version 2.7 and above) and perl installed. Two build system is currenlty available - GNU Make and Cmake GNU Make \u00b6 You need the following two directories for gnu make. src/ where the source code resides and the Makefile which is the main makefile. In general this src/Makefile should not be changed. In mk/ , there are other makefiles Make.defs.* which can be used to provide system specific information (e.g., name of compilers). You need a mk/Make.defs.local file for compilation. To help you design this file, we have put Make.defs.* which are from various clusters around the world as well as common linux operating systems. You should copy/link one of these to Make.defs.local . For example, if your MPI compiler is Intel based ifort, you may try - # Copy cp Make.defs.bora Make.defs.myown # and then link ln -sf Make.defs.myown Make.defs.local Then you need to edit Make.defs.local for e.g. the MPI compiler name, path names for netcdf library (v4.4 and above preferred) on your local cluster (sometimes you may also need to add FORTRAN support for netcdf, e.g. \u2013lnetcdff ), and name of the executable ( EXEC ). Also the graph partitioning lib ParMETIS is compiled each time together with the SCHISM code, and you may need to update the MPI C compiler names in src/ParMetis-* (consult also INSTALL inside the ParMETIS directory). Lastly, turn on/off modules in include_modules (note that TVD_LIM should always have a valid value). Make sure mk/sfmakedepend.pl and mk/cull_depends.py are executable (otherwise make them executable with chmod +x ). After all of these are done - cd ../src make clean make pschism You might get some errors if you did not use git to clone so the make cannot find the hash information; ignore it and proceed in making. The final name of executable has the cluster name and also additional suffixes if you turn on modules: pschism_* (note that you get a preview of this name when you do make clean so you know which modules you have turned on). Note: the Makefile will automatically invoke Core/gen_version.py , which will generate Core/schism_version.F90 , needed for querying the hash/version. Cmake \u00b6 The cmake utility is a very powerful way of building the source code and utility script bundle. The main cmake files are found in cmake/. You\u2019ll need two essential files in this directory. SCHISM.local.build : used to toggle on/off optional modules (similar to include_modules used in make). TVD_LIM should always have a valid value, and BLD_STANDALONE should be ON (to build SCHISM alone; OFF is for building SCHISM as a UFS/ESMF component). All other 'modules' are usually turned off for pure hydrodynamic applications. NO_PARMETIS : you can bypass ParMETIS lib by providing instead a domain partitioning map ( partition.prop which is identical to the output from ParMETIS global_to_local.prop ) at runtime. OLDIO : this swtich controls the global outputs. We have implemented asynchronous I/O (aka 'scribed' I/O) where combined global variables are outputted by dedicated scribes cores. To use this option, OLDIO should be off, and the user needs to specify number of scribe cores at command line. See 'Running the model' for more details. If OLDIO is turned on, previous I/O mode (i.e. outputs per MPI process) is used and the user needs to use post-processing scripts to combine outputs; SCHISM.local.cluster_name : similar to Make.defs.local, this file specifies the most important environment variables like name/path of compiler, netcdf library etc. In general, cmake is quite adept at inferring some of these variables but sometimes you might need to overwrite the defaults in this file. You can start from an existing file for a similar cluster e.g. cp -L SCHISM.local.whirlwind SCHISM.local.myown Once these two files are set, run - mkdir ../build cd ../build ; rm -rf * # Clean old cache cmake -C ../cmake/SCHISM.local.build -C ../cmake/SCHISM.local.myown ../src/ The cmake is essentially a pre-processor for make, and it creates cache files (e.g. build/ CMakeCache.txt, where you can inspect all env variables). After cmake is done, make can be executed in parallel or in serial mode. make -j8 pschism # efficient parallel build; you can replace \"8\" with number of processes you want # or make VERBOSE = 1 pschism # serial build with a lot of messages The executable ( pschism_ with extensions) is found in build/bin/ and the compiled libraries are in build/lib/ . If pschism is omitted above, the main executable and all utility scripts will be built in bin/ .","title":"Compilation"},{"location":"getting-started/compilation.html#gnu-make","text":"You need the following two directories for gnu make. src/ where the source code resides and the Makefile which is the main makefile. In general this src/Makefile should not be changed. In mk/ , there are other makefiles Make.defs.* which can be used to provide system specific information (e.g., name of compilers). You need a mk/Make.defs.local file for compilation. To help you design this file, we have put Make.defs.* which are from various clusters around the world as well as common linux operating systems. You should copy/link one of these to Make.defs.local . For example, if your MPI compiler is Intel based ifort, you may try - # Copy cp Make.defs.bora Make.defs.myown # and then link ln -sf Make.defs.myown Make.defs.local Then you need to edit Make.defs.local for e.g. the MPI compiler name, path names for netcdf library (v4.4 and above preferred) on your local cluster (sometimes you may also need to add FORTRAN support for netcdf, e.g. \u2013lnetcdff ), and name of the executable ( EXEC ). Also the graph partitioning lib ParMETIS is compiled each time together with the SCHISM code, and you may need to update the MPI C compiler names in src/ParMetis-* (consult also INSTALL inside the ParMETIS directory). Lastly, turn on/off modules in include_modules (note that TVD_LIM should always have a valid value). Make sure mk/sfmakedepend.pl and mk/cull_depends.py are executable (otherwise make them executable with chmod +x ). After all of these are done - cd ../src make clean make pschism You might get some errors if you did not use git to clone so the make cannot find the hash information; ignore it and proceed in making. The final name of executable has the cluster name and also additional suffixes if you turn on modules: pschism_* (note that you get a preview of this name when you do make clean so you know which modules you have turned on). Note: the Makefile will automatically invoke Core/gen_version.py , which will generate Core/schism_version.F90 , needed for querying the hash/version.","title":"GNU Make"},{"location":"getting-started/compilation.html#cmake","text":"The cmake utility is a very powerful way of building the source code and utility script bundle. The main cmake files are found in cmake/. You\u2019ll need two essential files in this directory. SCHISM.local.build : used to toggle on/off optional modules (similar to include_modules used in make). TVD_LIM should always have a valid value, and BLD_STANDALONE should be ON (to build SCHISM alone; OFF is for building SCHISM as a UFS/ESMF component). All other 'modules' are usually turned off for pure hydrodynamic applications. NO_PARMETIS : you can bypass ParMETIS lib by providing instead a domain partitioning map ( partition.prop which is identical to the output from ParMETIS global_to_local.prop ) at runtime. OLDIO : this swtich controls the global outputs. We have implemented asynchronous I/O (aka 'scribed' I/O) where combined global variables are outputted by dedicated scribes cores. To use this option, OLDIO should be off, and the user needs to specify number of scribe cores at command line. See 'Running the model' for more details. If OLDIO is turned on, previous I/O mode (i.e. outputs per MPI process) is used and the user needs to use post-processing scripts to combine outputs; SCHISM.local.cluster_name : similar to Make.defs.local, this file specifies the most important environment variables like name/path of compiler, netcdf library etc. In general, cmake is quite adept at inferring some of these variables but sometimes you might need to overwrite the defaults in this file. You can start from an existing file for a similar cluster e.g. cp -L SCHISM.local.whirlwind SCHISM.local.myown Once these two files are set, run - mkdir ../build cd ../build ; rm -rf * # Clean old cache cmake -C ../cmake/SCHISM.local.build -C ../cmake/SCHISM.local.myown ../src/ The cmake is essentially a pre-processor for make, and it creates cache files (e.g. build/ CMakeCache.txt, where you can inspect all env variables). After cmake is done, make can be executed in parallel or in serial mode. make -j8 pschism # efficient parallel build; you can replace \"8\" with number of processes you want # or make VERBOSE = 1 pschism # serial build with a lot of messages The executable ( pschism_ with extensions) is found in build/bin/ and the compiled libraries are in build/lib/ . If pschism is omitted above, the main executable and all utility scripts will be built in bin/ .","title":"Cmake"},{"location":"getting-started/getting-sourcecode.html","text":"SCHISM modeling system is mostly distributed via github. To download the source code it is good idea to have git installed in your system. If you have git, you can download the sourcecode with the following commands - git clone --recurse-submodules https://github.com/schism-dev/schism.git cd schism This will give you the latest master branch. If you want to get certain tagged versions use the tag command of git as (for example) git checkout tags/v5.10.0 - for v5.10.0. Note that sometimes you might need to add your system\u2019s ssh public key to your github.com account first before cloning. If cloning fails, you can also go to https://github.com/schism-dev and directly download the zip files. General users have access to all branches and tags of the repository (https://github.com/schism-dev/schism). You can find online manuals for the latest stable master or newer tags after v5.9.0. The developers will constantly update the manuals to keep them up to date as much as possible.","title":"Getting the source code"},{"location":"getting-started/grid-generation.html","text":"UG (unstructured grid or 'mesh') modelling starts with mesh generation, and the latter is often an iterative process. Here lies the greatest strength and challenges of using an UG model like SCHISM. Fortunately the meshgen tools have come a long way since 2000s and at the moment we are routinely generating large UGs with millions of nodes and ever higher resolution, all within a few hours (after the Digital Elevation Model (DEM) has been assembled). Note We will only cover SCHISM specific aspects of gridgen using SMS in this chapter; you are referred to schism.wiki for other info related to DEM preparation etc. Please also refer to Dr. Wood\u2019s thesis for some insight info on using SMS. Important One important point to remember is that mesh generation for SCHISM always starts from raw high-quality DEMs; do NOT use computational grids from another model as DEM because most hydrodynamic models smooth the bathymetry. With some practice and care, you can generate complex UG like Figure 1 . A few important things to note before we dive into details of mesh generation. SCHISM is an implicit model It can tolerate bad mesh quality (at least it won\u2019t blow up easily) High resolution is and should be used to faithfully capture the main features of DEMs Since we do not smooth or manipulate bathymetry in the model mesh, the model results are sensitive/responsive to DEM quality. Therefore, make sure the DEM quality is sufficiently good. Establish your workflow starting from mesh generation to model setup so you can easily repeat/iterate. San Francisco Bay & Delta grid (c/o CAL-Department of Water Resource (DWR)). Beware of CFL number \u00b6 You may be familiar with the CFL restriction associated with explicit (mode-splitting) models \\(\\text{CFL} \\lt 1\\) , where the CFL number is defined as - \\[\\begin{equation} \\label{eq01} \\text{CFL} = \\frac{\\left( \\left| \\pmb{u} \\right| + \\sqrt{gh} \\right) \\Delta t}{\\Delta x} \\end{equation}\\] where \\(h\\) is the local water depth, and \\(\\pmb{u}\\) is the flow velocity. Note that the surface wave celerity term is undefined when \\(h \\lt 0\\) , and in the shallow area it\u2019s best to drop this term and assume \\(\\left| \\pmb{u} \\right| \\sim 1\\) , and therefore \\(\\text{CFL} \\approx \\frac{\\Delta t}{\\Delta x}\\) when \\(h \\lt 0.1\\) m. Being an implicit model using ELM, SCHISM has a somewhat opposite requirement: \\[\\begin{equation} \\label{eq02} \\text{CFL} \\gt 0.4 \\end{equation}\\] You may be able to get away with \\(\\text{CFL}\\gt 0.2\\) in some applications like tsunami. Therefore care must be taken in the mesh generation process; otherwise numerical diffusion in ELM would ruin your results, which may manifest itself in the form of either noise or dissipation. For a given mesh, the errors changes with \\(\\Delta t\\) in a nonlinear manner, as shown in Figure 2 . Operational range for time step for a given mesh size. The meshgen process for SCHISM therefore starts with a range of time step for your application, We found the following ranges work for field applications: 100-400s step for barotropic applications, and 100-200s for baroclinic applications. Eqn. \\(\\ref{eq02}\\) is then used to calculate the \\(coarsest\\) mesh size at each depth (in anticipation of the smallest possible \\(\\Delta t = 100s\\) ). Table 1 shows some examples. You can see that the inverse CFL restriction is not restrictive. Table 1. Coarsest mesh resolution at sample depths, assuming a \u2018worse case\u2019 scenario of \\(\\Delta t=100s\\) . h(m) \\(\\Delta x_{max}\\) (m) 1 790 10 2500 50 5.5e3 100 7.9e3 500 1.7e4 1000 2.5e4 4000 5e4 Three immediate consequences of Eqs. \\(\\ref{eq02}\\) are that - you do not need to reduce \\(\\Delta t\\) if you refine mesh (yay!) if you have to coarsen mesh, you will have to recheck Eq. \\(\\ref{eq02}\\) if you have to reduce the time step for some reason, you may have to refine mesh The first consequence embodies the greatest strength (efficiency) of SCHISM as an implicit model. (However, if you are doing a convergence study, you need to keep the \\(\\text{CFL}\\) number fixed while reducing the time step (which means you have to reduce the mesh spacing), as is done with explicit models.) Therefore both explicit and implicit models converge (and are consistent) as \\(\\Delta x, \\Delta t \\rightarrow 0\\) and \\(\\frac{\\Delta x}{\\Delta t} = \\text{constant}\\) . Check CFL number in xmgredit5 With xmgredit5, you can very easily visualize CFL for the entire grid. xmgredit5 -belel -1.e-10 hgrid.gr3 . -belel -1.e-10 is used mainly to increase precision for lat/lon grid. if your hgrid.gr3 is in lat/lon, you need to first project it, as the grid size dx in lat/lon is not in meters) Since the CFL inside ACE is calculated without \\(\\pmb{u}\\) , and a different form is used for CFL in the shallow \\(h \\lt 0.1m\\) , we should impose a min depth of 0.1m, so that \\(\\sqrt{gh} = 1m/s\\) . You can do this by - Edit \\(\\rightarrow\\) Edit over grid/regions \\(\\rightarrow\\) Evaluate. In the dialogue box, type depth=max(depth,0.1) The Evaluate function is also very useful for generation of other .gr3 files needed by SCHISM Special \\(\\rightarrow\\) Dimensionless numbers. In the right half of the dialogue box, type in 100s ( \\(\\Delta t\\) ), Warning value (say 0.8), Unacceptable value (say 0.4), press Display filled. The color will appear in the main window, with red indicating good CFL, and green for bad CFL, and orange somewhere in between. You may also 'Display Courant number' but this may take a while to refresh, and so you may want to zoom into a small region first. Small patches of \u2018green\u2019 are OK with SCHISM, especially if they are in shallow area. However, avoid large patches of green in deeper area. Revise your grid accordingly if necessary. Tsunami simulations In tsunami simulations, \\(\\Delta t\\) has to be small (~1s) due to small wavelength, and you can bypass the CFL condition by turning off advection in deeper depths as the advection is negligible there. You also need to make sure that each wavelength is resolved by at least 20 grid points. Mesh quality \u00b6 SCHISM\u2019s superior stability means the model is very forgiving in mesh quality; skewness of triangles (defined as the ratio between the max. side and the equivalent radius) >15 can be used without problem (the skewness can be easily checked with xmgredit5: Evaluate \\(\\rightarrow\\) Acceptable skewness). However, for baroclinic applications, mesh quality may be important in critical regions. Also note that quality quads are required; always use the pre-processing script fix_bad_quads.f90 to split bad quads. (You can check quad quality in xmgredit5 \\(\\rightarrow\\) Edit \\(\\rightarrow\\) Edit over region \\(\\rightarrow\\) Quality check for quadrangles, and input 0.5 (which is the ratio between the min and max interior angles) for cutoff and \u2018Accept\u2019. All violating elements will be highlighted.) Unlike explicit models, you\u2019ll find meshgen for SCHISM is more \u2018intuitive\u2019 and \u2018freer\u2019. Implicit model allows you to focus on physics instead of numerics. You are freer to resolve important features (e.g. jetties) without worrying about cost/instability. SCHISM is not picky about mesh quality (except for quads). While the physics generally suggests that coarser resolution be used in deeper depths, this is not always the best practice. E.g., you should resolve the channel to more accurately represent the salt intrusion process. Barotropic simulation Mesh quality requirement is relatively lax for barotropic simulations. Besides the considerations above, you mainly need to use appropriate resolution based on physics (e.g., generally coarser resolution in deeper depths and finer resolution for shallow depths but make sure channels are resolved/unblocked). Most important task is to accurately capture the water volume for tide propagation. Remember: you are on implicit UG territory, and so you are free to resolve features as you wish! Baroclinic simulation The transport process is influenced by your choice of mesh, and so the meshgen for baroclinic simulations needs some attention. The mesh quality may need to be better in some critical areas (otherwise you may see noise). Quasi-uniform grid needs to be used in the eddying regime, not for stability but to avoid distortion of eddies (Zhang et al. 2016); gradual transition in resolution should be used as much as possible for eddying regime. Avoiding excessive resolution in high-flow area would speed up the transport TVD solver. Mesh generation process for baroclinic applications requires more effort and is often an iterative process, and so it\u2019s important to establish a good work flow from the start. In a later chapter we will cover some advanced topics on meshing eddying and transitional regimes. Conceptual maps in SMS While there are many methods for creating conceptual maps in SMS, we typically extract representative isobaths (e.g., isobath at the highest gradient that represents slope) first as shapefiles using e.g. GIS tools, and then import the shapefiles into SMS as feature arcs, and specify resolution along each arc based on Table 1 . An exmample map is given below. The key is to faithfully capture the main features of DEMs. There are two main types of meshing options in SMS: paving (triangles) and patch (quads) that can be effetively utilized for our purpose. SMS map in a stretch of San Francisco Bay. Channels, channels, channels \u00b6 Channels serve as the main conduit for fresh and ocean water flow, and thus are very important features for gravitational circulation. When meshing channels, try to use \u2018patch\u2019 method to generate quads as much as possible for better efficiency and precise control on cross-channel resolution (and do not round corners (Figure 3 )). Use arcs to follow the thalweg and the steep slopes (highest gradient zone for isobaths). Avoid artificial blocking of channels (Figure 4 ), which may lead to noisy flow field, but try to represent the channel cross section as faithfully as possible to capture the water volume. There is no need for bathymetry smoothing or other manipulation (and implicitness allows high resolution on steep slope and skew elements). A good mesh together with SCHISM\u2019s flexible vertical gridding system \\(LSC^2\\) one can accurately capture the 3D processes. Side view of channel representation. Remember SCHISM does not allow partial wet/dry. Patch method It is well known that channelized flow is better simulated using flow-aligned quads. Therefore we recommend using patch in SMS to mesh channels. This approach allows precise control on the cross-channel resolution which is important for 3D processes. Paving, on the other hand, can lead to either excessively large mesh size or inadequate cross-channel resolution. Meshing near wetting and drying \u00b6 You may want to have an arc follow the initial shoreline (but there is no need to be exactly following the shoreline). Reasonable mesh transition should be done from shoreline to dryland. Use comparable or finer mesh resolution in the dryland that is expected to be wetted, and then transition to coarser resolution beyond (to account for rare inundation). Simulating wetting and drying well with SCHISM requires some care. A critical parameter in shallow area is the bottom friction. Note that the bottom friction parameterizations are very different between 2D and 3D prisms. From a physical point of view, the 2D and 3D models behave very differently. Consider a straight channel with variable depths, with flow coming from deeper part and going into shallower part. Figure 5 shows the side views of 2D and 3D velocities. Side view of channel flow for (a) 2D and (b) 3D cases. Volume conservation dictates larger velocities in shallow areas. Note that strong shear is possible in 3D model. In 2D model, the velocity is depth-averaged and vertical shear is not represented. Strong friction directly translates into reduced velocity. In 3D model however, a large bottom friction will lead to strong shear, although the depth integrated velocity value matches that from the 2D model. This problem is exacerbated by the exaggeration of \\(C_d\\) in the shallow if the roughness formula is used (since the bottom cell thickness is very small). A classical pathological velocity field obtained with SCHISM is seen in Figure 6 . Noisy velocity field in shallow areas in SCHISM 3D. There are a few approaches to resolve this issue. First, make sure the channel is not blocked. Second, try to use 2D prisms in shallows (so you can use large friction) with SCHISM \\(LSC^2\\) system. Using a larger thetai would also stabilize the wetting and drying fronts. As a last resort if you have to use 3D configuration in shallows, reduce friction (or even set it to 0). Dredging open boundary A very common crash is related to the wet/dry near the open boundary. SCHISM does NOT allow an entire open boundary segment to become dry at ANY time (while drying at individual nodes is fine). Therefore you need to make sure the depths there are deep enough compared to expected tidal range. An easy way is to impose a minimum depth near those segments (which can be done using xmgredit5) if the accuracy near the boundary is not of importance. Since the wet/dry rule inside SCHISM is element-based, a node becomes dry if all of its surrounding elements become dry. As a result, you may need to impose a minimum depth a couple of rows of elements into the domain, not just at open boundary nodes. This ensures that water can come into the domain without being blocked at the open boundary. Note that wet/dry is allowed to occur at land/island boundaries or interior nodes. Alternative options If you care about wetting and drying near the open boundary location, one option is to relocate the open boundary elsewhere. Also for upstream rivers where depths become negative and you do not want to dredge depths there, you can use the bed deformation option ( imm=1 ): start with a dredged boundary, and then gradually move the bed back to its original location. The most robust option, however, is to use point sources ( if_source=1 ): in this case no open boundary is required there so wet/dry can happen without crashing the code. However, the open boundary approach is usually more accurate. Periodic boundary condition \u00b6 Implementing this type of B.C. in SCHISM introduces some challenges in the barotropic solver because it\u2019d destroy the symmetry of the matrix and cause blowup if the conditioning is sufficiently bad. A workaround is to \u2018drape\u2019 the hgrid onto a sphere to avoid the corresponding open boundary segments altogether. A simple script to guide this process can be found in Utility/Pre-Processing/periodic_grid.f90 . DWR tools In the git directory of BayDeltaSCHISM you will find a number of useful python tools for DEM preparation and for aiding the gridgen.","title":"Mesh generation"},{"location":"getting-started/grid-generation.html#beware-of-cfl-number","text":"You may be familiar with the CFL restriction associated with explicit (mode-splitting) models \\(\\text{CFL} \\lt 1\\) , where the CFL number is defined as - \\[\\begin{equation} \\label{eq01} \\text{CFL} = \\frac{\\left( \\left| \\pmb{u} \\right| + \\sqrt{gh} \\right) \\Delta t}{\\Delta x} \\end{equation}\\] where \\(h\\) is the local water depth, and \\(\\pmb{u}\\) is the flow velocity. Note that the surface wave celerity term is undefined when \\(h \\lt 0\\) , and in the shallow area it\u2019s best to drop this term and assume \\(\\left| \\pmb{u} \\right| \\sim 1\\) , and therefore \\(\\text{CFL} \\approx \\frac{\\Delta t}{\\Delta x}\\) when \\(h \\lt 0.1\\) m. Being an implicit model using ELM, SCHISM has a somewhat opposite requirement: \\[\\begin{equation} \\label{eq02} \\text{CFL} \\gt 0.4 \\end{equation}\\] You may be able to get away with \\(\\text{CFL}\\gt 0.2\\) in some applications like tsunami. Therefore care must be taken in the mesh generation process; otherwise numerical diffusion in ELM would ruin your results, which may manifest itself in the form of either noise or dissipation. For a given mesh, the errors changes with \\(\\Delta t\\) in a nonlinear manner, as shown in Figure 2 . Operational range for time step for a given mesh size. The meshgen process for SCHISM therefore starts with a range of time step for your application, We found the following ranges work for field applications: 100-400s step for barotropic applications, and 100-200s for baroclinic applications. Eqn. \\(\\ref{eq02}\\) is then used to calculate the \\(coarsest\\) mesh size at each depth (in anticipation of the smallest possible \\(\\Delta t = 100s\\) ). Table 1 shows some examples. You can see that the inverse CFL restriction is not restrictive. Table 1. Coarsest mesh resolution at sample depths, assuming a \u2018worse case\u2019 scenario of \\(\\Delta t=100s\\) . h(m) \\(\\Delta x_{max}\\) (m) 1 790 10 2500 50 5.5e3 100 7.9e3 500 1.7e4 1000 2.5e4 4000 5e4 Three immediate consequences of Eqs. \\(\\ref{eq02}\\) are that - you do not need to reduce \\(\\Delta t\\) if you refine mesh (yay!) if you have to coarsen mesh, you will have to recheck Eq. \\(\\ref{eq02}\\) if you have to reduce the time step for some reason, you may have to refine mesh The first consequence embodies the greatest strength (efficiency) of SCHISM as an implicit model. (However, if you are doing a convergence study, you need to keep the \\(\\text{CFL}\\) number fixed while reducing the time step (which means you have to reduce the mesh spacing), as is done with explicit models.) Therefore both explicit and implicit models converge (and are consistent) as \\(\\Delta x, \\Delta t \\rightarrow 0\\) and \\(\\frac{\\Delta x}{\\Delta t} = \\text{constant}\\) . Check CFL number in xmgredit5 With xmgredit5, you can very easily visualize CFL for the entire grid. xmgredit5 -belel -1.e-10 hgrid.gr3 . -belel -1.e-10 is used mainly to increase precision for lat/lon grid. if your hgrid.gr3 is in lat/lon, you need to first project it, as the grid size dx in lat/lon is not in meters) Since the CFL inside ACE is calculated without \\(\\pmb{u}\\) , and a different form is used for CFL in the shallow \\(h \\lt 0.1m\\) , we should impose a min depth of 0.1m, so that \\(\\sqrt{gh} = 1m/s\\) . You can do this by - Edit \\(\\rightarrow\\) Edit over grid/regions \\(\\rightarrow\\) Evaluate. In the dialogue box, type depth=max(depth,0.1) The Evaluate function is also very useful for generation of other .gr3 files needed by SCHISM Special \\(\\rightarrow\\) Dimensionless numbers. In the right half of the dialogue box, type in 100s ( \\(\\Delta t\\) ), Warning value (say 0.8), Unacceptable value (say 0.4), press Display filled. The color will appear in the main window, with red indicating good CFL, and green for bad CFL, and orange somewhere in between. You may also 'Display Courant number' but this may take a while to refresh, and so you may want to zoom into a small region first. Small patches of \u2018green\u2019 are OK with SCHISM, especially if they are in shallow area. However, avoid large patches of green in deeper area. Revise your grid accordingly if necessary. Tsunami simulations In tsunami simulations, \\(\\Delta t\\) has to be small (~1s) due to small wavelength, and you can bypass the CFL condition by turning off advection in deeper depths as the advection is negligible there. You also need to make sure that each wavelength is resolved by at least 20 grid points.","title":"Beware of CFL number"},{"location":"getting-started/grid-generation.html#mesh-quality","text":"SCHISM\u2019s superior stability means the model is very forgiving in mesh quality; skewness of triangles (defined as the ratio between the max. side and the equivalent radius) >15 can be used without problem (the skewness can be easily checked with xmgredit5: Evaluate \\(\\rightarrow\\) Acceptable skewness). However, for baroclinic applications, mesh quality may be important in critical regions. Also note that quality quads are required; always use the pre-processing script fix_bad_quads.f90 to split bad quads. (You can check quad quality in xmgredit5 \\(\\rightarrow\\) Edit \\(\\rightarrow\\) Edit over region \\(\\rightarrow\\) Quality check for quadrangles, and input 0.5 (which is the ratio between the min and max interior angles) for cutoff and \u2018Accept\u2019. All violating elements will be highlighted.) Unlike explicit models, you\u2019ll find meshgen for SCHISM is more \u2018intuitive\u2019 and \u2018freer\u2019. Implicit model allows you to focus on physics instead of numerics. You are freer to resolve important features (e.g. jetties) without worrying about cost/instability. SCHISM is not picky about mesh quality (except for quads). While the physics generally suggests that coarser resolution be used in deeper depths, this is not always the best practice. E.g., you should resolve the channel to more accurately represent the salt intrusion process. Barotropic simulation Mesh quality requirement is relatively lax for barotropic simulations. Besides the considerations above, you mainly need to use appropriate resolution based on physics (e.g., generally coarser resolution in deeper depths and finer resolution for shallow depths but make sure channels are resolved/unblocked). Most important task is to accurately capture the water volume for tide propagation. Remember: you are on implicit UG territory, and so you are free to resolve features as you wish! Baroclinic simulation The transport process is influenced by your choice of mesh, and so the meshgen for baroclinic simulations needs some attention. The mesh quality may need to be better in some critical areas (otherwise you may see noise). Quasi-uniform grid needs to be used in the eddying regime, not for stability but to avoid distortion of eddies (Zhang et al. 2016); gradual transition in resolution should be used as much as possible for eddying regime. Avoiding excessive resolution in high-flow area would speed up the transport TVD solver. Mesh generation process for baroclinic applications requires more effort and is often an iterative process, and so it\u2019s important to establish a good work flow from the start. In a later chapter we will cover some advanced topics on meshing eddying and transitional regimes. Conceptual maps in SMS While there are many methods for creating conceptual maps in SMS, we typically extract representative isobaths (e.g., isobath at the highest gradient that represents slope) first as shapefiles using e.g. GIS tools, and then import the shapefiles into SMS as feature arcs, and specify resolution along each arc based on Table 1 . An exmample map is given below. The key is to faithfully capture the main features of DEMs. There are two main types of meshing options in SMS: paving (triangles) and patch (quads) that can be effetively utilized for our purpose. SMS map in a stretch of San Francisco Bay.","title":"Mesh quality"},{"location":"getting-started/grid-generation.html#channels-channels-channels","text":"Channels serve as the main conduit for fresh and ocean water flow, and thus are very important features for gravitational circulation. When meshing channels, try to use \u2018patch\u2019 method to generate quads as much as possible for better efficiency and precise control on cross-channel resolution (and do not round corners (Figure 3 )). Use arcs to follow the thalweg and the steep slopes (highest gradient zone for isobaths). Avoid artificial blocking of channels (Figure 4 ), which may lead to noisy flow field, but try to represent the channel cross section as faithfully as possible to capture the water volume. There is no need for bathymetry smoothing or other manipulation (and implicitness allows high resolution on steep slope and skew elements). A good mesh together with SCHISM\u2019s flexible vertical gridding system \\(LSC^2\\) one can accurately capture the 3D processes. Side view of channel representation. Remember SCHISM does not allow partial wet/dry. Patch method It is well known that channelized flow is better simulated using flow-aligned quads. Therefore we recommend using patch in SMS to mesh channels. This approach allows precise control on the cross-channel resolution which is important for 3D processes. Paving, on the other hand, can lead to either excessively large mesh size or inadequate cross-channel resolution.","title":"Channels, channels, channels"},{"location":"getting-started/grid-generation.html#meshing-near-wetting-and-drying","text":"You may want to have an arc follow the initial shoreline (but there is no need to be exactly following the shoreline). Reasonable mesh transition should be done from shoreline to dryland. Use comparable or finer mesh resolution in the dryland that is expected to be wetted, and then transition to coarser resolution beyond (to account for rare inundation). Simulating wetting and drying well with SCHISM requires some care. A critical parameter in shallow area is the bottom friction. Note that the bottom friction parameterizations are very different between 2D and 3D prisms. From a physical point of view, the 2D and 3D models behave very differently. Consider a straight channel with variable depths, with flow coming from deeper part and going into shallower part. Figure 5 shows the side views of 2D and 3D velocities. Side view of channel flow for (a) 2D and (b) 3D cases. Volume conservation dictates larger velocities in shallow areas. Note that strong shear is possible in 3D model. In 2D model, the velocity is depth-averaged and vertical shear is not represented. Strong friction directly translates into reduced velocity. In 3D model however, a large bottom friction will lead to strong shear, although the depth integrated velocity value matches that from the 2D model. This problem is exacerbated by the exaggeration of \\(C_d\\) in the shallow if the roughness formula is used (since the bottom cell thickness is very small). A classical pathological velocity field obtained with SCHISM is seen in Figure 6 . Noisy velocity field in shallow areas in SCHISM 3D. There are a few approaches to resolve this issue. First, make sure the channel is not blocked. Second, try to use 2D prisms in shallows (so you can use large friction) with SCHISM \\(LSC^2\\) system. Using a larger thetai would also stabilize the wetting and drying fronts. As a last resort if you have to use 3D configuration in shallows, reduce friction (or even set it to 0). Dredging open boundary A very common crash is related to the wet/dry near the open boundary. SCHISM does NOT allow an entire open boundary segment to become dry at ANY time (while drying at individual nodes is fine). Therefore you need to make sure the depths there are deep enough compared to expected tidal range. An easy way is to impose a minimum depth near those segments (which can be done using xmgredit5) if the accuracy near the boundary is not of importance. Since the wet/dry rule inside SCHISM is element-based, a node becomes dry if all of its surrounding elements become dry. As a result, you may need to impose a minimum depth a couple of rows of elements into the domain, not just at open boundary nodes. This ensures that water can come into the domain without being blocked at the open boundary. Note that wet/dry is allowed to occur at land/island boundaries or interior nodes. Alternative options If you care about wetting and drying near the open boundary location, one option is to relocate the open boundary elsewhere. Also for upstream rivers where depths become negative and you do not want to dredge depths there, you can use the bed deformation option ( imm=1 ): start with a dredged boundary, and then gradually move the bed back to its original location. The most robust option, however, is to use point sources ( if_source=1 ): in this case no open boundary is required there so wet/dry can happen without crashing the code. However, the open boundary approach is usually more accurate.","title":"Meshing near wetting and drying"},{"location":"getting-started/grid-generation.html#periodic-boundary-condition","text":"Implementing this type of B.C. in SCHISM introduces some challenges in the barotropic solver because it\u2019d destroy the symmetry of the matrix and cause blowup if the conditioning is sufficiently bad. A workaround is to \u2018drape\u2019 the hgrid onto a sphere to avoid the corresponding open boundary segments altogether. A simple script to guide this process can be found in Utility/Pre-Processing/periodic_grid.f90 . DWR tools In the git directory of BayDeltaSCHISM you will find a number of useful python tools for DEM preparation and for aiding the gridgen.","title":"Periodic boundary condition"},{"location":"getting-started/post-processing.html","text":"You can find some useful post-processing tools in the src/Utility directory. Combining scripts \u00b6 combine_output11.f90 is used to combine process-specific netcdf to global netcdf. autocombine_MPI_elfe.pl is a simple perl wrapper script that automatically combines all available outputs during or after the run. Use these if you invoked OLDIO in make. combine_hotstart7.f90 is used combine process-specific hotstart outputs ( outputs/hotstart_0*.nc ) into hotstart.nc . This is required even if you used scribed I/O (as hotstart outputs are still be emitted per MPI process). combine_gr3.f90 is used to combine process-specific maxelev_* and maxdahv_* (ASCII) into maxelev.gr3 or maxdahv.gr3 . Extraction & analysis \u00b6 read_output*.f90 : This group of scripts read multiple nc4 outputs and extract time series of a point, a slab, a transect etc. They share similar code structure and can be used to understand the nc4 output format as well as how to do your own processing. You may start from read_output*_xyz.f90 . After you are familiar with these scripts, you can easily customize them for your own purpose. Note that you'll need to use different extraction scripts depending on whether you use scribe I/O or not. E.g., if you use scribe I/O, the FORTRAN extraction scripts are read_output10*.f90 . There are also some analysis scripts, e.g. computing the averaged fields etc. Particle tracking \u00b6 This tool is explained here . One-way nesting \u00b6 OneWayNestScripts/interpolate_variables*.f90 : The purpose of this script is to generate elev2D.th.nc , SAL_3D.th.nc , TEM_3D.th.nc and/or uv3D.th.nc from a large-domain run to be used in a small-domain run. This is of limited utility now because uv3D.th.nc etc for the sub-tidal component can be generated using HYCOM or other large-scale models or observation. To prepare for the nesting, first do a 2D barotropic run for a larger or same grid, with only elevation b.c. Note that 2D model is inherently more stable than 3D model, and to further enhance stability, make sure you use indvel=1 (ishapiro=ihorcon=0) , thetai=1 , and also use a large Manning\u2019s \\(n\\) (e.g., 0.025 or larger) near the boundary. Once this is done use interpolate_variables7.f90 to generate *[23]D.th.nc for the small-domain run; use the new *[23]D.th.nc as inputs for the small-domain run. Note that interpolate_variables.in in the directory are sample inputs for the script. A common mistake is that the parent elements of some open boundary nodes in fg.gr3 (i.e. \u2018small-domain\u2019 hgrid) become dry and the script then fails to find a wet element to interpolate from. So make sure all open boundary nodes in fg.gr3 are located in wet region of bg.gr3 ; this is especially important for those nodes near the coast. You can use xmgredit5 to ascertain this. If necessary, modify fg.gr3 by moving some nodes to deeper depths.","title":"Postprocessing"},{"location":"getting-started/post-processing.html#combining-scripts","text":"combine_output11.f90 is used to combine process-specific netcdf to global netcdf. autocombine_MPI_elfe.pl is a simple perl wrapper script that automatically combines all available outputs during or after the run. Use these if you invoked OLDIO in make. combine_hotstart7.f90 is used combine process-specific hotstart outputs ( outputs/hotstart_0*.nc ) into hotstart.nc . This is required even if you used scribed I/O (as hotstart outputs are still be emitted per MPI process). combine_gr3.f90 is used to combine process-specific maxelev_* and maxdahv_* (ASCII) into maxelev.gr3 or maxdahv.gr3 .","title":"Combining scripts"},{"location":"getting-started/post-processing.html#extraction-analysis","text":"read_output*.f90 : This group of scripts read multiple nc4 outputs and extract time series of a point, a slab, a transect etc. They share similar code structure and can be used to understand the nc4 output format as well as how to do your own processing. You may start from read_output*_xyz.f90 . After you are familiar with these scripts, you can easily customize them for your own purpose. Note that you'll need to use different extraction scripts depending on whether you use scribe I/O or not. E.g., if you use scribe I/O, the FORTRAN extraction scripts are read_output10*.f90 . There are also some analysis scripts, e.g. computing the averaged fields etc.","title":"Extraction &amp; analysis"},{"location":"getting-started/post-processing.html#particle-tracking","text":"This tool is explained here .","title":"Particle tracking"},{"location":"getting-started/post-processing.html#one-way-nesting","text":"OneWayNestScripts/interpolate_variables*.f90 : The purpose of this script is to generate elev2D.th.nc , SAL_3D.th.nc , TEM_3D.th.nc and/or uv3D.th.nc from a large-domain run to be used in a small-domain run. This is of limited utility now because uv3D.th.nc etc for the sub-tidal component can be generated using HYCOM or other large-scale models or observation. To prepare for the nesting, first do a 2D barotropic run for a larger or same grid, with only elevation b.c. Note that 2D model is inherently more stable than 3D model, and to further enhance stability, make sure you use indvel=1 (ishapiro=ihorcon=0) , thetai=1 , and also use a large Manning\u2019s \\(n\\) (e.g., 0.025 or larger) near the boundary. Once this is done use interpolate_variables7.f90 to generate *[23]D.th.nc for the small-domain run; use the new *[23]D.th.nc as inputs for the small-domain run. Note that interpolate_variables.in in the directory are sample inputs for the script. A common mistake is that the parent elements of some open boundary nodes in fg.gr3 (i.e. \u2018small-domain\u2019 hgrid) become dry and the script then fails to find a wet element to interpolate from. So make sure all open boundary nodes in fg.gr3 are located in wet region of bg.gr3 ; this is especially important for those nodes near the coast. You can use xmgredit5 to ascertain this. If necessary, modify fg.gr3 by moving some nodes to deeper depths.","title":"One-way nesting"},{"location":"getting-started/pre-processing.html","text":"All .gr3 and .prop inputs can be visualized/generated using xmgredit5. For other inputs, you can find some useful pre-proc tools in the src/Utility directory. In general, all of our FORTRAN scripts have a header that explains its purpose, how to use it (inputs/outputs) and sample compilation command. Grid conversion \u00b6 2dm2gr3_m2m.pl and grd2sms.pl : These 2 perl scripts are used to convert between .2dm (SMS) and .gr3. Interpolation \u00b6 interpolate_unstructured.f90 : This efficient script can be used to interpolate depths from .gr3 onto another .gr3 quickly. It uses a bucket search algorithm along either x or y direction. To interpolate from raster files (.asc), use interpolate_depth_structured2.f90 . \\(LSC^2\\) scripts \u00b6 gen_vqs.f90 and plot_VQS.m : The FORTRAN script can be used as a start for creating a \\(LSC^2\\) grid and you need to use the matlab script to plot out transects to see if the vertical grid makes sense. You may lump multiple transects into 1 transect.bp . If you want to use this type of vgrid, make sure you go through the FORTRAN script carefully and understand the details. Nudging scripts \u00b6 gen_nudge.f90 , gen_nudge2.f90 : the two scripts generate either a simple elliptic nudging zone or a zone with fixed distance from boundary as *_nudge.gr3 . gen_nudge_from_hycom.f90 : This script generates the actual nudge data for tracers *_nu.nc from HYCOM (you may modify this for other gridded data sources from other structured-grid models). Hotstart \u00b6 Gen_Hotstart/change_hotstart4.f90 : This simple script shows you the internal structure of hotstart.nc and how to manipulate it. Gen_Hotstart/gen_*_from_hycom.f90 : These scripts show you how to create hotstart.nc and *.th.nc from gridded outputs like HYCOM. It essentially consists of 3D interpolations. Sflux_nc \u00b6 The matlab scripts inside Sflux_nc dir show you the structure of sflux*.nc as well as how to generate your own files. METIS for offline domain decomposition \u00b6 You'll only need to do this if you invoked offline partitioning in compilation (e.g. with NO_PARMETIS turned ON in cmake) to bypass ParMETIS. If so, you'll need to prepare an input called partion.prop (which is essentially the MPI process # for each element). Step 1: build METIS v5.1.0 by ( src/metis-5.1.0 ) following README inside. You only need gpmetis. Step 2: run a pre-processor for METIS: src/Utility/Grid_Scripts/metis_prep.f90 , which only requires hgrid.gr3 (with B.C. parts) and vgrid.in , to get graphinfo ; Step 3: run METIS: ./gpmetis graphinfo <nproc> -ufactor=1.01 -seed=15 where <nproc> is # of compute cores excluding scribes. The output is graphinfo.part.<nproc> , and then use awk to get partion.prop : awk '{print NR,$0}' graphinfo.part.<nproc> > partition.prop (replace <nproc> with actual # of cores). (For VIMS users, there is a simple perl wrapper in /sciclone/home10/yinglong/bin/partition_offline.pl )","title":"Preprocessing"},{"location":"getting-started/pre-processing.html#grid-conversion","text":"2dm2gr3_m2m.pl and grd2sms.pl : These 2 perl scripts are used to convert between .2dm (SMS) and .gr3.","title":"Grid conversion"},{"location":"getting-started/pre-processing.html#interpolation","text":"interpolate_unstructured.f90 : This efficient script can be used to interpolate depths from .gr3 onto another .gr3 quickly. It uses a bucket search algorithm along either x or y direction. To interpolate from raster files (.asc), use interpolate_depth_structured2.f90 .","title":"Interpolation"},{"location":"getting-started/pre-processing.html#lsc2-scripts","text":"gen_vqs.f90 and plot_VQS.m : The FORTRAN script can be used as a start for creating a \\(LSC^2\\) grid and you need to use the matlab script to plot out transects to see if the vertical grid makes sense. You may lump multiple transects into 1 transect.bp . If you want to use this type of vgrid, make sure you go through the FORTRAN script carefully and understand the details.","title":"\\(LSC^2\\) scripts"},{"location":"getting-started/pre-processing.html#nudging-scripts","text":"gen_nudge.f90 , gen_nudge2.f90 : the two scripts generate either a simple elliptic nudging zone or a zone with fixed distance from boundary as *_nudge.gr3 . gen_nudge_from_hycom.f90 : This script generates the actual nudge data for tracers *_nu.nc from HYCOM (you may modify this for other gridded data sources from other structured-grid models).","title":"Nudging scripts"},{"location":"getting-started/pre-processing.html#hotstart","text":"Gen_Hotstart/change_hotstart4.f90 : This simple script shows you the internal structure of hotstart.nc and how to manipulate it. Gen_Hotstart/gen_*_from_hycom.f90 : These scripts show you how to create hotstart.nc and *.th.nc from gridded outputs like HYCOM. It essentially consists of 3D interpolations.","title":"Hotstart"},{"location":"getting-started/pre-processing.html#sflux_nc","text":"The matlab scripts inside Sflux_nc dir show you the structure of sflux*.nc as well as how to generate your own files.","title":"Sflux_nc"},{"location":"getting-started/pre-processing.html#metis-for-offline-domain-decomposition","text":"You'll only need to do this if you invoked offline partitioning in compilation (e.g. with NO_PARMETIS turned ON in cmake) to bypass ParMETIS. If so, you'll need to prepare an input called partion.prop (which is essentially the MPI process # for each element). Step 1: build METIS v5.1.0 by ( src/metis-5.1.0 ) following README inside. You only need gpmetis. Step 2: run a pre-processor for METIS: src/Utility/Grid_Scripts/metis_prep.f90 , which only requires hgrid.gr3 (with B.C. parts) and vgrid.in , to get graphinfo ; Step 3: run METIS: ./gpmetis graphinfo <nproc> -ufactor=1.01 -seed=15 where <nproc> is # of compute cores excluding scribes. The output is graphinfo.part.<nproc> , and then use awk to get partion.prop : awk '{print NR,$0}' graphinfo.part.<nproc> > partition.prop (replace <nproc> with actual # of cores). (For VIMS users, there is a simple perl wrapper in /sciclone/home10/yinglong/bin/partition_offline.pl )","title":"METIS for offline domain decomposition"},{"location":"getting-started/running-model.html","text":"The model executable needs to be run inside the folder where all the model input files reside. The following inputs are minimum - hgrid.gr3 vgrid.in param.nml [your_choice_of_bottom_friction].gr3 bctides.in The model is usually run through a batch script, which in essence executes the code like: mpirun -np NPROC ./pschism <# scribes> (if OLDIO is OFF) mpirun -np NPROC ./pschism (if OLDIO is ON) where NPROC is the number of process used for parallel computing. Note that your system may require other commands than mpirun or more arguments. You can find example batch scripts in Utility/Cluster_files . Scribed IO Shortly after v5.9.0 we have implemented a new I/O mode called scribed I/O. Under scribed IO mode, the outputs are combined during the model simulation by dedicated \"scribed\" cores. Efficient asynchronous message passing is done inside the code for I/O that minimizes latency. Some details for using scribed IO mode are following: The user needs to specify at runtime how many 'scribe' cores they want to use. The # of scribes= # of 3D outputs (vectors counted as 2) plus 1 (the one that is used for all 2D variables). Each 3D output has its own netcdf output (e.g. salinity_*.nc ) and all 2D outputs share same output out2d_*.nc . Each vector output is split into X,Y components, e.g. horizontalVel[X,Y]_*.nc . The outputs out2d_*.nc and zCoordinates_*.nc are needed for VisIT. Users must specify # of scribes on cmd line as mpirun -np NPROC ./pschism <nscribe> . The specified number can be >= min required based on param.nml and explained above. If not you'll get an error. If you specify more than needed, you waste some cores but otherwise fine.","title":"Running the model"},{"location":"getting-started/test_suite.html","text":"Overview \u00b6 SCHISM provides benchmark tests for verifying your installation or new code development. Due to the large file size of these tests, they are distributed via svn. You\u2019ll need svn v1.8 or above ( svn manual ). Svn clients on linux/unix/windows/Mac should all work. The command to checkout the tests is: svn co https://columbia.vims.edu/schism/schism_verification_tests (You can also simply use wget to download) Note that the test suite is kept up to date with the latest master branch on the SCHISM's git repo . As a result, there may be some differences (some parameters may have been removed or added) between the param.nml you are using and the one from the verification tests (master branch). It's important to use a correct param.nml corresponding to the version of SCHISM you are using. A sample param.nml is always provided under your SCHISM source code directory: $your_schism_dir/sample_inputs/param.nml The latest master version for this input can also be viewed on the Github page . Useful info can be found in the source code bundle src/Readme.beta_notes (including change of format for input files and bug fixes) if you wish to hop among different versions. To ease the burden of beginners who wish to verify their own build of different SCHISM versions, we have also included a subdirectory Tags in the test suite, in which users can test all major tag releases with a simple test case (Quarter Annulus). SCHISM Modules required in the test suite \u00b6 Depending on which verification test you are conducting, you may need to enable certain modules when compiling SCHISM. Here is a reference: Test Module needed Test_Btrack_Cone None Test_Btrack_Gausshill None Test_Btrack_Gausshill_CPU None Test_CORIE None Test_CORIE_LSC2 None Test_COSINE_SFBay None Test_Chezy None Test_Convergence_Grid1 None Test_Convergence_Grid2 None Test_Convergence_Grid3 None Test_Convergence_Grid4 None Test_Convergence_Grid5 None Test_ECO_Toy ECO Test_FABM_COSINE_SFBay FABM Test_Flat_Adjust None Test_GEN_MassConsv GEN Test_GEN_MassConsv2 GEN Test_Geostrophic None Test_HeatConsv_TVD None Test_HeatConsv_Upwind None Test_HeatPool None Test_HydraulicStruct None Test_ICM_ChesBay ICM Test_ICM_UB ICM Test_Inun_CircularIsland_CaseB None Test_Inun_CircularIsland_CaseB_3D None Test_Inun_CircularIsland_CaseB_CPU None Test_Inun_NWaves_2D None Test_Inun_NWaves_3D None Test_MassSource None Test_Nonhydro_Flat_Adjust Nonhydro (not active) Test_Nonhydro_StandingWaves Nonhydro (not active) Test_ParaBowl None Test_QuarterAnnulus None Test_QuarterAnnulus_hvis None Test_SED_Trench_Migration SED Test_SED_meander_2 SED Test_Sed2d_Trench_Migration SED Test_TIMOR_rouse None Test_VolConsv_2D_1 None Test_VolConsv_2D_2 None Test_VolConsv_3D_1 None Test_VolConsv_3D_2 None Test_WWM_Analytical WWM Test_WWM_Duck WWM Test_WWM_L31_2A WWM Test_WWM_VF_adiabatic_case WWM Test_WWM_limon_NODIF WWM Test_Williamson5 None","title":"Test suite"},{"location":"getting-started/test_suite.html#overview","text":"SCHISM provides benchmark tests for verifying your installation or new code development. Due to the large file size of these tests, they are distributed via svn. You\u2019ll need svn v1.8 or above ( svn manual ). Svn clients on linux/unix/windows/Mac should all work. The command to checkout the tests is: svn co https://columbia.vims.edu/schism/schism_verification_tests (You can also simply use wget to download) Note that the test suite is kept up to date with the latest master branch on the SCHISM's git repo . As a result, there may be some differences (some parameters may have been removed or added) between the param.nml you are using and the one from the verification tests (master branch). It's important to use a correct param.nml corresponding to the version of SCHISM you are using. A sample param.nml is always provided under your SCHISM source code directory: $your_schism_dir/sample_inputs/param.nml The latest master version for this input can also be viewed on the Github page . Useful info can be found in the source code bundle src/Readme.beta_notes (including change of format for input files and bug fixes) if you wish to hop among different versions. To ease the burden of beginners who wish to verify their own build of different SCHISM versions, we have also included a subdirectory Tags in the test suite, in which users can test all major tag releases with a simple test case (Quarter Annulus).","title":"Overview"},{"location":"getting-started/test_suite.html#schism-modules-required-in-the-test-suite","text":"Depending on which verification test you are conducting, you may need to enable certain modules when compiling SCHISM. Here is a reference: Test Module needed Test_Btrack_Cone None Test_Btrack_Gausshill None Test_Btrack_Gausshill_CPU None Test_CORIE None Test_CORIE_LSC2 None Test_COSINE_SFBay None Test_Chezy None Test_Convergence_Grid1 None Test_Convergence_Grid2 None Test_Convergence_Grid3 None Test_Convergence_Grid4 None Test_Convergence_Grid5 None Test_ECO_Toy ECO Test_FABM_COSINE_SFBay FABM Test_Flat_Adjust None Test_GEN_MassConsv GEN Test_GEN_MassConsv2 GEN Test_Geostrophic None Test_HeatConsv_TVD None Test_HeatConsv_Upwind None Test_HeatPool None Test_HydraulicStruct None Test_ICM_ChesBay ICM Test_ICM_UB ICM Test_Inun_CircularIsland_CaseB None Test_Inun_CircularIsland_CaseB_3D None Test_Inun_CircularIsland_CaseB_CPU None Test_Inun_NWaves_2D None Test_Inun_NWaves_3D None Test_MassSource None Test_Nonhydro_Flat_Adjust Nonhydro (not active) Test_Nonhydro_StandingWaves Nonhydro (not active) Test_ParaBowl None Test_QuarterAnnulus None Test_QuarterAnnulus_hvis None Test_SED_Trench_Migration SED Test_SED_meander_2 SED Test_Sed2d_Trench_Migration SED Test_TIMOR_rouse None Test_VolConsv_2D_1 None Test_VolConsv_2D_2 None Test_VolConsv_3D_1 None Test_VolConsv_3D_2 None Test_WWM_Analytical WWM Test_WWM_Duck WWM Test_WWM_L31_2A WWM Test_WWM_VF_adiabatic_case WWM Test_WWM_limon_NODIF WWM Test_Williamson5 None","title":"SCHISM Modules required in the test suite"},{"location":"getting-started/typical-workflow.html","text":"Typical workflow with SCHISM modeling. Mesh generation tips \u00b6 Generate meshes in map projection, not lon/lat; this gives flexibility of setting element size (although newer SMS versions can now handle distance in lon/lat directly). Distortion due to projection can be rectified later by projecting back to lon/lat; Make sure major channels are resolved with at least 1 row of \u2018always wet\u2019 elements \u2013 no blockage of major channel flow Always keep the map file and DEM sources and be willing to edit the grid, as often the model results (and sometimes performance) depend on the mesh Being an implicit model with ELM treatment of momentum advection, SCHISM has an operating range for the time step. For field applications, the range is 100-400 sec for barotropic cases, 100-200 sec for baroclinic cases. If you have to reduce the time step, make sure you recheck the inverse CFL criterion again. First estimate the smallest \\(\\Delta t\\) you\u2019d anticipate (e.g., 100s for field applications), and then estimate the coarsest \\(\\Delta t\\) at sample depths to make sure \\(CFL>0.4\\) (cf. Table 5.1). Resolving features is much easier with SCHISM \u2013 be game! Bathymetry smoothing is not necessary. Make sure open boundaries do not become completely dry during simulation [3D simulations with transport] Implicit \\(TVD^2\\) transport is very efficient, but horizontal transport is still explicit (and is the main bottleneck). Therefore beware of grid resolution in critical regions to avoid excessive sub-cycling; use upwind in areas of no stratification. Another way to speed up is to use hybrid ELM and FV by setting ielm_transport=1 . Check the following things immediately after a mesh is generated (via ACE/xmgredit5 or scripts) Minimum area: make sure there are no negative elements (under xmgredit5->Status). \\(CFL>0.4\\) (at least in \u2018wet\u2019 areas). Note that you need to do this check in map projection (meters), not in lon/lat! Maximum skewness for triangle: use a generous threshold of 17, mainly to find excessive \"collapsed\" elements that originate from the SMS map issues (and fix them in SMS). As a general rule of thumb, SCHISM can comfortably handle elements >= \\(1m^2\\) ( \\(10^{-10}\\) in lon/lat), and skewness<=60. Use ACE/xmgredit5 or SMS to check these. Most of those extreme elements are due to SMS map issues so you should fix them there. Fix bad quads: fix all bad-quality quads using fix_bad_quads.f90 as the last step; use 0.5 (ratio of min and max internal angles) as threshold. 2D model: pre-processing \u00b6 Check additional grid issues with a 2D barotropic model with ipre=1 , ibc=1 , ibtp=0 You can cheat without any open boundary segments during this step Remember to mkdir outputs in the run directory Iterate with mesh generation step to fix any mesh issues. 2D model: calibration \u00b6 Start from simple and then build up complexity. Simplest may be a tidal run with a constant Manning\u2019s \\(n\\) . Remember most outputs are on a per-core basis if you use OLDIO and need to be combined using the utility scripts; e.g., for global outputs (schout*.nc), use combine_output11.f90 to get global netcdf outputs that can be visualized by VisIT or other tools; for hotstart, use combine_hotstart7.f90 . If you use new scribe I/O, you don't need to combine global outputs, but still need to combine hotstart outputs. Examine surface velocity in animation mode to find potential issues (e.g. blockage of channels) Negative river flow values for inflow Check all inputs: \u2018junk in, junk out\u2019. There are several pre-processing scripts for this purpose. Xmgredit5 or SMS is very useful also. 3D model: calibration \u00b6 The model may need velocity boundary condition at ocean boundary. The easiest approach is to use FES2014 or TPXO tide package to generate tidal velocity, and use a global ocean model (e.g. HYCOM) to get sub-tidal velocity. Then use type \u20185\u2019 in bctides.in . Avoid large bottom friction in shallow areas in 3D regions Examine surface velocity in animation mode to find potential issues Control the balance between numerical diffusion and dispersion ( indvel , ihorcon ) Transport solver efficiency may require some experience. \\(LSC^2\\) grid requires some learning/experience, but is a very powerful tool (resembling unstructured grid in the vertical) See Case studies for commonly encountered issues in 3D setup. Note Another good resource for beginners is a mini live manual by Ms. Christelle Auguste (U. of Tasmania). There is a PDF on there.","title":"Typical workflow (a cheat sheet)"},{"location":"getting-started/typical-workflow.html#mesh-generation-tips","text":"Generate meshes in map projection, not lon/lat; this gives flexibility of setting element size (although newer SMS versions can now handle distance in lon/lat directly). Distortion due to projection can be rectified later by projecting back to lon/lat; Make sure major channels are resolved with at least 1 row of \u2018always wet\u2019 elements \u2013 no blockage of major channel flow Always keep the map file and DEM sources and be willing to edit the grid, as often the model results (and sometimes performance) depend on the mesh Being an implicit model with ELM treatment of momentum advection, SCHISM has an operating range for the time step. For field applications, the range is 100-400 sec for barotropic cases, 100-200 sec for baroclinic cases. If you have to reduce the time step, make sure you recheck the inverse CFL criterion again. First estimate the smallest \\(\\Delta t\\) you\u2019d anticipate (e.g., 100s for field applications), and then estimate the coarsest \\(\\Delta t\\) at sample depths to make sure \\(CFL>0.4\\) (cf. Table 5.1). Resolving features is much easier with SCHISM \u2013 be game! Bathymetry smoothing is not necessary. Make sure open boundaries do not become completely dry during simulation [3D simulations with transport] Implicit \\(TVD^2\\) transport is very efficient, but horizontal transport is still explicit (and is the main bottleneck). Therefore beware of grid resolution in critical regions to avoid excessive sub-cycling; use upwind in areas of no stratification. Another way to speed up is to use hybrid ELM and FV by setting ielm_transport=1 . Check the following things immediately after a mesh is generated (via ACE/xmgredit5 or scripts) Minimum area: make sure there are no negative elements (under xmgredit5->Status). \\(CFL>0.4\\) (at least in \u2018wet\u2019 areas). Note that you need to do this check in map projection (meters), not in lon/lat! Maximum skewness for triangle: use a generous threshold of 17, mainly to find excessive \"collapsed\" elements that originate from the SMS map issues (and fix them in SMS). As a general rule of thumb, SCHISM can comfortably handle elements >= \\(1m^2\\) ( \\(10^{-10}\\) in lon/lat), and skewness<=60. Use ACE/xmgredit5 or SMS to check these. Most of those extreme elements are due to SMS map issues so you should fix them there. Fix bad quads: fix all bad-quality quads using fix_bad_quads.f90 as the last step; use 0.5 (ratio of min and max internal angles) as threshold.","title":"Mesh generation tips"},{"location":"getting-started/typical-workflow.html#2d-model-pre-processing","text":"Check additional grid issues with a 2D barotropic model with ipre=1 , ibc=1 , ibtp=0 You can cheat without any open boundary segments during this step Remember to mkdir outputs in the run directory Iterate with mesh generation step to fix any mesh issues.","title":"2D model: pre-processing"},{"location":"getting-started/typical-workflow.html#2d-model-calibration","text":"Start from simple and then build up complexity. Simplest may be a tidal run with a constant Manning\u2019s \\(n\\) . Remember most outputs are on a per-core basis if you use OLDIO and need to be combined using the utility scripts; e.g., for global outputs (schout*.nc), use combine_output11.f90 to get global netcdf outputs that can be visualized by VisIT or other tools; for hotstart, use combine_hotstart7.f90 . If you use new scribe I/O, you don't need to combine global outputs, but still need to combine hotstart outputs. Examine surface velocity in animation mode to find potential issues (e.g. blockage of channels) Negative river flow values for inflow Check all inputs: \u2018junk in, junk out\u2019. There are several pre-processing scripts for this purpose. Xmgredit5 or SMS is very useful also.","title":"2D model: calibration"},{"location":"getting-started/typical-workflow.html#3d-model-calibration","text":"The model may need velocity boundary condition at ocean boundary. The easiest approach is to use FES2014 or TPXO tide package to generate tidal velocity, and use a global ocean model (e.g. HYCOM) to get sub-tidal velocity. Then use type \u20185\u2019 in bctides.in . Avoid large bottom friction in shallow areas in 3D regions Examine surface velocity in animation mode to find potential issues Control the balance between numerical diffusion and dispersion ( indvel , ihorcon ) Transport solver efficiency may require some experience. \\(LSC^2\\) grid requires some learning/experience, but is a very powerful tool (resembling unstructured grid in the vertical) See Case studies for commonly encountered issues in 3D setup. Note Another good resource for beginners is a mini live manual by Ms. Christelle Auguste (U. of Tasmania). There is a PDF on there.","title":"3D model: calibration"},{"location":"getting-started/visualization.html","text":"Visualization with Matlab \u00b6 The directory Utility/Vis_Matlab/ has matlab scripts that can visualize outputs along a horizontal slab (at a fixed z level or at a sigma level) or vertical transects. In particular, SCHISM_SLAB2.m and SCHISM_TRANSECT2.m for for the new scribed outputs, while SCHISM_SLAB.m and SCHISM_TRANSECT.m are for the old outputs (schout*.nc). Visualization with pylib \u00b6 pylib provides schismview to visualize outputs (scribed outputs, OLDIO not supported yet). schismview will collect all the available variables from your outputs. For each variable, you can do 1). contour plot, 2). animation, 3). extract time series, and 4) query, etc. This is a lightweight app, and please report bug to SCHISM maillist or wzhengui@gmail.com. Installation of pylib \u00b6 By running the following code, you can locate the executable of schismview python -c \"from pylib import *; print(mylib.__file__[:-16]+'Scripts/schismview')\" How to use schismview \u00b6 To lauch schismview , you can run the executable either under your run directory, or pass the run directory as a argument to the executable, which will give you an schismview window below. variable : All availalbe SCHISM output variables are collected, and you can choose the variable you want to view from the list window. figure : list of figures. You can have multiple figures for different variables. You can close it if you want. Later on, you can retrieve previous figures from the list. If you want to add a new figure, choose add. layer : For 3D variable, you can specify which layer you want to view. For 2D variable, this option is not needed. grid or bnd : If clicked, schism grid/boundary will plotted out along with the contour plot. If you only want to view the grid/boundary, choose none from the variable list. ctr : By default, schismview will use tripcolor to plot contours, which is element-based. If ctr is clicked, schismview will use tricontourf to plot, which can be faster for very large grid. time : There are three available time options (calendar time, SCHISM stack number, or Julian date). You can set the Start and End dates for viewing variables in the textbox. This may be needed for animation if you only want to view for a specific period of time. limit : It sets the lower and upper limits of contours. The values beyond are extended. vector : You can choose vector you want to view from the list. vector shown will be limitted to the current domain specified by xlim and ylim . curve : By right double click , you can add location points for extractng times for the active variable. middle double click will remove the points. Then, click curve , schismview will extract time series in background and the button will display wait . Once wait becomes curve again, clicking on it will show the time series. Note, extracting time series can be very slow for 3D variables depending on how the netcdf outputs are stored (chuncking the files can help, but it is a separate topic beyond schismview ). It is better to specify short time range. query : You can query the value of variable. By clicking query (becomes sunken once chosen), you can use middle single click to query the value. By clicking query again, it will exit query mode. xlim / ylim : Sspecify the X/Y axis range. animation |< : go to start time < : go to previous time play : play animation for the current variable. The button will display stop , and click stop will stop the animation. Note doulbe right click will have the same effect of play buttion > : go to next time >| : go to end time skip : specify the animation interval draw : draw plot or refresh the plot. option : Advaned features command window : type commands to interact with the plot, which can be used to generate desired high-quality figures. save animation show node/element number Visualization with VisIt \u00b6 The most comprehensive way to visualize SCHISM nc4 outputs is via VisIt. Shortly after v5.9.0, we have successfully implemented a new mode of efficient I/O using dedicated 'scribes'. At runtime, the user needs to specify number of scribe cores (= # of 3D outputs variables (vectors counted as 2) plus 1), and the code, compiled without OLDIO , will output combined netcdf outputs for each 3D variable and also all 2D variables in out2d*.nc . Sample 3D outputs are: salinity_*.nc , horizontalVelX_*.nc etc - note that vectors variable names end with X,Y . You can find sample outputs here . Sample outputs using OLDIO (schout*.nc) can be found here . You can download newer versions of VisIt plugins c/o Jon Shu, DWR by following these steps: On Windows 7 or 10 First download VisIt from LLNL site and install. Note the location, which will be in your Windows profile directory if you install for the current user or in Program Files if you install for all users. Note the location. Make sure MS visualc++ 2012 x64 is installed. If not, google it and install and restart (this is required for using multi-core VisIt). If you are using VisIt 3.3.1, you need MS visualc++ 2013 x64 also. Download pre-built plug-in, developed at California Dept of Water Resource For VisIt v2.13.3 For VisIt v3.1.4 For VisIt v3.3.1 You need to put the plugin dlls in: %USERPROFILE%\\Documents\\VisIt\\databases (create new folders if necessary), except netcdf_c++.dll . The NetCDF DLL needs to be copied to the VisIt installation directory, which may be %USERPROFILE%\\LLNL\\VisIt 3.3.1 if you installed for yourself or the system install directory C:Program Files\\LLNL\\VisIt3.3.1. if you installed for all users. After these steps, you should be able to read in SCHISM outputs in ViSIt; look for SCHISM , gr3 format from the dropdown list. To load in vectors, select only the X file. On Linux Systems Newer versions can be found at the master branch of github . Note Note that the new plugins also work with the old I/O (combined schout*.nc ) or even the older binary outputs. To visualize any variables under new I/O with VisIt, you'll always need corresponding out2d*.nc ; additionally for any 3D variables, VisIt also needs corresponding zCoordinates*.nc .","title":"Visualization"},{"location":"getting-started/visualization.html#visualization-with-matlab","text":"The directory Utility/Vis_Matlab/ has matlab scripts that can visualize outputs along a horizontal slab (at a fixed z level or at a sigma level) or vertical transects. In particular, SCHISM_SLAB2.m and SCHISM_TRANSECT2.m for for the new scribed outputs, while SCHISM_SLAB.m and SCHISM_TRANSECT.m are for the old outputs (schout*.nc).","title":"Visualization with Matlab"},{"location":"getting-started/visualization.html#visualization-with-pylib","text":"pylib provides schismview to visualize outputs (scribed outputs, OLDIO not supported yet). schismview will collect all the available variables from your outputs. For each variable, you can do 1). contour plot, 2). animation, 3). extract time series, and 4) query, etc. This is a lightweight app, and please report bug to SCHISM maillist or wzhengui@gmail.com.","title":"Visualization with pylib"},{"location":"getting-started/visualization.html#installation-of-pylib","text":"By running the following code, you can locate the executable of schismview python -c \"from pylib import *; print(mylib.__file__[:-16]+'Scripts/schismview')\"","title":"Installation of pylib"},{"location":"getting-started/visualization.html#how-to-use-schismview","text":"To lauch schismview , you can run the executable either under your run directory, or pass the run directory as a argument to the executable, which will give you an schismview window below. variable : All availalbe SCHISM output variables are collected, and you can choose the variable you want to view from the list window. figure : list of figures. You can have multiple figures for different variables. You can close it if you want. Later on, you can retrieve previous figures from the list. If you want to add a new figure, choose add. layer : For 3D variable, you can specify which layer you want to view. For 2D variable, this option is not needed. grid or bnd : If clicked, schism grid/boundary will plotted out along with the contour plot. If you only want to view the grid/boundary, choose none from the variable list. ctr : By default, schismview will use tripcolor to plot contours, which is element-based. If ctr is clicked, schismview will use tricontourf to plot, which can be faster for very large grid. time : There are three available time options (calendar time, SCHISM stack number, or Julian date). You can set the Start and End dates for viewing variables in the textbox. This may be needed for animation if you only want to view for a specific period of time. limit : It sets the lower and upper limits of contours. The values beyond are extended. vector : You can choose vector you want to view from the list. vector shown will be limitted to the current domain specified by xlim and ylim . curve : By right double click , you can add location points for extractng times for the active variable. middle double click will remove the points. Then, click curve , schismview will extract time series in background and the button will display wait . Once wait becomes curve again, clicking on it will show the time series. Note, extracting time series can be very slow for 3D variables depending on how the netcdf outputs are stored (chuncking the files can help, but it is a separate topic beyond schismview ). It is better to specify short time range. query : You can query the value of variable. By clicking query (becomes sunken once chosen), you can use middle single click to query the value. By clicking query again, it will exit query mode. xlim / ylim : Sspecify the X/Y axis range. animation |< : go to start time < : go to previous time play : play animation for the current variable. The button will display stop , and click stop will stop the animation. Note doulbe right click will have the same effect of play buttion > : go to next time >| : go to end time skip : specify the animation interval draw : draw plot or refresh the plot. option : Advaned features command window : type commands to interact with the plot, which can be used to generate desired high-quality figures. save animation show node/element number","title":"How to use schismview"},{"location":"getting-started/visualization.html#visualization-with-visit","text":"The most comprehensive way to visualize SCHISM nc4 outputs is via VisIt. Shortly after v5.9.0, we have successfully implemented a new mode of efficient I/O using dedicated 'scribes'. At runtime, the user needs to specify number of scribe cores (= # of 3D outputs variables (vectors counted as 2) plus 1), and the code, compiled without OLDIO , will output combined netcdf outputs for each 3D variable and also all 2D variables in out2d*.nc . Sample 3D outputs are: salinity_*.nc , horizontalVelX_*.nc etc - note that vectors variable names end with X,Y . You can find sample outputs here . Sample outputs using OLDIO (schout*.nc) can be found here . You can download newer versions of VisIt plugins c/o Jon Shu, DWR by following these steps: On Windows 7 or 10 First download VisIt from LLNL site and install. Note the location, which will be in your Windows profile directory if you install for the current user or in Program Files if you install for all users. Note the location. Make sure MS visualc++ 2012 x64 is installed. If not, google it and install and restart (this is required for using multi-core VisIt). If you are using VisIt 3.3.1, you need MS visualc++ 2013 x64 also. Download pre-built plug-in, developed at California Dept of Water Resource For VisIt v2.13.3 For VisIt v3.1.4 For VisIt v3.3.1 You need to put the plugin dlls in: %USERPROFILE%\\Documents\\VisIt\\databases (create new folders if necessary), except netcdf_c++.dll . The NetCDF DLL needs to be copied to the VisIt installation directory, which may be %USERPROFILE%\\LLNL\\VisIt 3.3.1 if you installed for yourself or the system install directory C:Program Files\\LLNL\\VisIt3.3.1. if you installed for all users. After these steps, you should be able to read in SCHISM outputs in ViSIt; look for SCHISM , gr3 format from the dropdown list. To load in vectors, select only the X file. On Linux Systems Newer versions can be found at the master branch of github . Note Note that the new plugins also work with the old I/O (combined schout*.nc ) or even the older binary outputs. To visualize any variables under new I/O with VisIt, you'll always need corresponding out2d*.nc ; additionally for any 3D variables, VisIt also needs corresponding zCoordinates*.nc .","title":"Visualization with VisIt"},{"location":"getting-started/pre-processing-with-pylib/installation.html","text":"method 1: user-mode pip install pylibs-ocean method 2: developer mode (recommended) git clone https://github.com/wzhengui/pylibs.git cd pylibs pip install -e .","title":"Installation"},{"location":"getting-started/pre-processing-with-pylib/overview.html","text":"pylib provides a matlab-style platform for python usage and an independent python-based SCHISM modeling workflow please refer to https://github.com/wzhengui/pylibs for more information. some of pylib basic functions database usage time manipulation, geometry handling ( inside_polygon, near_pts, compute_contour ) data analysis: low/band-pass filters, running smooth, FFT, statistics, least-square-fit, EOF, harmonic analysis, etc . handling different file formats: SCHISM inputs/outputs, ASCII files, netcdf, shapefile, Excel, DEM files, projections, etc. some of SCHISM related functions geometry information: node, element, side, etc. hgrid: plot, interplation, boundary, read/save, grid-preprocess (grd2sms, sms2grd, quads check/split, skew-element check, projection) vgrid: compute_zcor, etc. point/region files post-process: extract time series, profiles, slabs, fluxes, etc. visualization of SCHISM inputs/outputs","title":"Overview"},{"location":"getting-started/pre-processing-with-pylib/schismcheck.html","text":"one can find the location of schismcheck by executing the following code. Then, running it in your schism run directory python -c \"from pylib import *; print(mylib.__file__[:-16]+'Scripts/schismcheck')\" schismcheck is still under development/testing mode (please report bugs either on SCHISM maillist or to wzhengui@gmail.com), but it is now able to view most of SCHISM inputs in different ways. It is a good way of sanity check for your model inputs. So far, 5 types of inputs are supported (see figures below). dimension operations the following dimension opertations are provided for the data. schismcheck can only plot 1D or 2D data, which will plot as time series, 2D contour plot, or scatter plot. all : extract all data along dimension mean : compute mean value along dimension min : compute minimum value along dimension max : compute maximum value along dimension sum : compute sum of value along dimension number (0-n) : extract data slice along dimension note : all operation will add an one dimension to your data to be plotted. *.gr3, hgrid.ll, *.ic, *.prop : Plot value as contour. SCHISM grid and boundary can be superposed. *_nu.nc, *_th.nc : After data (1D or 2D) is extracted, it will be plotted as time series or 2D contour. For nudge 1D data, it can also be plotted on schism grid. hotstart.nc : data will be plotted as time series or 2D contour; For 1D data with dimension=node or elem, it will be plotted as contours on schism grid. source.nc or source_input (source_sink.in, vsource, msource, vsink) : data will be plotted as time series or 2D contour; For 1D data with dimension=source_number, it can be plotted as scatter points on schsim grid. *.th : data will be plotted as time series (1D data) or 2D contour (2D data)","title":"schismCheck (input visualization)"},{"location":"getting-started/pre-processing-with-pyschism/atmos.html","text":"Atmospheric forcing \u00b6 The sflux/ directory is required if nws=2 in param.nml . There are four types of files needed: sflux_input.txt ( required ): a namelist file sflux_air_1.[XXXX].nc ( required ): NetCDF files that have time (in days), wind speed at 10m above MSL (u, v), air temperatue and spedific humidity at 2m above MSL, sea level pressure; sflux_prc_1.[XXXX].nc ( needed if isconsv=1): NetCDF files that have time and precipitation rate; sflux_rad_1.[XXXX].nc ( needed if ihconsv=1): NetCDF files that have time, downward longwave and shortwave radiation fluxes. PySCHISM supports three types of atmpsheric datasets. Notes: startdate should be one day earlier than the actual run startdate, because there is no data at t00z. Acoordingly, add two more extra days for rnday in the following scripts. ECMWF ERA5 \u00b6 ERA5 provides hourly estimates of a large number of atmoshperic, land and oceanic climate variables. The data cover the Earth on a 30km grid and resolve the atmoshpere using 137 levels from the surface up to a height of 80km. The dataset covers from 1950 to present. PySCHISM downloads ERA5 data through CDS API service. To do so, you need to install CDS API package. Here is the instruction about how to install the package. The python script to generate sflux file from ERA5 is as follows: from datetime import datetime import pathlib from pyschism.mesh.hgrid import Hgrid from pyschism.forcing.nws.nws2.era5 import ERA5 if __name__ == '__main__' startdate = datetime ( 2022 , 4 , 1 ) rnday = 10 hgrid = Hgrid . open ( './hgrid.gr3' , crs = 'EPSG:4326' ) bbox = hgrid . get_bbox ( 'EPSG:4326' , output_type = 'bbox' ) outdir = pathlib . Path ( './' ) er = ERA5 () er . write ( outdir = outdir , start_date = startdate , rnday = rnday , air = True , rad = True , prc = True , bbox = bbox , output_interval = interval , overwrite = True ) GFS \u00b6 The Global Forecast System (GFS) is weather forecast model produced by the National Centers for Environmental Prediction (NCEP). PySCHISM uses data hosted on AWS S3 bucket. The python script to generate sflux from GFS is as follows: from datetime import datetime from pyschism.mesh.hgrid import Hgrid from pyschism.forcing.nws.nws2.gfs2 import GFS if __name__ == '__main__' : startdate = datetime ( 2022 , 3 , 31 ) rnday = 10 record = 1 hgrid = Hgrid . open ( './hgrid.gr3' , crs = 'epsg:4326' ) pscr = '/sciclone/pscr/lcui01/GFS/' gfs = GFS ( start_date = startdate , rnday = rnday , pscr = pscr , record = record , bbox = hgrid . bbox ) Parameter startdate should be one day earlier than the actual startdate in the param.nml becasue GFS have nodata at t00, pscr is the pre-generated directory to save dowloaded raw data (grib2), record is to specify how many days in each file. For hindcast, recommend record=1 . For forecast, the maximum is 5, because GFS has 5-day forecast. HRRR \u00b6 The HRRR is a NOAA real-time 3-km resolution, hourly updated, cloud-resolving, convection-allowing atmospheric model. The AWS archived data starts from August 2014 to present. The python script to generate sflux from HRRR is as follows: from datetime import datetime from pyschism.mesh.hgrid import Hgrid from pyschism.forcing.nws.nws2.hrrr3 import HRRR if __name__ == '__main__' : startdate = datetime ( 2022 , 3 , 31 ) rnday = 10 record = 1 hgrid = Hgrid . open ( '../../../data/hgrid.gr3' , crs = 'epsg:4326' ) pscr = '/sciclone/pscr/lcui01/HRRR/' hrrr = HRRR ( start_date = startdate , rnday = rnday , pscr = pscr , record = record , bbox = hgrid . bbox ) Parameter startdate , pscr , and record are defined the same as GFS', except for forecast, the maximum of record for HRRR is 2, because HRRR only has 2-day forecast.","title":"Atmospheric forcing"},{"location":"getting-started/pre-processing-with-pyschism/atmos.html#atmospheric-forcing","text":"The sflux/ directory is required if nws=2 in param.nml . There are four types of files needed: sflux_input.txt ( required ): a namelist file sflux_air_1.[XXXX].nc ( required ): NetCDF files that have time (in days), wind speed at 10m above MSL (u, v), air temperatue and spedific humidity at 2m above MSL, sea level pressure; sflux_prc_1.[XXXX].nc ( needed if isconsv=1): NetCDF files that have time and precipitation rate; sflux_rad_1.[XXXX].nc ( needed if ihconsv=1): NetCDF files that have time, downward longwave and shortwave radiation fluxes. PySCHISM supports three types of atmpsheric datasets. Notes: startdate should be one day earlier than the actual run startdate, because there is no data at t00z. Acoordingly, add two more extra days for rnday in the following scripts.","title":"Atmospheric forcing"},{"location":"getting-started/pre-processing-with-pyschism/atmos.html#ecmwf-era5","text":"ERA5 provides hourly estimates of a large number of atmoshperic, land and oceanic climate variables. The data cover the Earth on a 30km grid and resolve the atmoshpere using 137 levels from the surface up to a height of 80km. The dataset covers from 1950 to present. PySCHISM downloads ERA5 data through CDS API service. To do so, you need to install CDS API package. Here is the instruction about how to install the package. The python script to generate sflux file from ERA5 is as follows: from datetime import datetime import pathlib from pyschism.mesh.hgrid import Hgrid from pyschism.forcing.nws.nws2.era5 import ERA5 if __name__ == '__main__' startdate = datetime ( 2022 , 4 , 1 ) rnday = 10 hgrid = Hgrid . open ( './hgrid.gr3' , crs = 'EPSG:4326' ) bbox = hgrid . get_bbox ( 'EPSG:4326' , output_type = 'bbox' ) outdir = pathlib . Path ( './' ) er = ERA5 () er . write ( outdir = outdir , start_date = startdate , rnday = rnday , air = True , rad = True , prc = True , bbox = bbox , output_interval = interval , overwrite = True )","title":"ECMWF ERA5"},{"location":"getting-started/pre-processing-with-pyschism/atmos.html#gfs","text":"The Global Forecast System (GFS) is weather forecast model produced by the National Centers for Environmental Prediction (NCEP). PySCHISM uses data hosted on AWS S3 bucket. The python script to generate sflux from GFS is as follows: from datetime import datetime from pyschism.mesh.hgrid import Hgrid from pyschism.forcing.nws.nws2.gfs2 import GFS if __name__ == '__main__' : startdate = datetime ( 2022 , 3 , 31 ) rnday = 10 record = 1 hgrid = Hgrid . open ( './hgrid.gr3' , crs = 'epsg:4326' ) pscr = '/sciclone/pscr/lcui01/GFS/' gfs = GFS ( start_date = startdate , rnday = rnday , pscr = pscr , record = record , bbox = hgrid . bbox ) Parameter startdate should be one day earlier than the actual startdate in the param.nml becasue GFS have nodata at t00, pscr is the pre-generated directory to save dowloaded raw data (grib2), record is to specify how many days in each file. For hindcast, recommend record=1 . For forecast, the maximum is 5, because GFS has 5-day forecast.","title":"GFS"},{"location":"getting-started/pre-processing-with-pyschism/atmos.html#hrrr","text":"The HRRR is a NOAA real-time 3-km resolution, hourly updated, cloud-resolving, convection-allowing atmospheric model. The AWS archived data starts from August 2014 to present. The python script to generate sflux from HRRR is as follows: from datetime import datetime from pyschism.mesh.hgrid import Hgrid from pyschism.forcing.nws.nws2.hrrr3 import HRRR if __name__ == '__main__' : startdate = datetime ( 2022 , 3 , 31 ) rnday = 10 record = 1 hgrid = Hgrid . open ( '../../../data/hgrid.gr3' , crs = 'epsg:4326' ) pscr = '/sciclone/pscr/lcui01/HRRR/' hrrr = HRRR ( start_date = startdate , rnday = rnday , pscr = pscr , record = record , bbox = hgrid . bbox ) Parameter startdate , pscr , and record are defined the same as GFS', except for forecast, the maximum of record for HRRR is 2, because HRRR only has 2-day forecast.","title":"HRRR"},{"location":"getting-started/pre-processing-with-pyschism/bctides.html","text":"Bctides \u00b6 Please refer to this page for detailed horizontal B.C. and nudging options supported by SCHISM. PySCHISM supports both TPXO and FES2014 tidal database. Please download the data (you may need to register) and save it as: For TPXO : ~/.local/share/tpxo/h_tpxo9.v1.nc ~/.local/share/tpxo/u_tpxo9.v1.nc For FES2014 : ~/.local/share/fes2014/eastward_velocity/ ~/.local/share/fes2014/northward_velocity/ ~/.local/share/fes2014/ocean_tide_extrapolated/ Bctides class : arguments : hgrid : required , hgrid . ll ( lon / lat ) flags : requried , bctypes for each boundary [[ iettype , ifltype , itetype , isatype ], [ ... ], [ ... ], ... ] constituents : optional , default is \"major\" , which is eight major tidal constituents dabase : optional , default is \"tpxo\" add_earth_tidal : optional , default is True cutoff_depth : optional , default is 50.0 ethconst : optional , needed when using constant elevation along the boundary ( iettype = 2 ), which is given as [ v1 , v2 , v3 , ... ] vthconst : optional , needed when using constant discharge ( ifltype = 2 ) tthconst : optional , needed when using constant temperatur ( itetype = 2 ) sthconst : optional , needed when using constant temperature ( isatype = 2 ) tobc : optional , nudging factor , needed when itetype is not 0 , [ v1 , v2 , v3 , ... ] sobc : optional , nudging factor for salinity , needed when isatype is not 0 , [ v1 , v2 , v3 , ... ] relax : optional , needed when ifttype =- 4 , [ rel1 , rel2 ] Below shows an example script to generate bctides.in for hgrid with three open boundaries (2 ocean + 1 river). Bctypes for ocean boundaries are [5, 5, 4, 4], and for river is [0, 1, 1, 2]: from datetime import datetime import numpy as np from pyschism.mesh import Hgrid from pyschism.forcing.bctides import Bctides if __name__ == '__main__' : start_date = datetime ( 2017 , 12 , 1 ) rnday = 396 bctypes = [[ 5 , 5 , 4 , 4 ], [ 5 , 5 , 4 , 4 ], [ 0 , 1 , 1 , 2 ]] constituents = 'major' database = 'tpxo' earth_tidal_potential = True sthconst = [ np . nan , np . nan , 0 ] tobc = [ 0.5 , 0.5 , 1 ] sobc = [ 0.5 , 0.5 , 1 ] outdir = './' hgrid = Hgrid . open ( \"./hgrid.gr3\" , crs = \"epsg:4326\" ) bctides = Bctides ( hgrid = hgrid , flags = bctypes , constituents = constituents , database = database , add_earth_tidal = earth_tidal_potential , sthconst = sthconst , tobc = tobc , sobc = sobc , ) bctides . write ( outdir , start_date = start_date , end_date = rnday , overwrite = True , )","title":"Tides"},{"location":"getting-started/pre-processing-with-pyschism/bctides.html#bctides","text":"Please refer to this page for detailed horizontal B.C. and nudging options supported by SCHISM. PySCHISM supports both TPXO and FES2014 tidal database. Please download the data (you may need to register) and save it as: For TPXO : ~/.local/share/tpxo/h_tpxo9.v1.nc ~/.local/share/tpxo/u_tpxo9.v1.nc For FES2014 : ~/.local/share/fes2014/eastward_velocity/ ~/.local/share/fes2014/northward_velocity/ ~/.local/share/fes2014/ocean_tide_extrapolated/ Bctides class : arguments : hgrid : required , hgrid . ll ( lon / lat ) flags : requried , bctypes for each boundary [[ iettype , ifltype , itetype , isatype ], [ ... ], [ ... ], ... ] constituents : optional , default is \"major\" , which is eight major tidal constituents dabase : optional , default is \"tpxo\" add_earth_tidal : optional , default is True cutoff_depth : optional , default is 50.0 ethconst : optional , needed when using constant elevation along the boundary ( iettype = 2 ), which is given as [ v1 , v2 , v3 , ... ] vthconst : optional , needed when using constant discharge ( ifltype = 2 ) tthconst : optional , needed when using constant temperatur ( itetype = 2 ) sthconst : optional , needed when using constant temperature ( isatype = 2 ) tobc : optional , nudging factor , needed when itetype is not 0 , [ v1 , v2 , v3 , ... ] sobc : optional , nudging factor for salinity , needed when isatype is not 0 , [ v1 , v2 , v3 , ... ] relax : optional , needed when ifttype =- 4 , [ rel1 , rel2 ] Below shows an example script to generate bctides.in for hgrid with three open boundaries (2 ocean + 1 river). Bctypes for ocean boundaries are [5, 5, 4, 4], and for river is [0, 1, 1, 2]: from datetime import datetime import numpy as np from pyschism.mesh import Hgrid from pyschism.forcing.bctides import Bctides if __name__ == '__main__' : start_date = datetime ( 2017 , 12 , 1 ) rnday = 396 bctypes = [[ 5 , 5 , 4 , 4 ], [ 5 , 5 , 4 , 4 ], [ 0 , 1 , 1 , 2 ]] constituents = 'major' database = 'tpxo' earth_tidal_potential = True sthconst = [ np . nan , np . nan , 0 ] tobc = [ 0.5 , 0.5 , 1 ] sobc = [ 0.5 , 0.5 , 1 ] outdir = './' hgrid = Hgrid . open ( \"./hgrid.gr3\" , crs = \"epsg:4326\" ) bctides = Bctides ( hgrid = hgrid , flags = bctypes , constituents = constituents , database = database , add_earth_tidal = earth_tidal_potential , sthconst = sthconst , tobc = tobc , sobc = sobc , ) bctides . write ( outdir , start_date = start_date , end_date = rnday , overwrite = True , )","title":"Bctides"},{"location":"getting-started/pre-processing-with-pyschism/boundary.html","text":"Boundary Condition from HYCOM \u00b6 Please refer to this page for detailed horizontal B.C. and nudging options supported by SCHISM. Generating elev.2D.th.nc , SAL_3D.th.nc , TEM_3D.th.nc , and uv3D.th.nc : from datetime import datetime from pyschism.mesh.hgrid import Hgrid from pyschism.forcing.hycom.hycom2schism import OpenBoundaryInventory if __name__ == '__main__' : start_date = datetime ( 2022 , 4 , 1 ) rnday = 10 hgrid = Hgrid . open ( './hgrid.gr3' , crs = 'epsg:4326' ) vgrid = './vgrid.in' outdir = './' bnd = OpenBoundaryInventory ( hgrid , vgrid ) bnd . fetch_data ( outdir , start_date , rnday , elev2D = True , TS = True , UV = True ) Generating SAL_nu.nc and TEM_nu.nc for nudging: from datetime import datetime from pyschism.mesh import Hgrid from pyschism.forcing.hycom.hycom2schism import Nudge if __name__ == '__main__' : start_date = datetime ( 2022 , 4 , 1 ) rnday = 10 hgrid = Hgrid . open ( './hgrid.gr3' , crs = 'epsg:4326' ) vgrid = './vgrid.in' outdir = './' nudge = Nudge () nudge . fetch_data ( outdir , hgrid , vgrid , start_date , rnday ) This script also generates nudging coefficient files SAL_nu.gr3 and TEM_nu.gr3 .","title":"B.C. from HYCOM"},{"location":"getting-started/pre-processing-with-pyschism/boundary.html#boundary-condition-from-hycom","text":"Please refer to this page for detailed horizontal B.C. and nudging options supported by SCHISM. Generating elev.2D.th.nc , SAL_3D.th.nc , TEM_3D.th.nc , and uv3D.th.nc : from datetime import datetime from pyschism.mesh.hgrid import Hgrid from pyschism.forcing.hycom.hycom2schism import OpenBoundaryInventory if __name__ == '__main__' : start_date = datetime ( 2022 , 4 , 1 ) rnday = 10 hgrid = Hgrid . open ( './hgrid.gr3' , crs = 'epsg:4326' ) vgrid = './vgrid.in' outdir = './' bnd = OpenBoundaryInventory ( hgrid , vgrid ) bnd . fetch_data ( outdir , start_date , rnday , elev2D = True , TS = True , UV = True ) Generating SAL_nu.nc and TEM_nu.nc for nudging: from datetime import datetime from pyschism.mesh import Hgrid from pyschism.forcing.hycom.hycom2schism import Nudge if __name__ == '__main__' : start_date = datetime ( 2022 , 4 , 1 ) rnday = 10 hgrid = Hgrid . open ( './hgrid.gr3' , crs = 'epsg:4326' ) vgrid = './vgrid.in' outdir = './' nudge = Nudge () nudge . fetch_data ( outdir , hgrid , vgrid , start_date , rnday ) This script also generates nudging coefficient files SAL_nu.gr3 and TEM_nu.gr3 .","title":"Boundary Condition from HYCOM"},{"location":"getting-started/pre-processing-with-pyschism/installation.html","text":"Installation \u00b6 Setting up a conda environment is recommended to install PySCHISM. Please refer here for how to install Miniconda. Create conda environment: conda create -n pyschism python=3.9 From GitHub repo \u00b6 conda activate pyschism git clone https://github.com/schism-dev/pyschism.git cd pyschism pip install . # install as a user # OR pip install -e . #install as a developer Python package from PyPI \u00b6 Get the package with: pip3 install pyschism","title":"Installation"},{"location":"getting-started/pre-processing-with-pyschism/installation.html#installation","text":"Setting up a conda environment is recommended to install PySCHISM. Please refer here for how to install Miniconda. Create conda environment: conda create -n pyschism python=3.9","title":"Installation"},{"location":"getting-started/pre-processing-with-pyschism/installation.html#from-github-repo","text":"conda activate pyschism git clone https://github.com/schism-dev/pyschism.git cd pyschism pip install . # install as a user # OR pip install -e . #install as a developer","title":"From GitHub repo"},{"location":"getting-started/pre-processing-with-pyschism/installation.html#python-package-from-pypi","text":"Get the package with: pip3 install pyschism","title":"Python package from PyPI"},{"location":"getting-started/pre-processing-with-pyschism/nwm.html","text":"National Water Model \u00b6 NOAA NWM CONUS Retrospective Dataset is to provide streamflow when if_source=1 is defined in param.nml . This dataset covers from February 1979 to present, combination of different versions of NWM dataset. These four files are needed: source_sink.in vsource.th vsink.th msource.th The python script to generate these files is as follows: from datetime import datetime from pyschism.mesh import Hgrid from pyschism.forcing.source_sink.nwm import NationalWaterModel , NWMElementPairings if __name__ == '__main__' : startdate = datetime ( 2022 , 4 , 4 ) rnday = 10 hgrid = Hgrid . open ( \"./hgrid.gr3\" , crs = \"epsg:4326\" ) sources_pairings = pathlib . Path ( './sources.json' ) sinks_pairings = pathlib . Path ( './sinks.json' ) output_directory = pathlib . Path ( './' ) cache = pathlib . Path ( f './ { startdate . strftime ( \"%Y%m %d \" ) } ' ) cache . mkdir ( exist_ok = True , parents = True ) if all ([ sources_pairings . is_file (), sinks_pairings . is_file ()]) is False : pairings = NWMElementPairings ( hgrid ) sources_pairings . parent . mkdir ( exist_ok = True , parents = True ) pairings . save_json ( sources = sources_pairings , sinks = sinks_pairings ) else : pairings = NWMElementPairings . load_json ( hgrid , sources_pairings , sinks_pairings ) nwm = NationalWaterModel ( pairings = pairings , cache = cache ) nwm . write ( output_directory , hgrid , startdate , rnday , overwrite = True )","title":"Souce and Sink"},{"location":"getting-started/pre-processing-with-pyschism/nwm.html#national-water-model","text":"NOAA NWM CONUS Retrospective Dataset is to provide streamflow when if_source=1 is defined in param.nml . This dataset covers from February 1979 to present, combination of different versions of NWM dataset. These four files are needed: source_sink.in vsource.th vsink.th msource.th The python script to generate these files is as follows: from datetime import datetime from pyschism.mesh import Hgrid from pyschism.forcing.source_sink.nwm import NationalWaterModel , NWMElementPairings if __name__ == '__main__' : startdate = datetime ( 2022 , 4 , 4 ) rnday = 10 hgrid = Hgrid . open ( \"./hgrid.gr3\" , crs = \"epsg:4326\" ) sources_pairings = pathlib . Path ( './sources.json' ) sinks_pairings = pathlib . Path ( './sinks.json' ) output_directory = pathlib . Path ( './' ) cache = pathlib . Path ( f './ { startdate . strftime ( \"%Y%m %d \" ) } ' ) cache . mkdir ( exist_ok = True , parents = True ) if all ([ sources_pairings . is_file (), sinks_pairings . is_file ()]) is False : pairings = NWMElementPairings ( hgrid ) sources_pairings . parent . mkdir ( exist_ok = True , parents = True ) pairings . save_json ( sources = sources_pairings , sinks = sinks_pairings ) else : pairings = NWMElementPairings . load_json ( hgrid , sources_pairings , sinks_pairings ) nwm = NationalWaterModel ( pairings = pairings , cache = cache ) nwm . write ( output_directory , hgrid , startdate , rnday , overwrite = True )","title":"National Water Model"},{"location":"getting-started/pre-processing-with-pyschism/overview.html","text":"PySCHISM is a python based package for preparing most inputs required of 3D baroclinic SCHISM run, driven by TPXO , HYCOM , NWM , and a few pre-selected atmospheric models ( ERA5 , GFS , and HRRR ). PySCHISM has its own repository . The syntax of classes and methods in the library are subject to change in future releases, which will also significantly optimize performace and speed of some functionalities.","title":"Overview"},{"location":"input-output/bctides.html","text":"Please refer to sample bctides.in in the source code directory when you read this. The following table summarizes all horizontal B.C. and nudging options supported by SCHISM. The format for other necessary input files are decribed in the Optional inputs section. Variable Type 1 ( *.th ) Type 2 Type 3 Type 4 ( *[23]D.th ) Type 5 Type -1 Type -4, -5 ( uv3D.th ); Nudging Nudging/Sponge layer near bnd \\(\\eta\\) elev.th ; Time history; uniform along bnd constant Tidal amp/phases elev2D.th.nc : time- and space- varying along bnd elev2D.th.nc : sum of 3 and 4 Must = 0 N\\/A inu_elev=1 S&T, Tracers [MOD]_[ID].th : relax to time history (uniform along bnd for inflow) Relax to specified value for inflow Relax to i.c. for inflow [MOD]_3D.th.nc : relax to time- and space- varying values along bnd during inflow N/A N/A N/A inu_[MOD]=1 or 2 u,v flux.th : via discharge ( <0 for inflow!) Via dischage (<0 for inflow) Tidal amp/phases for u and v components uv3D.th.nc : time- and space- varying along bnd (in lon/lat for ics=2 ) uv3D.th.nc : sum of 3 and 4 Flather (0 for \\(\\eta\\) ) Relax to uv3D.th.nc (2 separate relaxations for in and outflow) inu_uv=1 Following is a psudo code to explain the structure of bctides.in for different types of boundary conditions listed above. Spaces between lines are added for clarity. < you notes > !Not used in code; write your own comments ntip tip_dp !# of constituents used in earth tidal potential; cut-off depth for applying tidal potential (i.e., it is not calculated when depth < tip_dp). for k = 1 , ntip talpha ( k ) !tidal constituent name jspc ( k ), tamp ( k ), tfreq ( k ), tnf ( k ), tear ( k ) !tidal species # (0: declinational; 1: diurnal; 2: semi-diurnal), amplitude constants, angular frequency, nodal factor, earth equilibrium argument (in degrees); end for nbfr !total # of tidal boundary forcing frequencies for k = 1 , nbfr alpha ( k ) !tidal constituent name amig ( k ), ff ( k ), face ( k ) !angular frequency (rad/s), nodal factor, earth equilibrium argument (in degrees) for constituent end for nope !# of open boundary segments for j = 1 , nope neta ( j ), iettype ( j ), ifltype ( j ), itetype ( j ), isatype ( j ), ( optional ) itrtype ( j ) !# of nodes on the open boundary segment j (corresponding to hgrid.gr3), B.C. flags for elevation, velocity, temperature, and salinity, and (optionally) for each tracer module invoked (in the order of GEN, AGE, SED3D, EcoSim, ICM, CoSiNE, FIB, and TIMOR) ! Elevation B.C. section if ( iettype ( j ) == 1 ) !time history of elevation on this boundary !no input in bctides.in; time history of elevation is read in from elev.th (ASCII); else if ( iettype ( j ) == 2 ) !this boundary is forced by a constant elevation ethconst !constant elevation value for this segment else if ( iettype ( j ) == 3 ) !this boundary is forced by tides for k = 1 , nbfr alpha ( k ) !tidal constituent name for i = 1 , nond ( j ) !loop over all open boundary nodes on this segment emo (( j , i , k ) efa ( j , i , k ) !amplitude and phase for each node on this open boundary end for i end for k else if ( iettype ( j ) == 4 ) !space- and time-varying input !no input in this file; time history of elevation is read in from elev2D.th.nc (netcdf); else if ( iettype ( j ) == 5 ) !combination of \u20183\u2019 and \u20184\u2019 !time history of elevation is read in from elev2D.th.nc, and then added to tidal B.C. specified below for k = 1 , nbfr alpha ( k ) !tidal constituent name for i = 1 , nond ( j ) !loop over all open boundary nodes on this segment emo (( j , i , k ) efa ( j , i , k ) !amplitude and phase for each node on this open boundary end for i end for k else if ( iettype ( j ) == 0 ) !elevations are not specified for this boundary (in this case the velocity must be specified). end if ! Velocity B.C. section if ( ifltype ( j ) == 0 ) !vel. not specified ! no input needed else if ( ifltype ( j ) == 1 ) !time history of discharge on this boundary ! no input in this file; time history of discharge is read in from flux.th (ASCII) else if ( ifltype ( j ) == 2 ) !this boundary is forced by a constant discharge vthconst !constant discharge (note that a negative number means inflow) else if ( ifltype ( j ) == 3 ) !vel. (not discharge!) is forced in frequency domain for k = 1 , nbfr alpha ( k ) !tidal constituent name for i = 1 , nond ( j ) !loop over all open boundary nodes on this segment umo ( j , i , k ) ufa ( j , i , k ) vmo ( j , i , k ) vfa ( j , i , k ) !amplitude and phase for (u,v) at each node on this open boundary end for i end for k else if ( ifltype ( j ) == 4 or - 4 ) !3D input !time history of velocity (not discharge!) is read in from uv3D.th.nc (netcdf) if ifltype ( j ) ==- 4 ) rel1 rel2 !relaxation constants for inflow and outflow (between 0 and 1 with 1 being strongest nudging) end if else if ( ifltype ( j ) == 5 ) !combination of \u20184\u2019 and \u20183\u2019 ! time history of velocity (not discharge!) is read in from uv3D.th.nc (netcdf) and then added to tidal velocity specified below for k = 1 , nbfr alpha ( k ) !tidal constituent name for i = 1 , nond ( j ) !loop over all open boundary nodes on this segment umo ( j , i , k ) ufa ( j , i , k ) vmo ( j , i , k ) vfa ( j , i , k ) !amplitude and phase for (u,v) at each node on this open boundary end for i end for k else if ( ifltype ( j ) == - 1 ) !Flather type radiation b.c. (iettype must be 0 in this case) 'eta_mean' !comment only - mean elevation below for i = 1 , nond ( j ) !loop over all nodes eta_m0 ( i ) !mean elev at each node end for i 'vn_mean' !comment only - mean normal velocity below for i = 1 , nond ( j ) qthcon ( 1 : Nz , i , j ) !mean normal velocity at the node (at all levels) end for i end if ! Temperature B.C. section if ( itetype ( j ) == 0 ) !temperature not specified ! no input needed else if ( itetype ( j ) == 1 ) !time history of temperature on this boundary tobc !nudging factor (between 0 and 1 with 1 being strongest nudging) for inflow; time history of temperature will be read in from TEM_1.th (ASCII) else if ( itetype ( j ) == 2 ) !this boundary is forced by a constant temperature tthconst !constant temperature on this segment tobc !nudging factor (between 0 and 1) for inflow else if ( itetype ( j ) == 3 ) !initial temperature profile for inflow tobc !nudging factor (between 0 and 1) for inflow else if ( itetype ( j ) == 4 ) !3D input tobc !nudging factor (between 0 and 1); time history of temperature is read in from TEM_3D.th.nc (netcdf) end if ! Salinity B.C. section ! Similar to temperature above if ( isatype ( j ) == 0 ) !salinity not specified ......... endif ! If any tracer module is invoked, you also need the corresponding B.C. part for each tracer module, and the structure is similar to temperature. !However, if the tracer module has multiple classes (which is the case for most modules; e.g., AGE, SED etc), !you need to specify the concentration constants (under `2` etc) for all classes in 1 row. In later sections !we will give examples for `.nc` inputs. end for !j: open boundary segment The following two samples provide more direct views on the structure of bctides.in. Sample 1 illustrates how to set Type 1 (Time history; uniform along bnd) and Type 2 (Constant) boundaries: Sample 2 illustrates how to set a Type 3 (tidal) boundary: Note on AGE module The number of tracers inside this module ( ntracer_age ) must be an even number, and usually you only specify the first ntracer_age/2 tracers on some open boundaries. For example, suppose ntracer_age=4 , you can set the B.C. flags as: 3 !nope 88 3 0 0 0 0 !ocean \u2013 no age tracer b.c. here .... 5 0 1 1 3 2 !Columbia River 1. !relax for T 1. !relax for S 1. 0. 0. 0. !inject age tracer #1 here 1. !relax for AGE 3 0 2 3 3 2 !Fraser River 1. !relax for T 1. !relax for S 0. 1. 0. 0. !inject age tracer #2 here 1. !relax for AGE Note bctides.in is one of the most error prone inputs for users due to its rigid formatting requirements. One useful trick to quickly find out the error location is to deliberately crash the code by placing illegal choices along this input to help isolate the errors (think of bi-section method). For example, you can intentionally set an illegal B.C. flag of 6 at a segment to see if the code crashes before or after this point. Note The tidal amplitudes and phases can be generated using utility scripts in the Tides .","title":"Boundary conditions (bctides.in)"},{"location":"input-output/friction.html","text":"Bottom friction can be provided in three types of file - drag.gr3 , or rough.gr3 or manning.gr3 . The \u2018depth\u2019 value in Gr3 file means \\(C_d\\) , bottom roughness in meters, or Manning\u2019s \\(n\\) , respectively. The 3 files correspond to nchi=0,1,-1 . Bottom friction is a critical parameter in shallow area. Note that the bottom friction parameterizations are very different between 2D and 3D model, and so you cannot use same input. For details please read this article . Further information can be found here .","title":"Bottom friction"},{"location":"input-output/hgrid.html","text":"The format of this file is shown below. It has 4 part. First part of the file is the information - hgrid.gr3 ! alphanumeric description; ignored by code 60356 31082 ! # of elements and nodes in the horizontal grid Second part is the node info. 1 402672.000000 282928.000000 2.0000000e+01 ! node #, x,y, depth 2 402416.000000 283385.000000 2.0000000e+01 3 402289.443000 282708.750000 2.0000000e+01 4 402014.597000 283185.897000 2.0000000e+01 ............................................. 31082 331118.598253 112401.547031 2.3000000e-01 !last node Third part is the connectivity table. 1 4 1 2 3 101 ! element #, element type (triangle or quad), nodes 1-4 2 3 2 4 3 3 3 4 5 3 ........................................... 60356 3 26914 30943 26804 !last element The last part is the list of open and land boundary segments. This part is needed for hgrid.gr3 only; not needed for other .gr3 files. 3 = Number of open boundaries 95 = Total number of open boundary nodes 3 = Number of nodes for open boundary 1 29835 ! first node on this segment 29834 ! 2nd node on this segment . . . 30001 !last node on this segment 90 = Number of nodes for open boundary 2 . . . 16 = number of land boundaries (including islands) 1743 = Total number of land boundary nodes 753 0 = Number of nodes for land boundary 1 ('0' means the exterior land boundary) 30381 ! first node on this segment ....................................... 1 !last node on this segment 741 0 ! Number of nodes for land boundary 2 ('0' means the exterior boundary) . . . 10 1 = Number of nodes for island boundary 1 ('1' means island) 29448 ! first node on this island . . . 29449 !last node on this island (note this is different from the first node \u201829448\u2019 above) Horizontal grid and boundary segments.. Note Land and Ocean boundary sagment can be generated with xmgredit5 \\(\\rightarrow\\) GridDEM \\(\\rightarrow\\) Create open/land boundaries; it can also be generated with SMS; If you have no open boundary, you can create two land boundary segments that are linked to each other. Likewise, if you have no land boundary, you should create two open boundary segments that are connected to each other; Although not required, we recommend you follow the following convention when generating the boundary segments. For the exterior boundary (open+land), go in counter-clockwise direction. With xmgredit5, the island boundaries are automatically created once you have finished designating all open and land segments on the exterior boundary. At the moment xmgredit5 cannot generate open boundary segments on islands. You cna use SMS or some python tools for this; Note that this format is the same as fort.14 of ADCIRC; keep an eye on the land boundary sagment, where instead of 741 0 in the above example SMS will produce 741 10 . At the moment, the flags for land/island boundaries are not used in SCHISM system except for WWM (see below); If WWM is used, the land boundary flags (cf. bold texts above) are required, and also there must not be any open boundary segments on any island. Therefore if you use WWM, make sure the exterior land boundary flags are 0 and island boundary flags are non-zero; Since WWM can only handle triangles, the mixed grid needs to be converted to a pure triangular grid for WWM using a pre-processing script Pre-Processing/split_quads_wwm.f90 .","title":"Horizontal grid (hgrid.gr3)"},{"location":"input-output/optional-inputs.html","text":"This section explains the details of some options inputs triggered by param.nml . The list is non-exhaustive as there are many such inputs. You can also find some example in test suite . hgrid.ll \u00b6 The format is the same as hgrid.gr3, except that the B.C. part is not necessary. The x,y of each node are replaced by lon/lat coordinates. If your model is already prepared in lon-lat, then, this file can be provided by simply making a soft-link to the hgrid.gr3 file. .gr3 \u00b6 The format is the same as hgrid.gr3 , except that the B.C. part is not necessary. The only difference between .gr3 files is that the \u2018depth\u2019 means different variables. We show some examples below. Some such inputs are generated by scripts (e.g. shapiro.gr3 , SAL_nudge.gr3 ). diffmin.gr3 and diffmax.gr3 : the \u2018depth\u2019 specifies the min/max of the viscosity or diffusivity. Needed if itur=3 or 4 . Suggested value: \\(1.e-6 m^2/s\\) for diffmin and \\(1 m^2/s\\) (or larger) for diffmax. albedo.gr3 and watertype.gr3 : required if ihconsv=1 , specifying the albedo (e.g. 0.1) and water type for attenuation rate of solar radiation. E.g., '1' is Jerlov type I (clean water), '5' is Jerlov type III etc. Consult schism_step.F90 for more details. '7' has largest attenuation rate (muddy water). adv.gr3 : Required if nadv=0 . The \u2018depth\u2019 is either 0 , 1 or 2 in this case, corresponding to where the momentum advection is turned off, using backward Euler, or using 2nd-order Runge-Kutta method at a node. krvel.gr3 : Required if inter_mom=-1 . The \u2018depth\u2019 is either 0 , 1 , corresponding to kriging ELM bring turned off/on. The generalized covariance function is specified by kr_co . bdef.gr3 : Required if imm=1 . The \u2018depth\u2019 specifies the amount of bed deformation (in meters) during time step 1 to ibdef , with positive values being uplift. .th (ASCII) \u00b6 This includes elev.th , flux.th , TEM_1.th , SAL_1.th etc, which share same ASCII structure. Below is a sample flux.th (note that negative values mean inflow!) 0. -1613.005 -6186.0 !time (in sec), discharge at the 1st boundary segment that has ifltype=1 (in bctides.in), discharge at the 2nd boundary segment with ifltype=1, etc 300. -1613.05005 -6186.60156 600. -1611.37854 -6208.62549 900. -1609.39612 -6232.22314 Notes Note that the time must start from 0, and the step can be anything \u2265dt . The '1' in TEM_1.th refers to the 1 (and only) tracer class in the temperature module; In the case of wind.th (with nws=1 or 4 ), the time step specified inside must also match wtiminc in param.nml . If nws=4 , the format of wind.th is different: each line specifies the wind u,v, and atmospheric pressure (in Pa) at all nodes. In the case of msource.th (invoked with if_source=1 ), the values after time stamp are tracer values at each source element (specified in source_sink.in ), and the order of tracers is: T,S, followed by each tracer module invoked. No vertical level info is needed here as the tracers are injected at a level or all levels. If you do not have good values for some tracers, use -9999. instead and the code will inject ambient concentration values for you. See examples of vsource.th , vsink.th and msource.th in sample_inputs/ of source code bundle. .th.nc (netcdf4) \u00b6 These include elev2D.th.nc , uv3D.th.nc , TEM_3D.th.nc , SAL_3D.th.nc , and [MOD]_3D.th.nc (where MOD is the tracer module name like \u2018COS\u2019). The format can be found below (also in test suite (e.g. schism_verification_tests/Test_ICM_UB/)). Notes the time always starts from 0, and the time step can be anything \u2265dt . Note that the time stamp series in time is not needed by the code; only time_step (in sec) is needed; time_series contains the main data at all relevant nodes; \u2018nOpenBndNodes\u2019 should be total number of nodes on all open boundary segments that require this input, and the values appear in same order as in bctides.in inside \u2018time_series\u2019; nLevels specifies the vertical structure, and nComponents specifies either scalar/vector, or # of classes in the tracer module; Most netcdf4 libraries allow float and double to be interchangeable but it's better to be strict about data type. elev2D.th.nc netcdf elev2D.th { dimensions: time = UNLIMITED ; // (73 currently) nOpenBndNodes = 748 ; nLevels = 1 ; nComponents = 1 ; one = 1 ; variables: float time_series(time, nOpenBndNodes, nLevels, nComponents) ; float time_step(one) ; double time(time) ; } uv3D.th.nc netcdf uv3D.th { dimensions: nOpenBndNodes = 748 ; one = 1 ; time = UNLIMITED ; // (73 currently) nLevels = 44 ; nComponents = 2 ; variables: float time_step(one) ; double time(time) ; float time_series(time, nOpenBndNodes, nLevels, nComponents) ; } TEM_3D.th.nc netcdf TEM_3D.th { dimensions: nOpenBndNodes = 30 ; nLevels = 35 ; nComponents = 1 ; one = 1 ; time = UNLIMITED ; // (371 currently) variables: float time_step(one) ; time_step:long_name = \"time step in seconds\" ; double time(time) ; time:long_name = \"simulation time in seconds\" ; float time_series(time, nOpenBndNodes, nLevels, nComponents) ; .prop \u00b6 The element-centered inputs color each element with a \u2018property\u2019, which can be visualized with xmgredit5 (Special \\(\\rightarrow\\) properties). xmgredit5 also allows editing of this file. The format follows xmgredit5 element property format: 1 -1 !element number, element property 2 0 3 2 4 5 .... Currently there are 3 .prop files: tvd.prop : user needs to explicitly specify horizontal regions where upwind or higher-order solver (TVD or WENO) is used, based on the element property values ( 0 : upwind; 1 : TVD or WENO) in tvd.prop . partition.prop : this input is required if you use static domain decomposition (NO_PARMETIS). The element property simple specifies the MPI process that owns each element. This can be generated e.g. by METIS. fluxflag.prop The element property flags (integers from -1,0,1,\u2026) specify the 'region number' for each element. The code will only compute the flow across a side if (1) the flags at its 2 adjacent elements differ by 1, and (2) neither flag is -1 (cf. Fig. 4.2). The output flux.out is a simple ASCII file with the format: 0.001389 0.1004E-01 0.1934E-01 !time (days), flow [m3/s] from region \u20181\u2019 to \u20180\u2019, flow from region \u20182\u2019 to \u20181\u2019,\u2026 0.002778 0.8852E-02 0.2285E-01 ... Example of `fluxflag.prop` .ic \u00b6 The I.C. inputs include the initial condition for elevation or tracers ( salt.ic , temp.ic , and ts.ic ). For most generic form of I.C. (variable in space and time), use hotstart.nc . elev.ic is a .gr3 file that specifies the initial elevation at each node. Depending on the values of flag_ic(1:2) , T,S I.C. inputs have different format. If flag_ic(1:2)= 1 , salt.ic and temp.ic take the .gr3 format; If flag_ic(1:2)= 2 , ts.ic takes the following simple format: 43 !total # of vertical levels 1 -2000. 4. 34. !level #, z-coordinates, temperature, salinity 2 -1000. 5. 34. ... Notes on ts.ic The code will extrapolate above surface or below bottom for you if your z-coordinates do not cover the full depth. Since it uses cubic spline interpolate, make sure your vertical profiles are well resolved to avoid unexpected min/max due to the cubic spline method. Similar format is used for other tracers; e.g., ICM_vvar_[1,2..].ic has a similar format to ts.ic . .nc \u00b6 Beside the time series inputs, we have the other types of netcdf4 input files as follows. Some sample files can be found in the test suite (e.g. schism_verification_tests/Test_ICM_UB/). hotstart.nc This input basically contains all major state variables defined at node/side/element. source.nc Required if if_source=-1 , this input combines all info needed for source/sink. source.nc netcdf source { dimensions: nsources = 1268 ; nsinks = UNLIMITED ; // (0 currently) ntracers = 23 ; time_msource = 732 ; time_vsource = 732 ; time_vsink = UNLIMITED ; // (0 currently) one = 1 ; variables: int source_elem(nsources) ; float vsource(time_vsource, nsources) ; float msource(time_msource, ntracers, nsources) ; double time_msource(time_msource) ; double time_vsource(time_vsource) ; float time_step_vsource(one) ; float time_step_msource(one) ; float time_step_vsink(one) ; // global attributes: :file_format = \"NETCDF4\" ; :_NCProperties = \"version=2,netcdf=4.8.1,hdf5=1.12.1\" ; } Notes Numbers of records for sources and sinks can be different; source_elem and sink_elem specify the element indices for source/sinks; The time stamps in time_msource etc are not needed by the code; only time_step_* (in sec) are required; ntracers specifies the total # of classes in all tracer modules (including T,S,..). The example above used ICM module (which has 21 classes), so together with T,S there are 23 'tracers'. *_nu.nc This input is used for tracer nudging ( inu_tr=2 ). You only need to specify values in the nudging zone and may use junk values -9999 inside (in this case the code will not nudge to the junk value). The mapping array \u2018map_to_global_node\u2019 is used to map the array indices to the global node indices. ICM_nu.nc netcdf ICM_nu { dimensions: node = 27023 ; nLevels = 40 ; ntracers = 21 ; time = UNLIMITED ; // (367 currently) variables: float time(time) ; int map_to_global_node(node) ; float tracer_concentration(time, node, nLevels, ntracers) ; } Notes node specifies total # of nodes in the nudging zone (i.e. with non-zero depths in *_nudge.gr3 ); ntracers is the # of tracer classes in this module (1 for T,S); map_to_global_node maps the local node indices to global nodes; The time stamps in time are not needed by the code, as step_inu_tr already specified the time step in nudging inputs. tracer_concentration specifies the tarcer concentrations to nudge toward. .in \u00b6 station.in (.bp format) \u00b6 This file is needed if iout_sta=1 and is in a build point format (essentially.gr3 without the connectivity table): 1 1 1 1 1 1 1 1 1 !on (1)|off(0) flags for elev, air pressure, windx, windy, T, S, u, v, w nsta !# of stations do i=1,np i,xsta(i),ysta(i),zsta(i) !zsta(i) is z-coordinates (from vertical datum; <0 is below) enddo Also see station.in.sample in the source bundle. source_sink.in \u00b6 This input is invoked if if_source=1 , and specifies the element #\u2019s for each (volume and mass) source and sink. The format is: 2 ! total # of elements with sources 100 ! element # of 1st source 101 ! element # of 2nd source !A blank line for readability; below are sinks 3 ! total # of elements with sinks 99 ! element # of 1st sink 100 105 ! element # of 3rd sink hydraulics.in \u00b6 This input is invoked if ihydraulics=1 , and is the main input for the hydraulics module. See hydraulics module manual for details. harm.in \u00b6 This file is needed if iharind=1 . Harmonic analysis capabilities were introduced in SCHISM by Andre Fortunato, using the routines of ADCIRC. These routines were developed by R.A. Luettich and J.J. Westerink, who are hereby acknowledged, and were used with written permission by R.A. Luettich. Note that only analysis on elevations at all nodes can be done at the moment. The file has the following format (text adapted from the ADCIRC user's manual): NFREQ = number of frequencies included in harmonic analysis of model results. for k=1 to NFREQ NAMEFR(k) = an alphanumeric descriptor (i.e. the constituent name) whose length must be <=16 characters HAFREQ(k), HAFF(k), HAFACE(k) = frequency (rad/s), nodal factor, equilibrium argument (degrees) end k loop THAS, THAF, NHAINC, FMV = See detail in the notes below NHAGE, NHAGV = flags that indicate whether or not harmonic analysis is performed, see notes below Notes THAS: the number of days after which data starts to be harmonically analyzed THAF: the number of days after which data ceases to be harmonically analyzed NHAINC: the number of time steps at which information is harmonically analyzed (information every NHAINC time steps after THAS is used in harmonic analysis) FMV: fraction of the harmonic analysis period (extending back from the end of the harmonic analysis period) to use for comparing the water elevation and velocity means and variances from the raw model time series with corresponding means and variances of a time series resynthesized from the harmonic constituents. This comparison is helpful for identifying numerical instabilities and for determining how complete the harmonic analysis was. Examples: FMV = 0. - do not compute any means and vars. FMV = 0.1 - compute means and vars. over final 10% of period used in harmonic analysis FMV = 1.0 - compute means and vars. over entire period used in harmonic analysis. NHAGE: NHAGE= 0 no harmonic analysis is performed for global elevations; NHAGE =1 harmonic analysis is performed for global elevations (output on harme.53); NHAGV: NHAGV is for velocity which is not active right now.","title":"Optional inputs"},{"location":"input-output/optional-inputs.html#hgridll","text":"The format is the same as hgrid.gr3, except that the B.C. part is not necessary. The x,y of each node are replaced by lon/lat coordinates. If your model is already prepared in lon-lat, then, this file can be provided by simply making a soft-link to the hgrid.gr3 file.","title":"hgrid.ll"},{"location":"input-output/optional-inputs.html#gr3","text":"The format is the same as hgrid.gr3 , except that the B.C. part is not necessary. The only difference between .gr3 files is that the \u2018depth\u2019 means different variables. We show some examples below. Some such inputs are generated by scripts (e.g. shapiro.gr3 , SAL_nudge.gr3 ). diffmin.gr3 and diffmax.gr3 : the \u2018depth\u2019 specifies the min/max of the viscosity or diffusivity. Needed if itur=3 or 4 . Suggested value: \\(1.e-6 m^2/s\\) for diffmin and \\(1 m^2/s\\) (or larger) for diffmax. albedo.gr3 and watertype.gr3 : required if ihconsv=1 , specifying the albedo (e.g. 0.1) and water type for attenuation rate of solar radiation. E.g., '1' is Jerlov type I (clean water), '5' is Jerlov type III etc. Consult schism_step.F90 for more details. '7' has largest attenuation rate (muddy water). adv.gr3 : Required if nadv=0 . The \u2018depth\u2019 is either 0 , 1 or 2 in this case, corresponding to where the momentum advection is turned off, using backward Euler, or using 2nd-order Runge-Kutta method at a node. krvel.gr3 : Required if inter_mom=-1 . The \u2018depth\u2019 is either 0 , 1 , corresponding to kriging ELM bring turned off/on. The generalized covariance function is specified by kr_co . bdef.gr3 : Required if imm=1 . The \u2018depth\u2019 specifies the amount of bed deformation (in meters) during time step 1 to ibdef , with positive values being uplift.","title":".gr3"},{"location":"input-output/optional-inputs.html#th-ascii","text":"This includes elev.th , flux.th , TEM_1.th , SAL_1.th etc, which share same ASCII structure. Below is a sample flux.th (note that negative values mean inflow!) 0. -1613.005 -6186.0 !time (in sec), discharge at the 1st boundary segment that has ifltype=1 (in bctides.in), discharge at the 2nd boundary segment with ifltype=1, etc 300. -1613.05005 -6186.60156 600. -1611.37854 -6208.62549 900. -1609.39612 -6232.22314 Notes Note that the time must start from 0, and the step can be anything \u2265dt . The '1' in TEM_1.th refers to the 1 (and only) tracer class in the temperature module; In the case of wind.th (with nws=1 or 4 ), the time step specified inside must also match wtiminc in param.nml . If nws=4 , the format of wind.th is different: each line specifies the wind u,v, and atmospheric pressure (in Pa) at all nodes. In the case of msource.th (invoked with if_source=1 ), the values after time stamp are tracer values at each source element (specified in source_sink.in ), and the order of tracers is: T,S, followed by each tracer module invoked. No vertical level info is needed here as the tracers are injected at a level or all levels. If you do not have good values for some tracers, use -9999. instead and the code will inject ambient concentration values for you. See examples of vsource.th , vsink.th and msource.th in sample_inputs/ of source code bundle.","title":".th (ASCII)"},{"location":"input-output/optional-inputs.html#thnc-netcdf4","text":"These include elev2D.th.nc , uv3D.th.nc , TEM_3D.th.nc , SAL_3D.th.nc , and [MOD]_3D.th.nc (where MOD is the tracer module name like \u2018COS\u2019). The format can be found below (also in test suite (e.g. schism_verification_tests/Test_ICM_UB/)). Notes the time always starts from 0, and the time step can be anything \u2265dt . Note that the time stamp series in time is not needed by the code; only time_step (in sec) is needed; time_series contains the main data at all relevant nodes; \u2018nOpenBndNodes\u2019 should be total number of nodes on all open boundary segments that require this input, and the values appear in same order as in bctides.in inside \u2018time_series\u2019; nLevels specifies the vertical structure, and nComponents specifies either scalar/vector, or # of classes in the tracer module; Most netcdf4 libraries allow float and double to be interchangeable but it's better to be strict about data type. elev2D.th.nc netcdf elev2D.th { dimensions: time = UNLIMITED ; // (73 currently) nOpenBndNodes = 748 ; nLevels = 1 ; nComponents = 1 ; one = 1 ; variables: float time_series(time, nOpenBndNodes, nLevels, nComponents) ; float time_step(one) ; double time(time) ; } uv3D.th.nc netcdf uv3D.th { dimensions: nOpenBndNodes = 748 ; one = 1 ; time = UNLIMITED ; // (73 currently) nLevels = 44 ; nComponents = 2 ; variables: float time_step(one) ; double time(time) ; float time_series(time, nOpenBndNodes, nLevels, nComponents) ; } TEM_3D.th.nc netcdf TEM_3D.th { dimensions: nOpenBndNodes = 30 ; nLevels = 35 ; nComponents = 1 ; one = 1 ; time = UNLIMITED ; // (371 currently) variables: float time_step(one) ; time_step:long_name = \"time step in seconds\" ; double time(time) ; time:long_name = \"simulation time in seconds\" ; float time_series(time, nOpenBndNodes, nLevels, nComponents) ;","title":".th.nc (netcdf4)"},{"location":"input-output/optional-inputs.html#prop","text":"The element-centered inputs color each element with a \u2018property\u2019, which can be visualized with xmgredit5 (Special \\(\\rightarrow\\) properties). xmgredit5 also allows editing of this file. The format follows xmgredit5 element property format: 1 -1 !element number, element property 2 0 3 2 4 5 .... Currently there are 3 .prop files: tvd.prop : user needs to explicitly specify horizontal regions where upwind or higher-order solver (TVD or WENO) is used, based on the element property values ( 0 : upwind; 1 : TVD or WENO) in tvd.prop . partition.prop : this input is required if you use static domain decomposition (NO_PARMETIS). The element property simple specifies the MPI process that owns each element. This can be generated e.g. by METIS. fluxflag.prop The element property flags (integers from -1,0,1,\u2026) specify the 'region number' for each element. The code will only compute the flow across a side if (1) the flags at its 2 adjacent elements differ by 1, and (2) neither flag is -1 (cf. Fig. 4.2). The output flux.out is a simple ASCII file with the format: 0.001389 0.1004E-01 0.1934E-01 !time (days), flow [m3/s] from region \u20181\u2019 to \u20180\u2019, flow from region \u20182\u2019 to \u20181\u2019,\u2026 0.002778 0.8852E-02 0.2285E-01 ... Example of `fluxflag.prop`","title":".prop"},{"location":"input-output/optional-inputs.html#ic","text":"The I.C. inputs include the initial condition for elevation or tracers ( salt.ic , temp.ic , and ts.ic ). For most generic form of I.C. (variable in space and time), use hotstart.nc . elev.ic is a .gr3 file that specifies the initial elevation at each node. Depending on the values of flag_ic(1:2) , T,S I.C. inputs have different format. If flag_ic(1:2)= 1 , salt.ic and temp.ic take the .gr3 format; If flag_ic(1:2)= 2 , ts.ic takes the following simple format: 43 !total # of vertical levels 1 -2000. 4. 34. !level #, z-coordinates, temperature, salinity 2 -1000. 5. 34. ... Notes on ts.ic The code will extrapolate above surface or below bottom for you if your z-coordinates do not cover the full depth. Since it uses cubic spline interpolate, make sure your vertical profiles are well resolved to avoid unexpected min/max due to the cubic spline method. Similar format is used for other tracers; e.g., ICM_vvar_[1,2..].ic has a similar format to ts.ic .","title":".ic"},{"location":"input-output/optional-inputs.html#nc","text":"Beside the time series inputs, we have the other types of netcdf4 input files as follows. Some sample files can be found in the test suite (e.g. schism_verification_tests/Test_ICM_UB/). hotstart.nc This input basically contains all major state variables defined at node/side/element. source.nc Required if if_source=-1 , this input combines all info needed for source/sink. source.nc netcdf source { dimensions: nsources = 1268 ; nsinks = UNLIMITED ; // (0 currently) ntracers = 23 ; time_msource = 732 ; time_vsource = 732 ; time_vsink = UNLIMITED ; // (0 currently) one = 1 ; variables: int source_elem(nsources) ; float vsource(time_vsource, nsources) ; float msource(time_msource, ntracers, nsources) ; double time_msource(time_msource) ; double time_vsource(time_vsource) ; float time_step_vsource(one) ; float time_step_msource(one) ; float time_step_vsink(one) ; // global attributes: :file_format = \"NETCDF4\" ; :_NCProperties = \"version=2,netcdf=4.8.1,hdf5=1.12.1\" ; } Notes Numbers of records for sources and sinks can be different; source_elem and sink_elem specify the element indices for source/sinks; The time stamps in time_msource etc are not needed by the code; only time_step_* (in sec) are required; ntracers specifies the total # of classes in all tracer modules (including T,S,..). The example above used ICM module (which has 21 classes), so together with T,S there are 23 'tracers'. *_nu.nc This input is used for tracer nudging ( inu_tr=2 ). You only need to specify values in the nudging zone and may use junk values -9999 inside (in this case the code will not nudge to the junk value). The mapping array \u2018map_to_global_node\u2019 is used to map the array indices to the global node indices. ICM_nu.nc netcdf ICM_nu { dimensions: node = 27023 ; nLevels = 40 ; ntracers = 21 ; time = UNLIMITED ; // (367 currently) variables: float time(time) ; int map_to_global_node(node) ; float tracer_concentration(time, node, nLevels, ntracers) ; } Notes node specifies total # of nodes in the nudging zone (i.e. with non-zero depths in *_nudge.gr3 ); ntracers is the # of tracer classes in this module (1 for T,S); map_to_global_node maps the local node indices to global nodes; The time stamps in time are not needed by the code, as step_inu_tr already specified the time step in nudging inputs. tracer_concentration specifies the tarcer concentrations to nudge toward.","title":".nc"},{"location":"input-output/optional-inputs.html#in","text":"","title":".in"},{"location":"input-output/optional-inputs.html#stationin-bp-format","text":"This file is needed if iout_sta=1 and is in a build point format (essentially.gr3 without the connectivity table): 1 1 1 1 1 1 1 1 1 !on (1)|off(0) flags for elev, air pressure, windx, windy, T, S, u, v, w nsta !# of stations do i=1,np i,xsta(i),ysta(i),zsta(i) !zsta(i) is z-coordinates (from vertical datum; <0 is below) enddo Also see station.in.sample in the source bundle.","title":"station.in (.bp format)"},{"location":"input-output/optional-inputs.html#source_sinkin","text":"This input is invoked if if_source=1 , and specifies the element #\u2019s for each (volume and mass) source and sink. The format is: 2 ! total # of elements with sources 100 ! element # of 1st source 101 ! element # of 2nd source !A blank line for readability; below are sinks 3 ! total # of elements with sinks 99 ! element # of 1st sink 100 105 ! element # of 3rd sink","title":"source_sink.in"},{"location":"input-output/optional-inputs.html#hydraulicsin","text":"This input is invoked if ihydraulics=1 , and is the main input for the hydraulics module. See hydraulics module manual for details.","title":"hydraulics.in"},{"location":"input-output/optional-inputs.html#harmin","text":"This file is needed if iharind=1 . Harmonic analysis capabilities were introduced in SCHISM by Andre Fortunato, using the routines of ADCIRC. These routines were developed by R.A. Luettich and J.J. Westerink, who are hereby acknowledged, and were used with written permission by R.A. Luettich. Note that only analysis on elevations at all nodes can be done at the moment. The file has the following format (text adapted from the ADCIRC user's manual): NFREQ = number of frequencies included in harmonic analysis of model results. for k=1 to NFREQ NAMEFR(k) = an alphanumeric descriptor (i.e. the constituent name) whose length must be <=16 characters HAFREQ(k), HAFF(k), HAFACE(k) = frequency (rad/s), nodal factor, equilibrium argument (degrees) end k loop THAS, THAF, NHAINC, FMV = See detail in the notes below NHAGE, NHAGV = flags that indicate whether or not harmonic analysis is performed, see notes below Notes THAS: the number of days after which data starts to be harmonically analyzed THAF: the number of days after which data ceases to be harmonically analyzed NHAINC: the number of time steps at which information is harmonically analyzed (information every NHAINC time steps after THAS is used in harmonic analysis) FMV: fraction of the harmonic analysis period (extending back from the end of the harmonic analysis period) to use for comparing the water elevation and velocity means and variances from the raw model time series with corresponding means and variances of a time series resynthesized from the harmonic constituents. This comparison is helpful for identifying numerical instabilities and for determining how complete the harmonic analysis was. Examples: FMV = 0. - do not compute any means and vars. FMV = 0.1 - compute means and vars. over final 10% of period used in harmonic analysis FMV = 1.0 - compute means and vars. over entire period used in harmonic analysis. NHAGE: NHAGE= 0 no harmonic analysis is performed for global elevations; NHAGE =1 harmonic analysis is performed for global elevations (output on harme.53); NHAGV: NHAGV is for velocity which is not active right now.","title":"harm.in"},{"location":"input-output/outputs.html","text":"All SCHISM outputs (except system outputs) can be found in outputs/ directory. Run info output (mirror.out) \u00b6 This is a mirror image of now-defunct screen output and is useful for diagnosis. Below is a sample: Barotropic model without ST calculation # of tracers in each module: 1 1 0 0 0 0 0 0 0 0 Total # of tracers= 2 Index ranges of each module: 1 1 2 2 3 2 3 2 3 2 3 2 3 2 3 2 3 2 3 2 # of global outputs= 27 done reading param.in; s2_mxnbt in param.in = 3.000000000000000 lhas_quad= T mnei, mnei_p = 4 9 lhas_quad= T Global Grid Size (ne,np,ns,nvrt): 108 130 237 2 **********Augmented Subdomain Sizes********** rank nea ne neg nea2 neg2 npa np npg npa2 npg2 nsa ns nsg nsa2 nsg2 0 30 14 16 40 10 43 24 19 43 0 72 37 35 72 0 1 28 14 14 38 10 40 23 17 40 0 67 36 31 67 0 2 26 13 13 32 6 38 23 15 38 0 63 35 28 63 0 3 23 13 10 30 7 34 22 12 34 0 56 34 22 56 0 4 23 13 10 30 7 34 22 12 34 0 56 34 22 56 0 5 28 14 14 38 10 40 23 17 40 0 67 36 31 67 0 6 26 13 13 32 6 38 23 15 38 0 63 35 28 63 0 7 30 14 16 40 10 43 24 19 43 0 72 37 35 72 0 **********Global Boundary Sizes********** nope neta nland nvel 1 13 1 31 **********Augmented Subdomain Boundary Sizes********** rank nope neta nland nvel 0 0 0 1 7 1 0 0 1 7 2 0 0 1 10 3 0 0 1 10 4 1 4 1 7 5 1 7 0 0 6 1 5 1 6 7 1 7 0 0 Max. & min. sidelength= 19934.91537849107 7973.938973963872 done init (1)... done init. tracers.. done initializing cold start Done initializing variables Done initializing outputs done computing initial vgrid... done computing initial nodal vel... done computing initial density... time stepping begins... 1 1440 done adjusting wind stress ... done flow b.c. done hvis... done backtracking done 1st preparation done 2nd preparation done solver; etatot= 3.1245774014922456E-002 ; average |eta|= 4.553235604713400E-005 done solving momentum eq... done solving w done solving transport equation done recomputing levels... done density calculation... TIME STEP= 1; TIME= 300.000000 \u2026. Notes The \u2018average |eta|\u2019 above can be used as a quick and easy way to check if the run is progressing smoothly; it is the average of the absolute value of surface elevation at all nodes. If it\u2019s too large or NaN, you have a problem. Global output \u00b6 SCHISM netcdf4 outputs are emitted in a directory called outputs/. This directory must exist or you will get an immediate crash from the model. Depending on whether or not you turned on OLDIO, the global netcdf outputs will look different. 1) Scribed I/O (OLDIO is OFF) Under this mode, the netcdf outputs are global (combined) outputs, and you can visualize or process thm using latest FORTRAN (e.g., read_output10*), matlab or python scripts, or the latest VisIT plugins. All 2D variables (e.g. elevation , sigWaveHeight etc) as well as static information such as geometry and connectivity info are grouped into out2d_*.nc . On the other hand, each 3D variable has its own output, and vector variables have X and Y components in separate outputs (e.g. horizontalVelX_*.nc and horizontalVelY_*.nc ). 2) Old I/O (OLDIO is ON) Under this mode, each MPI process will dump its own output and a post-processing script ( combin_output*.f90 ) will need to be used to combine these into global netcdf outputs. An example output file name is outputs/schout_000000_2.nc . More generally, the file name is: schout_[processor_no]_[time_block /stack #].nc Processor number The mpi_processor number starts at 0 and represents the MPI processor ID from the task that wrote the output. Time block The time blocks (\u2018stack\u2019) start from 1 and are sequential. The model buffers and writes data occasionally. Every ihfskip time steps it opens a new stack. For instance, if the time step is 120 seconds and ihfskip = 10080 , each stack will be 14-day long. \"Neat\" time lengths that will make meaningful analysis (e.g. daily, 10 days etc) are usually easiest later when you post-process; Some of the post-processing scripts will run a lot better if the length of your simulation is an even multiple of ihfskip. This can be done by altering ihfskip or the simulation length - at the risk of lengthening the simulation a bit, the latter often produces a neater result. If your simulation length is not an even multiple of the time block length, the last time block will be truncated on the last block. This will cause some minor errors and warnings in the post-processing tools. In addition, if you then restart the run it is best to repeat and overwrite the truncated block - the post-processing tools do not work well with blocks that grow and shrink in the middle of the run. If the output blocks match the end of the simulation very neatly, the model (at the time of writing) will open a new block that is very small in size. This is useful for the autocombine_MPI_elfe.pl , as the latter always waits until a new block to come out before starting to combine the previous block (and so it'd hang if the last empty block were not written out). Variable names The variables inside .nc correspond to 3D grid and state variables info at each output time step. The state variables (arrays) may have different centerings, e.g. at node/element/side. At the moment, most variables are centered around nodes (and most post-processing FORTRAN scripts also work on node-centered variables). Combine outputs The per-processor outputs need to be gathered into combined nc4 outputs first before you can visualize or post-process them. The script that does this is called combine_output11.f90 (a simple perl script autocombine_MPI_elfe.pl exists to combine all available outputs transparently; you just need to update the path to the compiled combine_output11 inside the script, and it can be launched before or after a run is done). See the header of combine_output11.f90 on sample compilation commands and usage. Once you are done combining, you should have nc4 files called something like schout_2.nc etc. Note that the stack # remains but the MPI process number is gone. There is no utility for gathering the outputs in stack/time; instead most post-processing tools are able to work with multiple stacks. Note that under OLDIO, SCHISM allows users to easily add more customized outputs, using the routine writeout_nc() inside schism_step. The combine scripts will automatically combine the additional outputs. You can visualize the combined nc4 outputs using VisIT (with SCHISM plug-ins). More info can be found in Visualization Special care for elevation outputs The elevation outputs from SCHISM are 'raw' outputs, which means users usually need to do post-processing to weed out dry instances themselves. This is a very common mistake from users. Always compare the elevation against local bottom elevation; if the total depth is less than h0 (as specified in param.nml ) you should not take the elevation outputs at face value - they should be instead NaN. For example, if the local depth is 2m, an elevation value of -3m or -1000m is the same: the node at this time instance is dry. Other global outputs The user may be interested in some maximum quantities. At the moment, SCHISM outputs two max files for elevation and depth-averaged velocity ( outputs/maxelev_* and outputs/maxdahv_* ). These files can be combined using Utility/Combining_Scripts/combine_gr3.f90 to generate maxelev.gr3 and maxdahv.gr3 . However, please exercise caution with maxelev.gr3 calculated this way because it may contain transient responses from cold start that should be disgarded. We recommend using Utility/Post-Processing-Fortran/read_output10_allnodes.f90 , which gives you more controls. Also see above for the general comments on elevation outputs. Another type of global outputs are hotstart outputs, which must be combined (using combine_hotstart7.f90 ) to generate a restart input. Station outputs \u00b6 These outputs are invoked with iout_sta=1 , and are found in outputs/staout_[1..,9] , corresponding respectively to elev, air pressure, wind u, wind v, T, S, u, v, w. Each output has a simple ASCII format: Time(sec), variable @ station 1,2,\u2026. (specified in station.in) Warning and fatal messages \u00b6 Warning message ( nonfatal_* ) contains non-fatal warnings, while fatal message file ( fatal.error ) contains fatal errors. In addition, you\u2019d also check the system error outputs from your parallel job.","title":"Outputs"},{"location":"input-output/outputs.html#run-info-output-mirrorout","text":"This is a mirror image of now-defunct screen output and is useful for diagnosis. Below is a sample: Barotropic model without ST calculation # of tracers in each module: 1 1 0 0 0 0 0 0 0 0 Total # of tracers= 2 Index ranges of each module: 1 1 2 2 3 2 3 2 3 2 3 2 3 2 3 2 3 2 3 2 # of global outputs= 27 done reading param.in; s2_mxnbt in param.in = 3.000000000000000 lhas_quad= T mnei, mnei_p = 4 9 lhas_quad= T Global Grid Size (ne,np,ns,nvrt): 108 130 237 2 **********Augmented Subdomain Sizes********** rank nea ne neg nea2 neg2 npa np npg npa2 npg2 nsa ns nsg nsa2 nsg2 0 30 14 16 40 10 43 24 19 43 0 72 37 35 72 0 1 28 14 14 38 10 40 23 17 40 0 67 36 31 67 0 2 26 13 13 32 6 38 23 15 38 0 63 35 28 63 0 3 23 13 10 30 7 34 22 12 34 0 56 34 22 56 0 4 23 13 10 30 7 34 22 12 34 0 56 34 22 56 0 5 28 14 14 38 10 40 23 17 40 0 67 36 31 67 0 6 26 13 13 32 6 38 23 15 38 0 63 35 28 63 0 7 30 14 16 40 10 43 24 19 43 0 72 37 35 72 0 **********Global Boundary Sizes********** nope neta nland nvel 1 13 1 31 **********Augmented Subdomain Boundary Sizes********** rank nope neta nland nvel 0 0 0 1 7 1 0 0 1 7 2 0 0 1 10 3 0 0 1 10 4 1 4 1 7 5 1 7 0 0 6 1 5 1 6 7 1 7 0 0 Max. & min. sidelength= 19934.91537849107 7973.938973963872 done init (1)... done init. tracers.. done initializing cold start Done initializing variables Done initializing outputs done computing initial vgrid... done computing initial nodal vel... done computing initial density... time stepping begins... 1 1440 done adjusting wind stress ... done flow b.c. done hvis... done backtracking done 1st preparation done 2nd preparation done solver; etatot= 3.1245774014922456E-002 ; average |eta|= 4.553235604713400E-005 done solving momentum eq... done solving w done solving transport equation done recomputing levels... done density calculation... TIME STEP= 1; TIME= 300.000000 \u2026. Notes The \u2018average |eta|\u2019 above can be used as a quick and easy way to check if the run is progressing smoothly; it is the average of the absolute value of surface elevation at all nodes. If it\u2019s too large or NaN, you have a problem.","title":"Run info output (mirror.out)"},{"location":"input-output/outputs.html#global-output","text":"SCHISM netcdf4 outputs are emitted in a directory called outputs/. This directory must exist or you will get an immediate crash from the model. Depending on whether or not you turned on OLDIO, the global netcdf outputs will look different. 1) Scribed I/O (OLDIO is OFF) Under this mode, the netcdf outputs are global (combined) outputs, and you can visualize or process thm using latest FORTRAN (e.g., read_output10*), matlab or python scripts, or the latest VisIT plugins. All 2D variables (e.g. elevation , sigWaveHeight etc) as well as static information such as geometry and connectivity info are grouped into out2d_*.nc . On the other hand, each 3D variable has its own output, and vector variables have X and Y components in separate outputs (e.g. horizontalVelX_*.nc and horizontalVelY_*.nc ). 2) Old I/O (OLDIO is ON) Under this mode, each MPI process will dump its own output and a post-processing script ( combin_output*.f90 ) will need to be used to combine these into global netcdf outputs. An example output file name is outputs/schout_000000_2.nc . More generally, the file name is: schout_[processor_no]_[time_block /stack #].nc Processor number The mpi_processor number starts at 0 and represents the MPI processor ID from the task that wrote the output. Time block The time blocks (\u2018stack\u2019) start from 1 and are sequential. The model buffers and writes data occasionally. Every ihfskip time steps it opens a new stack. For instance, if the time step is 120 seconds and ihfskip = 10080 , each stack will be 14-day long. \"Neat\" time lengths that will make meaningful analysis (e.g. daily, 10 days etc) are usually easiest later when you post-process; Some of the post-processing scripts will run a lot better if the length of your simulation is an even multiple of ihfskip. This can be done by altering ihfskip or the simulation length - at the risk of lengthening the simulation a bit, the latter often produces a neater result. If your simulation length is not an even multiple of the time block length, the last time block will be truncated on the last block. This will cause some minor errors and warnings in the post-processing tools. In addition, if you then restart the run it is best to repeat and overwrite the truncated block - the post-processing tools do not work well with blocks that grow and shrink in the middle of the run. If the output blocks match the end of the simulation very neatly, the model (at the time of writing) will open a new block that is very small in size. This is useful for the autocombine_MPI_elfe.pl , as the latter always waits until a new block to come out before starting to combine the previous block (and so it'd hang if the last empty block were not written out). Variable names The variables inside .nc correspond to 3D grid and state variables info at each output time step. The state variables (arrays) may have different centerings, e.g. at node/element/side. At the moment, most variables are centered around nodes (and most post-processing FORTRAN scripts also work on node-centered variables). Combine outputs The per-processor outputs need to be gathered into combined nc4 outputs first before you can visualize or post-process them. The script that does this is called combine_output11.f90 (a simple perl script autocombine_MPI_elfe.pl exists to combine all available outputs transparently; you just need to update the path to the compiled combine_output11 inside the script, and it can be launched before or after a run is done). See the header of combine_output11.f90 on sample compilation commands and usage. Once you are done combining, you should have nc4 files called something like schout_2.nc etc. Note that the stack # remains but the MPI process number is gone. There is no utility for gathering the outputs in stack/time; instead most post-processing tools are able to work with multiple stacks. Note that under OLDIO, SCHISM allows users to easily add more customized outputs, using the routine writeout_nc() inside schism_step. The combine scripts will automatically combine the additional outputs. You can visualize the combined nc4 outputs using VisIT (with SCHISM plug-ins). More info can be found in Visualization Special care for elevation outputs The elevation outputs from SCHISM are 'raw' outputs, which means users usually need to do post-processing to weed out dry instances themselves. This is a very common mistake from users. Always compare the elevation against local bottom elevation; if the total depth is less than h0 (as specified in param.nml ) you should not take the elevation outputs at face value - they should be instead NaN. For example, if the local depth is 2m, an elevation value of -3m or -1000m is the same: the node at this time instance is dry. Other global outputs The user may be interested in some maximum quantities. At the moment, SCHISM outputs two max files for elevation and depth-averaged velocity ( outputs/maxelev_* and outputs/maxdahv_* ). These files can be combined using Utility/Combining_Scripts/combine_gr3.f90 to generate maxelev.gr3 and maxdahv.gr3 . However, please exercise caution with maxelev.gr3 calculated this way because it may contain transient responses from cold start that should be disgarded. We recommend using Utility/Post-Processing-Fortran/read_output10_allnodes.f90 , which gives you more controls. Also see above for the general comments on elevation outputs. Another type of global outputs are hotstart outputs, which must be combined (using combine_hotstart7.f90 ) to generate a restart input.","title":"Global output"},{"location":"input-output/outputs.html#station-outputs","text":"These outputs are invoked with iout_sta=1 , and are found in outputs/staout_[1..,9] , corresponding respectively to elev, air pressure, wind u, wind v, T, S, u, v, w. Each output has a simple ASCII format: Time(sec), variable @ station 1,2,\u2026. (specified in station.in)","title":"Station outputs"},{"location":"input-output/outputs.html#warning-and-fatal-messages","text":"Warning message ( nonfatal_* ) contains non-fatal warnings, while fatal message file ( fatal.error ) contains fatal errors. In addition, you\u2019d also check the system error outputs from your parallel job.","title":"Warning and fatal messages"},{"location":"input-output/overview.html","text":"Type of inputs for SCHISM \u00b6 Most SCHISM inputs can be visualized with ACE/xmgredit5 or xmgr5 tools; see src/Utility/ACE for instructions on how to install these tools. Other useful tools will be mentioned in the later chapters. SCHISM input files can be broadly categorized into following 7 groups: *.gr3 , hgrid.ll : node centered spatial data and mesh connectivity. These file can be created/visualized using ACE/xmgredit5 ; *.th : time history files in ASCII format. The ASCII files can be visualized using ACE/xmgr5 ; *.ic : initial condition files. Some of these files use .gr3 format, while others have simple ASCII format; *.prop : element-centered spatial data and properties; can be created/visualized using ACE/xmgredit5 ; *.nc : netcdf4 inputs, including time history ( *.th.nc ), hotstart ( hotstart.nc ), and nudging inputs ( *_nu.nc ). These inputs may be created by PYSCHISM tool; *.nml : main parameter input ( param.nml ); *.in : role-specific input files with individual formats. ASCII inputs include vertical grid ( vgrid.in ), B.C. input ( bctides.in ), and hydraulics.in (for hydraulics module) etc; sflux/ : atmospheric and heat flux files in netcdf format (CF convention v1.0). These files can be visualized using standard tools like ncview, ferret etc; Inputs from modules: .nml , .inp etc. Mandatory inputs \u00b6 These inputs are required for all SCHISM simulations: Horizontal grid ( hgrid.gr3 ) Vertical grid ( vgrid.in ) Parameter input ( param.nml ) B.C. input ( bctides.in ) Bottom friction input ( drag.gr3 , or rough.gr3 or manning.gr3 , depending on parameter choice in param.nml ) We\u2019ll explain these inputs in detail below. Comments/explanations are usually preceded by '!'.","title":"Overview"},{"location":"input-output/overview.html#type-of-inputs-for-schism","text":"Most SCHISM inputs can be visualized with ACE/xmgredit5 or xmgr5 tools; see src/Utility/ACE for instructions on how to install these tools. Other useful tools will be mentioned in the later chapters. SCHISM input files can be broadly categorized into following 7 groups: *.gr3 , hgrid.ll : node centered spatial data and mesh connectivity. These file can be created/visualized using ACE/xmgredit5 ; *.th : time history files in ASCII format. The ASCII files can be visualized using ACE/xmgr5 ; *.ic : initial condition files. Some of these files use .gr3 format, while others have simple ASCII format; *.prop : element-centered spatial data and properties; can be created/visualized using ACE/xmgredit5 ; *.nc : netcdf4 inputs, including time history ( *.th.nc ), hotstart ( hotstart.nc ), and nudging inputs ( *_nu.nc ). These inputs may be created by PYSCHISM tool; *.nml : main parameter input ( param.nml ); *.in : role-specific input files with individual formats. ASCII inputs include vertical grid ( vgrid.in ), B.C. input ( bctides.in ), and hydraulics.in (for hydraulics module) etc; sflux/ : atmospheric and heat flux files in netcdf format (CF convention v1.0). These files can be visualized using standard tools like ncview, ferret etc; Inputs from modules: .nml , .inp etc.","title":"Type of inputs for SCHISM"},{"location":"input-output/overview.html#mandatory-inputs","text":"These inputs are required for all SCHISM simulations: Horizontal grid ( hgrid.gr3 ) Vertical grid ( vgrid.in ) Parameter input ( param.nml ) B.C. input ( bctides.in ) Bottom friction input ( drag.gr3 , or rough.gr3 or manning.gr3 , depending on parameter choice in param.nml ) We\u2019ll explain these inputs in detail below. Comments/explanations are usually preceded by '!'.","title":"Mandatory inputs"},{"location":"input-output/param.html","text":"Please refer to sample param.nml in the source code directory (sample_inputs/) while you read the following. The file uses the FORTRAN namelist format. The order of input parameters is not important. Governing rules for this file are: lines beginning with ! are comments; blank lines are ignored; the format for each parameter is: keywords=value ; keywords are case sensitive; spaces allowed between keywords and = and value ; comments starting with ! after value are ignored; value is an integer, double, or 2-char string (use ' ' (single quotes) for this); for double, any of the format is acceptable: 40 or 40. or 4.e1 but the last 2 are preferred. Use of decimal point for integers is discouraged; if multiple entries for a parameter are found, the last one wins - please avoid this array inputs follow column major (like FORTRAN) and can spill to multiple line. The namelist file is divided into 3 major sections: CORE , OPT and SCHOUT . CORE lists out all core parameters that must be specified by the user, i.e., no defaults are provided by the code. OPT and SCHOUT sections contain optional parameters and I/O flags, all of which have default values so the user does not have to specify any of these (the values shown in the sample are defaults unless otherwise stated). SCHISM will also echo the input values in the output file outputs/param_out.nml . Most parameters (and their keywords) are explained as follows; some are \u2018developers handles\u2019 that should not be tweaked usually. Also the sample has suggested values for many parameters. Note that you do not have to follow the order below. In many cases we have grouped related parameters for easier explanation, but you should specify them on separate lines. Also you'll find additional useful info in the comments of the sample param.nml . The parameters are listed out below in alphabetic order. CORE block \u00b6 The following parameters have to be specified by the user; otherwise you may get a fatal error. The exceptions are those parameters required by optional modules (e.g., WWM), which do not need to be present if the modules are not invoked. ipre (int) \u00b6 Pre-processing flag (1: on; 0: off). ipre=0 : normal run. Pre-processing flag is very useful for checking integrity of the horizontal grid and some inputs. ipre=1 : code will output centers.bp, sidecenters.bp, (centers build point, sidcenters build point), and mirror.out and stop. Check errors in fatal.error or system outputs. Important ipre/=0 only works for single CPU! If you use scribed I/O ( OLDIO off), make sure the number of 'computes' is 1, plus extra for scribes. Also under the scribe mode, the pre-processing run will likely finish without a clean exist (as the scribe world is still initializing). Check outputs/ ( mirror.out and fatal.error ) and system outputs; if the run is finished (e.g., you see 'Pre-processing completed successfully') you can manually kill the run. ibc (int), ibtp (int) \u00b6 Barotropic/baroclinic flags. If ibc=0 , a baroclinic model is used and regardless of the value for ibtp , the transport equation is solved. If ibc=1 , a barotropic model is used, and the transport equation may (when ibtp=1 ) or may not (when ibtp=0 ) be solved; in the former case, S and T are treated as passive tracers. rnday (double) \u00b6 Total simulation time in days. dt (double) \u00b6 Time step in seconds. This is the main time step in SCHISM. The transport solvers have their own adaptive time step for subcycling to satisfy the stability constraint. msc2 (int), mdc2 (int) \u00b6 These two parameters are only used if the wave module WWM is invoked ( USE_WWM is on and icou_elfe_wwm=1 ). The values represent the spectral resolution used in WWM and must match those in wwminput.nml ; eco_class, ntracer_gen, ntracer_age, sed_class (int) \u00b6 These parameters set the # of tracer \u2018classes\u2019 for each tracer module (EcoSim, GEN, AGE and SED), and are required if these modules are invoked in makefile. Note that other tracers modules (ICM, CoSiNE) set their own # of classes. nspool, ihfskip (int) \u00b6 These two flags control the global netcdf outputs. Output is done every nspool steps, and a new output stack is opened every ihfskip steps. The code requires that ihfskip is a multiple of nspool , and nhot_write (see SCHOUT section) is a a multiple of ihfskip . OPT block \u00b6 The optional parameters below are explained in alphabetical order. The default values can be seen below and also in the sample file (sample_inputs/). dramp=1. (double), drampbc=1. (double) \u00b6 Ramp periods in days for the tides, B.C. (boundary condition) or baroclincity. If ibc=0 , the ramp-up for baroclinicity is specified with drampbc (in days). Turn off ramp-up by setting the ramp-up period <=0. The ramp function is a hyperbolic tangent function; e.g. \\(f(t) = \\tanh(2t/86400/\\text{drampbc})\\) . flag_ic(:)=1 (int array) \u00b6 Options for specifying initial tracer fields for cold start, where each array entry corresponds to individual tracer model (e.g. TEM, SAL, SED etc). If flag_ic=1 , a vertically homogeneous but horizontally varying initial tracer field is specified in inputs like temp.ic , salt.ic , [MOD]_hvar_[class #].ic etc. If flag_ic=2 , a horizontally homogeneous but vertically varying initial tracer field, prescribed in a series of z-levels, is specified in inputs like ts.ic , [MOD]_vvar_[class #].ic . For more general 3D initial tracer fields, use the hot start option. See Optional inputs section for examples of some of these inputs. Note that there is a requirement that flag_ic(1)=flag_ic(2) . h0=0.01 (double) \u00b6 Minimum depth (in m) for wetting and drying (recommended value: 1cm ). When the total depth is less than h0 , the corresponding nodes/sides/elements are marked as dry. It should always be positive. h[1,2]_bcc=50,100 (double; in meters) \u00b6 Option on how the baroclinic gradient is calculated below bottom. The 'below-bottom' gradient is zeroed out if h>=h2_bcc (i.e. like Z) or uses constant extrapolation (i.e. like terrain-following) if h<=h1_bcc(<h2_bcc) . A linear transition is used if the local depth h1_bcc<h<h2_bcc . ibcc_mean=0 (int) \u00b6 Mean T,S profile option. If ibcc_mean=1 (or ihot=0 and flag_ic(1:2)=2 ), mean T/S profile is read in from ts.ic , and will be removed when calculating baroclinic force. No ts.ic is needed if ibcc_mean=0 . ic_elev=0 (int), nramp_elev=0 (int) (int) \u00b6 Elevation initial condition flag for cold start only ( ihot=0 ). If ic_elev=1 , elev.ic (in *.gr3 format) is needed to specify the initial condition (I.C.) Otherwise elevation is initialized to 0 everywhere (cold start only) or from the elevation values in hotstart.nc (hotstart option). If ic_elev=1 , the user can ramp up the elevation smoothly at the boundary starting from the specified elev.ic or hotstart.nc (if \\(ihot\\neq 0\\) ) by setting nramp_elev=1 (and the ramp-up period in this case is dramp ). It's usually OK to use nramp_elev=1 under either cold or hot start. icou_elfe_wwm=0, iwbl=0 (int) \u00b6 Coupler flag with WWM; needed if USE_WWM pre-processor is enabled. icou_elfe_wwm = 0 : no feedback from WWM to SCHISM (decoupled); 1 : coupled SCHISM-WWM. iwbl=1 : modified Grant-Madsen formulation for wave enhanced boundary layer; =2: Soulsby (1997) formulation; =0 : off. If icou_elfe_wwm=1 , additional parameters are: nstep_wwm=1 (int): call WWM every nstep_wwm time steps; hmin_radstress=1.0 (double): minimum total water depth in meters used only in radiation stress calculation; the radiation stress is zero if local depth <hmin_radstress . In addition, there are parameters related to Vortex Formalism of Bennice and Ardhuin (2008). ics=1 (int) \u00b6 Coordinate frame flag. If ics=1 , Cartesian coordinates are used; if ics=2 , both hgrid.ll and hgrid.gr3 use degrees latitude/longitude (and they should be identical to each other in this case). i_hmin_airsea_ex (int), hmin_airsea_ex (double; in meters) \u00b6 Option to locally turn off heat exchange. i_hmin_airsea_ex=1 : exchange turned off if local grid depth<hmin_airsea_ex i_hmin_airsea_ex=2 : exchange turned off if local water depth<hmin_airsea_ex i_hmin_salt_ex (int), hmin_salt_ex (double) \u00b6 Simialr tpo i_hmin_airsea_ex and hmin_airsea_ex . ielm_transport = 0, max_subcyc = 10 (int) \u00b6 Hybrid ELM-FV transport for performance. If ielm_transport=1 , the hybrid scheme is invoked and max_subcyc represents the max # of subcycling per time step in transport allowed; if the actual # of subcycling in a prism at a time step exceeds this threshold, more efficient ELM transport is used locally (at the expense of mass conservation and accuracy, so make sure this option is used sparingly). ieos_type=0, ieos_pres=0 (int) \u00b6 By default, use the nonlinear equation of state: ieos_type=0 . ieos_pres=0,1 will turn on/off hydrostatic pressure effects. If the potential temperature is used, the pressure effect has been accounted for, so ieos_pres=0. if_source=0 (int), dramp_ss=2. (double), lev_tr_source(:)=-9 (int array) \u00b6 Point sources/sinks option (0: no; 1: on). If if_source=1 , needs source_sink.in , vsource.th , vsink.th , and msource.th (see sample files in the source code directory src/ for their formats). If if_source=-1 , the input is source.nc , which includes element list inside and allows for different time steps and # of records for volume/mass source/sinks. If if_source/=0 , specify ramp-up period (in days) with dramp_ss (no ramp-up if <=0). The tracers are injected into an element at a particular level, as specified by lev_tr_source(1:ntr) (where ntr is total # of tracer modules, i.e. 1 input level per module). The code will extrapolate below bottom/above surface if necessary, so e.g., '-9' means bottom. To inject at all levels, set the level at '0'. AGE module The AGE mpdule has its own way of injecting age tracers (see below), so make sure the age concentrations from all sources are all -9999. in msource.th so as to not interfere. level_age(:)=-999 (int array) \u00b6 If USE_AGE is on, this array specifies the vertical level indices used to inject age tracers. You only need to specify this for the first half of the tracer classes. Use -999 to inject the tracer at all levels. iflux=0 (int) \u00b6 Parameter for checking volume and tracer mass conservation. If turned on ( =1 ), the conservation will be checked in regions specified by fluxflag.prop . iharind=0 (int) \u00b6 Harmonic analysis flag. If \\(iharind \\neq 0\\) , an input harm.in is needed. ihconsv=0, isconsv=0 (int) \u00b6 Heat budget and salt conservation models flags. If ihconsv=0 , the heat budget model is not used. If ihconsv=1 , a heat budget model is invoked, and a number of netcdf files for radiation flux input are read in from sflux/sflux_rad*.nc . If isconsv=1 , the evaporation and precipitation model is evoked but the user needs to turn on the pre-processing flag PREC_EVAP in makefile and recompile. In this case, ihconsv must be 1 , and additional netcdf inputs for precipitation ( sflux/sflux_prc*.nc ) are required. The user can also turn on USE_BULK_FAIRALL in the makefile to use COARE algorithm instead of the default Zeng's bulk aerodynamic module. ihdif=0 (int) \u00b6 Flag to use non-zero horizontal diffusivity. If ihdif=0 , it is not used. If \\(ihdif \\neq 0\\) , input hdif.gr3 is needed. ihot=0 (int) \u00b6 Hot start flag. If ihot=0 , cold start; if \\(ihot \\neq 0\\) , hot start from hotstart.nc . If ihot=1 , the time and time step are reset to zero, and outputs start from t=0 accordingly (and you need to adjust other inputs like .th etc). If ihot=2 , the run (and outputs) will continue from the time specified in hotstart.nc . Note With ihot=2 ,you do not need to adjust other inputs but you do need to make sure flux.out is inside outputs/ (even if you used iflux=0 ). If you used \\(iout\\_sta \\neq 0\\) , make sure staout_* are inside outputs/ as well. This is because the code will try to append to these outputs upon restart, and would crash if it cannot find them. On the other hand, you don't need to have the global outputs in outputs/ because nhot_write is a multiple of ihfskip so the new outputs will be written into a new stack. In fact, you can change the core count upon hotstart this way. ihydraulics=0 (int) \u00b6 Hydraulic model option. If \\(ihydraulics \\neq 0\\) , hydraulics.in is required (cf. hydraulics user manual). iloadtide=0 (int), loadtide_coef (double) \u00b6 Option to specify Self Attraction and Loading (SAL) tide, usually used for basin- or global-scale applications. If iloadtide=0 , SAL is off. If iloadtide=1 , the SAL input is interpolated values from a tide database, e.g., FES2014, given in loadtide_[FREQ].gr3 , where [FREQ] are frequency names (shared with tidal potential, in upper cases like M2) and the two 'depths' inside are amplitude (m) and phases (degrees behind GMT). In this option, SAL is lumped into tidal potential so it shares some parameters with tidal potential in bctides.in (cut-off depth, frequencies). If iloadtide=2 or 3, use a simple scaling for gravity approach (in this option, SAL is applied everywhere and does not share parameters with tidal potential). If iloadtide=2 , a simple scaling specified by loadtide_coef is used to reduce the gravity. If iloadtide=3 , the scaling is dependent on the local depth a la Stepanov & Hughes (2004), with a maximum value of loadtide_coef . imm=0, ibdef=10 (int) \u00b6 Bed deformation option. Default: 0 (no bed deformation); 1 : with bed deformation (needs ibdef (# of steps during which deformation occurs), and bdef.gr3 ); 2: 3D bottom deformation (need to interact with code). indvel=0 (int), ihorcon=0 (int), hvis_coef0=0.025 (double), ishapiro=1, niter_shap=1 (int), shapiro0=0.5 (double) \u00b6 These parameters (and inter_mom below) control the numerical dissipation in momentum solver; see SCHISM paper (Zhang et al. 2016) for details. indvel determines the method of converting side velocity to node velocity. If indvel=0 , the node velocity is allowed to be discontinuous across elements and additional viscosity/filter is needed to filter out grid-scale noises (spurious 'modes'). If indvel=1 , an inverse-distance interpolation procedure is used instead and the node velocity is continuous across elements; this method requires no additional viscosity/filter unless kriging ELM is used ( inter_mom >0 ). In general, indvel=0 leads to smaller numerical dissipation and better accuracy, but does generally require a velocity B.C. Due to spurious modes or dispersion (oscillation), viscosity/filter should be applied. ihorcon=0 :no horizontal viscosity; =1 : Laplacian (implemented as a filter); =2 : bi-harmonic. For ihorcon/=0 , hvis_coef0 specifies the non-dimensional viscosity. In addition to the viscosity, one can add the Shapiro filter, which is specified by ishapiro =0,\u00b11, 2 (turn off/on Shapiro filter). If ishapiro=1 , shapiro0 specifies the Shapiro filter strength. If ishapiro=-1 , an input called shapiro.gr3 is required which specifies the filter strength at each node (there is a pre-proc script gen_slope_filter2.f90 for this). If ishapiro=2 , a Smagorinsky-like filter is applied and shapiro0 is a coefficient \\((\\gamma_0)\\) , which is on the order of \\(10^3\\) : \\[\\begin{equation} \\label{eq01} \\begin{aligned} \\gamma &= 0.5\\tanh (\\gamma_0 \\Delta t \\hat \\mu)\\\\ \\hat\\mu &= \\sqrt{u_x^2 + v_y^2 + \\frac{(u_y + v_x)^2}{2}} \\end{aligned} \\end{equation}\\] If ishapiro/=0 , niter_shap specifies the number of times the filter is applied. For non-eddying regime applications (nearshore, estuary, river), an easiest option is: indvel=0 , ishapiro=1 ( shapiro0=0.5 ), ihorcon= inter_mom=0 . For applications that include the eddying regime, grid resolution in the eddying regime needs to vary smoothly (Zhang et al. 2016), and the user needs to tweak dissipation carefully. A starting point can be: indvel=ishapiro=inter_mom=0 , ihorcon=2 , hvis_coef0=0.025 . If the amount of dissipation is insufficient in the non-eddying regime, consider using ishapiro=-1 , with an appropriate shapiro.gr3 to turn on Shapiro filter locally to add dissipation, or use ishapiro=2 and shapiro0=1000 . inter_mom=0, kr_co=1 (int) \u00b6 Interpolation method at foot of characteristic line during ELM. inter_mom=0 : default linear interpolation; =1 : dual kriging method. If inter_mom=-1 , the depth in krvel.gr3 (0 or 1) will determine the order of interpolation (linear or kriging). If the kriging ELM is used, the general covariance function is specified in kr_co : 1: linear \\(f(h)=-h\\) ; 2: \\((h^2*log(h))\\) ; 3: cubic \\((h^3)\\) ; 4: \\((-h^5)\\) . In general, indvel=0 should be used with inter_mom=0 or inter_mom=1, kr_co=1,2 to avoid large dispersion (with additional viscosity/filter also). indvel=1 can be used with any covariance function without viscosity/filter. inu_elev=0, inu_uv=0 (int) \u00b6 Sponge layer for elevation and velocity (which is rarely used in SCHISM). Relaxation/nudging of a generic variable is implemented as: \\[\\begin{equation} \\label{eq02} \\widetilde \\varphi = (1-\\gamma)\\varphi + \\gamma\\varphi_{target} \\end{equation}\\] which is a discrete analogue of the restoration equation: \\[\\begin{equation} \\label{eq03} \\frac{\\partial \\varphi}{\\partial t} = \\frac{\\gamma}{\\Delta t} \\left( \\varphi_{target} - \\varphi \\right) \\end{equation}\\] If inu_elev=0 , no relaxation is applied to elevation. If inu_elev=1 , relaxation constants are specified in elev_nudge.gr3 (depth=0 means no relaxation, depth=1 means strongest nudging) and the elevations are relaxed toward 0. Similarly for inu_uv (with input uv_nudge.gr3 ). inu_tr(:)=0 (int array), nu_sum_mult(int), step_nu_tr=86400. (double) \u00b6 Nudging flag for tracer models (e.g. temperature), and nudging step (in sec). When inu_tr=0 , no nudging is done. When inu_tr=1 , relax back to initial conditions. When inu_tr=2 , nudge to values specified in [MOD]_nu.nc , which has a time step of step_nu_tr (in sec). If inu_tr\u22600 , the horizontal relaxation factors are specified in [MOD]_nudge.gr3 (as depths info), and the vertical relaxation factors are specified as a linear function of depths with: vnh[1,2] (transitional depths) and vnf[1,2] (relaxation constants at the 2 depths). The final relaxation constant is either the sum (if nu_sum_mult=1 ) or product (if nu_sum_mult=2 ) of the two, i.e. (horizontal + or * vertical relaxation factors) times dt . inunfl=0 (int) \u00b6 Choice of inundation algorithm. inunfl=1 can be used if the horizontal resolution is fine enough, and this is critical for tsunami simulations. Otherwise use inunfl=0 . isav=0 (int) \u00b6 Parameters for submerged or emergent vegetation. If isav=1 (module on), you need to supply 4 extra inputs: sav_cd.gr3 (form drag coefficient), sav_D.gr3 (depth is stem diameter in meters); sav_N.gr3 (depth is # of stems per m2); and sav_h.gr3 (height of canopy in meters). itr_met=3 (int), h_tvd=5. (double) \u00b6 Transport option for all tracers. itr_met=3 for TVD, and itr_met=4 for 3rd order WENO. h_tvd specifies the transition depth (in meters) between upwind and higher-order schemes; i.e. more efficient upwind is used when the local depth < h_tvd . Also in this case, you can additionally toggle between upwind and TVD by specifying regions in tvd.prop . The TVD limiter function is specified in TVD_LIM in mk/include_modules (for code efficiency purpose). If itr_met=3 , 2 tolerances are also required (use recommended values). If itr_met=4 (WENO), there are several additional parameters. The most important ones are epsilon[12] , which controls the numerical dispersion for the 2nd and 3rd-order WENO respectively (note that the code will decide which order is used at each prism based on geometric constraints). itur=0 (int) \u00b6 Turbulence closure model selection. If itur=0 , constant diffusivities are used for momentum and transport, and the diffusivities are specified in dfv0 , dfh0 . If itur=-2 , vertically homogeneous but horizontally varying diffusivities are used, which are read in from hvd.mom and hvd.tran . If itur=-1 , horizontally homogeneous but vertically varying diffusivities are used, which are read in from vvd.dat . If itur=2 , the zero-equation Pacanowski and Philander closure is used. In this case, a few extra parameters are required: h1_pp , vdmax_pp1 , vdmin_pp1 , tdmin_pp1 , h2_pp , vdmax_pp2 , vdmin_pp2 , tdmin_pp2 . Eddy viscosity is computed as: \\(\\text{vdiff}=\\text{vdiff_max}/(1+\\text{rich})^2+\\text{vdiff_min}\\) , and diffusivity \\(\\text{tdiff}=\\text{vdiff_max}/(1+\\text{rich})^2+\\text{tdiff_min}\\) , where \\(\\text{rich}\\) is a Richardson number. The limits ( vdiff_max , vdiff_min and tdiff_min ) vary linearly with depth between depths h1_pp and h2_pp . If itur=3 , then the two-equation closure schemes from the GLS model of Umlauf and Burchard (2003) are used. In this case, 2 additional parameters are required: mid , stab , which specify the closure scheme and stability function used: mid= MY is Mellor & Yamada; KL is GLS as k-kl; KE is GLS as \\(k-\\varepsilon\\) ; KW is GLS as \\(k-\\omega\\) ; UB is Umlauf & Burchard's optimal. stab=GA is Galperin's clipping (only for MY); KC is Kantha & Clayson's stability function). Also the user needs to specify max/min diffusivity/viscosity in diffmax.gr3 and diffmin.gr3 , as well as a surface mixing length scale constant xlsc0 . If itur=4 , GOTM turbulence model is invoked; the user needs to turn on pre-processing flag USE_GOTM in makefile and recompile (GOTM5.2 uses cmake, so does not need to be pre-compiled). In this case, the minimum and maximum viscosity/diffusivity are still specified in diffmin.gr3 and diffmax.gr3 . There are some ready-made samples for this input in the source code bundle. A key parameter is the steady state Richardson number. If you wish to tune some parameters inside, you may consult gotm.net for more details. Note GOTM has only been tested up to v5.2, not newer versions of GOTM. Using itur=3 generally gave similar results, but GOTM can produce substantially better stratification in some cases. meth_sink=1 (int) \u00b6 Option for sinks. If meth_sink =1 , the sink value is reset to 0 if an element is dry with a net sink value locally to prevent further drawdown of groundwater. nadv=1 (int), dtb_min=10, dtb_max=30 (double) \u00b6 Advection on/off option. If nadv=0 , advection is selectively turned off based on the input file adv.gr3 . If nadv=1 or 2 , advection is on for the whole domain, and backtracking is done using either Euler or 2nd-order Runge-Kutta scheme. dtb_[min,max] are min/max sub-steps allowed in btrack; actual sub-steps are calculated based on local flow gradients. nchi=0 (int) \u00b6 Bottom friction option. If nchi=-1 , and Manning's \\(n\\) is specified in manning.gr3 . If nchi=0 , spatially varying drag coefficients are read in from drag.gr3 (as depth info). For nchi=1 , bottom roughnesses (in meters) are read in from rough.gr3 . If nchi=-1 , an additional parameter is required: hmin_man (in meters) which sets the minimum depth used in the Manning formulation. If nchi=1 , one additional parameter is required: dzb_min (in meters). In this case the drag coefficients are calculated using the log drag law when the bottom cell thickness \\(\\delta_b>=\\text{dzb_min}\\) ; when \\(\\delta_b<\\text{dzb_min}\\) , \\(\\text{Cd}=\\text{Cdmax}\\) , where \\(\\text{Cdmax}=\\text{Cd}(\\delta_b=\\text{dzb_min})\\) . This is to avoid exaggeration of \\(\\text{Cd}\\) in very shallow water. ncor=0 (int) \u00b6 Coriolis option. If ncor=0 or -1 , a constant Coriolis parameter is specified. If ncor=0 , coricoef specifies the Coriolis factor. If ncor=-1 , rlatitude specifies the mean latitude used to calculate the Coriolis factor. If ncor=1 , a variable Coriolis parameter, based either on a beta-plane approximation ( ics=1 ) or on the latitude-dependent Coriolis ( ics=2 ), is used, with the lat/lon coordinates read in from hgrid.ll . For ics=1 , the center of beta-plane approximation must be correctly specified in sfea0 . nws=0 (int), drampwind=1. (double), iwind_form=1 (int), iwindoff(int), wtiminc=dt (double) \u00b6 Wind forcing options and the interval (in seconds) with which the wind input is read in. If nws=0 , no wind is applied (and wtiminc becomes unused). If nws=1 , constant wind is applied to the whole domain at any given time, and the time history of wind is read in from wind.th . If nws=2 , spatially and temporally variable wind is applied and the input consists of a number of netcdf files in the directory sflux/ . The option nws=3 is reserved for coupling with atmospheric model via ESMF caps. If nws=4 , the required input wind.th specifies wind and pressure at each node and at time of multiple of wtiminc . If nws=-1 (requires USE_PAHM), use Holland parametric wind model (barotropic only with wind and atmos. pressure). In this case, the Holland model is called every step so wtiminc is not used. An extra input is needed: hurricane-track.dat . If nws>0 , the ramp-up period (in days) is specified with drampwind . Also the user has the option to scale the wind speed using iwindoff =1 (which requires an additional input windfactor.gr3 ). The wind stress formulation is selected with iwind_form . If nws=2, ihconsv=1 && iwind_form=0 , the stress is calculated from heat exchange routine. If nws=1 or 4 , or nws=2 && ihconsv=0 , or nws=2 && iwind_form\u2260 0 , the stress is calculated from Pond & Pichard formulation (originally from Garret) if iwind_form=-1 , or from Hwang (2018) if iwind_form=1 . If WWM is enabled and icou_elfe_wwm > 0 and iwind_form=-2 , stress is calculated by WWM. rho0=1000, shw=4184. (double) \u00b6 Reference water density for Boussinesq approximation and specific heat of water in J/kg/K. rmaxvel=10. (double) \u00b6 Maximum velocity. This is needed mainly for the air-water exchange as the latter may blow up if the water velocity is above 20m/s. s1_mxbnt=0.5, s2_mxnbnt=3.5 (double) \u00b6 Dimensioning parameters used in inter-subdomain backtracking. Start from s[12]_mxnbt=0.53 , and increase them (gradually) if you get a fatal error like \u201cbtrack: overflow\u201d. Accuracy is not affected by the choice of these two parameters; these only affect memory consumption. slam0=-124, sfea0=45 (double) \u00b6 Centers of projection used to convert lat/lon to Cartesian coordinates. These are used if a variable Coriolis parameter is employed (ncor=1). start_year=2000, start_month=1, start_day=1 (int), start_hour=0, utc_start=8 (double) \u00b6 Starting time for simulation. utc_start is hours behind the GMT, and is used to adjust time zone. For example, utc_start=5 is US Eastern Time, and utc_start= -8 is Beijing Time. Note SCHISM's view of the time origin is relatively simple. The code starts from t=0 and marches with time step dt under cold start. It starts from a specified time upon hot start. There are only 2 exceptions: (1) in air-sea exchange ( ihconsv=1 ), the origin info (including utc_start ) specified in these parameters will be compared against the time origins in each sflux file to determine the starting stack; (2) WWM manages its own time origins in wwminput.nml ; it's advisable to align the latter with SCHISM's origin. thetai=0.6 (double) \u00b6 Implicitness parameter (between 0.5 and 1). Recommended value: 0.6. Use '1' to get maximum stability for strong wet/dry. SCHOUT block \u00b6 iout_sta=0, nspool_sta=10 (int) \u00b6 Station output flag. If iout_sta\u22600 , an input station.in is needed. In addition, nspool_sta specifies the spool for station output. In this case, make sure nhot_write is a multiple of nspool_sta . nc_out =1(int) \u00b6 Main switch to turn on/off netcdf outputs, useful for other programs (e.g., ESMF) to control outputs. nhot=0, nhot_write=8640 (int) \u00b6 Hot start output control parameters. If nhot=0 , no hot start output is generated. If nhot=1 , hotstart output is named outputs/hotstart_[process_id]_[it].nc every nhot_write steps, where it is the corresponding time iteration number. nhot_write must be a multiple of ihfskip and nspool_sta . If you want to hotstart a run from step it , you need to combine all process-specific hotstart outputs into a hotstart.nc using combine_hotstart7.f90 ( ./combine_hotstart7 -h for help). iof_* (int) \u00b6 Global output (in netcdf4 format) options, where * stands for module name (e.g. \"hydro\", \"wwm\" etc). The frequency of global outputs is controlled by 2 parameters in CORE : nspool and ihfskip . Output is done every nspool steps, and a new output stack is created every ihfskip steps. Under OLDIO, the outputs are named as outputs/schout_[MPI process id]_[1,2,3,...].nc etc. The combine scripts are then used to gather each output variable across all MPI processes into a single output, e.g., schout_[1,2,3\u2026].nc . With new scribed I/O, outputs look like out2d_1,2,3\u2026].nc etc (and no combining is necessary). In this mode, all 2D outputs are found in out2d* and each 3D output (note that vector output like horizontal velocity counts as 2 outputs) has its own netcdf files, e.g. salinity_[1,2..].nc , horizontalVelX_[1,2..].nc etc. Each output variable is controlled by an I/O flag in param.nml . We only show a few examples below; the rest are similar. Note that variables may be centered at nodes/sides/elements horizontally and whole/half levels vertically. However, at the moment most variables are centered at nodes and whole levels, and most post-processing FORTRAN scripts can only handle this type of outputs (while VisIT can handle other types). iof_hydro(1) = 1 !global elevation output control. If iof_hydro(1)=0, no global elevation is recorded. !If iof_hydro(1)= 1, global elevation for each node is recorded. !The output is either starting from scratch or appended to existing ones depending !on ihot. Some outputs are conditional upon you turn on certain module; e.g. iof_sed(7) = 1 won\u2019t output the bottom depth change unless you turn on USE_SED in makefile. Some \u2018native\u2019 variables (e.g., element- or side-centered) are: iof_hydro(27) = 1 !horizontal velocity defined at side [m/s]. These are the original velocity inside SCHISM","title":"Model parameters (param.nml)"},{"location":"input-output/param.html#core-block","text":"The following parameters have to be specified by the user; otherwise you may get a fatal error. The exceptions are those parameters required by optional modules (e.g., WWM), which do not need to be present if the modules are not invoked.","title":"CORE block"},{"location":"input-output/param.html#ipre-int","text":"Pre-processing flag (1: on; 0: off). ipre=0 : normal run. Pre-processing flag is very useful for checking integrity of the horizontal grid and some inputs. ipre=1 : code will output centers.bp, sidecenters.bp, (centers build point, sidcenters build point), and mirror.out and stop. Check errors in fatal.error or system outputs. Important ipre/=0 only works for single CPU! If you use scribed I/O ( OLDIO off), make sure the number of 'computes' is 1, plus extra for scribes. Also under the scribe mode, the pre-processing run will likely finish without a clean exist (as the scribe world is still initializing). Check outputs/ ( mirror.out and fatal.error ) and system outputs; if the run is finished (e.g., you see 'Pre-processing completed successfully') you can manually kill the run.","title":"ipre (int)"},{"location":"input-output/param.html#ibc-int-ibtp-int","text":"Barotropic/baroclinic flags. If ibc=0 , a baroclinic model is used and regardless of the value for ibtp , the transport equation is solved. If ibc=1 , a barotropic model is used, and the transport equation may (when ibtp=1 ) or may not (when ibtp=0 ) be solved; in the former case, S and T are treated as passive tracers.","title":"ibc (int), ibtp (int)"},{"location":"input-output/param.html#rnday-double","text":"Total simulation time in days.","title":"rnday (double)"},{"location":"input-output/param.html#dt-double","text":"Time step in seconds. This is the main time step in SCHISM. The transport solvers have their own adaptive time step for subcycling to satisfy the stability constraint.","title":"dt (double)"},{"location":"input-output/param.html#msc2-int-mdc2-int","text":"These two parameters are only used if the wave module WWM is invoked ( USE_WWM is on and icou_elfe_wwm=1 ). The values represent the spectral resolution used in WWM and must match those in wwminput.nml ;","title":"msc2 (int), mdc2 (int)"},{"location":"input-output/param.html#eco_class-ntracer_gen-ntracer_age-sed_class-int","text":"These parameters set the # of tracer \u2018classes\u2019 for each tracer module (EcoSim, GEN, AGE and SED), and are required if these modules are invoked in makefile. Note that other tracers modules (ICM, CoSiNE) set their own # of classes.","title":"eco_class, ntracer_gen, ntracer_age, sed_class (int)"},{"location":"input-output/param.html#nspool-ihfskip-int","text":"These two flags control the global netcdf outputs. Output is done every nspool steps, and a new output stack is opened every ihfskip steps. The code requires that ihfskip is a multiple of nspool , and nhot_write (see SCHOUT section) is a a multiple of ihfskip .","title":"nspool, ihfskip (int)"},{"location":"input-output/param.html#opt-block","text":"The optional parameters below are explained in alphabetical order. The default values can be seen below and also in the sample file (sample_inputs/).","title":"OPT block"},{"location":"input-output/param.html#dramp1-double-drampbc1-double","text":"Ramp periods in days for the tides, B.C. (boundary condition) or baroclincity. If ibc=0 , the ramp-up for baroclinicity is specified with drampbc (in days). Turn off ramp-up by setting the ramp-up period <=0. The ramp function is a hyperbolic tangent function; e.g. \\(f(t) = \\tanh(2t/86400/\\text{drampbc})\\) .","title":"dramp=1. (double), drampbc=1. (double)"},{"location":"input-output/param.html#flag_ic1-int-array","text":"Options for specifying initial tracer fields for cold start, where each array entry corresponds to individual tracer model (e.g. TEM, SAL, SED etc). If flag_ic=1 , a vertically homogeneous but horizontally varying initial tracer field is specified in inputs like temp.ic , salt.ic , [MOD]_hvar_[class #].ic etc. If flag_ic=2 , a horizontally homogeneous but vertically varying initial tracer field, prescribed in a series of z-levels, is specified in inputs like ts.ic , [MOD]_vvar_[class #].ic . For more general 3D initial tracer fields, use the hot start option. See Optional inputs section for examples of some of these inputs. Note that there is a requirement that flag_ic(1)=flag_ic(2) .","title":"flag_ic(:)=1 (int array)"},{"location":"input-output/param.html#h0001-double","text":"Minimum depth (in m) for wetting and drying (recommended value: 1cm ). When the total depth is less than h0 , the corresponding nodes/sides/elements are marked as dry. It should always be positive.","title":"h0=0.01 (double)"},{"location":"input-output/param.html#h12_bcc50100-double-in-meters","text":"Option on how the baroclinic gradient is calculated below bottom. The 'below-bottom' gradient is zeroed out if h>=h2_bcc (i.e. like Z) or uses constant extrapolation (i.e. like terrain-following) if h<=h1_bcc(<h2_bcc) . A linear transition is used if the local depth h1_bcc<h<h2_bcc .","title":"h[1,2]_bcc=50,100 (double; in meters)"},{"location":"input-output/param.html#ibcc_mean0-int","text":"Mean T,S profile option. If ibcc_mean=1 (or ihot=0 and flag_ic(1:2)=2 ), mean T/S profile is read in from ts.ic , and will be removed when calculating baroclinic force. No ts.ic is needed if ibcc_mean=0 .","title":"ibcc_mean=0 (int)"},{"location":"input-output/param.html#ic_elev0-int-nramp_elev0-int-int","text":"Elevation initial condition flag for cold start only ( ihot=0 ). If ic_elev=1 , elev.ic (in *.gr3 format) is needed to specify the initial condition (I.C.) Otherwise elevation is initialized to 0 everywhere (cold start only) or from the elevation values in hotstart.nc (hotstart option). If ic_elev=1 , the user can ramp up the elevation smoothly at the boundary starting from the specified elev.ic or hotstart.nc (if \\(ihot\\neq 0\\) ) by setting nramp_elev=1 (and the ramp-up period in this case is dramp ). It's usually OK to use nramp_elev=1 under either cold or hot start.","title":"ic_elev=0 (int), nramp_elev=0 (int) (int)"},{"location":"input-output/param.html#icou_elfe_wwm0-iwbl0-int","text":"Coupler flag with WWM; needed if USE_WWM pre-processor is enabled. icou_elfe_wwm = 0 : no feedback from WWM to SCHISM (decoupled); 1 : coupled SCHISM-WWM. iwbl=1 : modified Grant-Madsen formulation for wave enhanced boundary layer; =2: Soulsby (1997) formulation; =0 : off. If icou_elfe_wwm=1 , additional parameters are: nstep_wwm=1 (int): call WWM every nstep_wwm time steps; hmin_radstress=1.0 (double): minimum total water depth in meters used only in radiation stress calculation; the radiation stress is zero if local depth <hmin_radstress . In addition, there are parameters related to Vortex Formalism of Bennice and Ardhuin (2008).","title":"icou_elfe_wwm=0, iwbl=0 (int)"},{"location":"input-output/param.html#ics1-int","text":"Coordinate frame flag. If ics=1 , Cartesian coordinates are used; if ics=2 , both hgrid.ll and hgrid.gr3 use degrees latitude/longitude (and they should be identical to each other in this case).","title":"ics=1 (int)"},{"location":"input-output/param.html#i_hmin_airsea_ex-int-hmin_airsea_ex-double-in-meters","text":"Option to locally turn off heat exchange. i_hmin_airsea_ex=1 : exchange turned off if local grid depth<hmin_airsea_ex i_hmin_airsea_ex=2 : exchange turned off if local water depth<hmin_airsea_ex","title":"i_hmin_airsea_ex (int), hmin_airsea_ex (double; in meters)"},{"location":"input-output/param.html#i_hmin_salt_ex-int-hmin_salt_ex-double","text":"Simialr tpo i_hmin_airsea_ex and hmin_airsea_ex .","title":"i_hmin_salt_ex (int), hmin_salt_ex (double)"},{"location":"input-output/param.html#ielm_transport-0-max_subcyc-10-int","text":"Hybrid ELM-FV transport for performance. If ielm_transport=1 , the hybrid scheme is invoked and max_subcyc represents the max # of subcycling per time step in transport allowed; if the actual # of subcycling in a prism at a time step exceeds this threshold, more efficient ELM transport is used locally (at the expense of mass conservation and accuracy, so make sure this option is used sparingly).","title":"ielm_transport = 0, max_subcyc = 10 (int)"},{"location":"input-output/param.html#ieos_type0-ieos_pres0-int","text":"By default, use the nonlinear equation of state: ieos_type=0 . ieos_pres=0,1 will turn on/off hydrostatic pressure effects. If the potential temperature is used, the pressure effect has been accounted for, so ieos_pres=0.","title":"ieos_type=0, ieos_pres=0 (int)"},{"location":"input-output/param.html#if_source0-int-dramp_ss2-double-lev_tr_source-9-int-array","text":"Point sources/sinks option (0: no; 1: on). If if_source=1 , needs source_sink.in , vsource.th , vsink.th , and msource.th (see sample files in the source code directory src/ for their formats). If if_source=-1 , the input is source.nc , which includes element list inside and allows for different time steps and # of records for volume/mass source/sinks. If if_source/=0 , specify ramp-up period (in days) with dramp_ss (no ramp-up if <=0). The tracers are injected into an element at a particular level, as specified by lev_tr_source(1:ntr) (where ntr is total # of tracer modules, i.e. 1 input level per module). The code will extrapolate below bottom/above surface if necessary, so e.g., '-9' means bottom. To inject at all levels, set the level at '0'. AGE module The AGE mpdule has its own way of injecting age tracers (see below), so make sure the age concentrations from all sources are all -9999. in msource.th so as to not interfere.","title":"if_source=0 (int), dramp_ss=2. (double), lev_tr_source(:)=-9 (int array)"},{"location":"input-output/param.html#level_age-999-int-array","text":"If USE_AGE is on, this array specifies the vertical level indices used to inject age tracers. You only need to specify this for the first half of the tracer classes. Use -999 to inject the tracer at all levels.","title":"level_age(:)=-999 (int array)"},{"location":"input-output/param.html#iflux0-int","text":"Parameter for checking volume and tracer mass conservation. If turned on ( =1 ), the conservation will be checked in regions specified by fluxflag.prop .","title":"iflux=0 (int)"},{"location":"input-output/param.html#iharind0-int","text":"Harmonic analysis flag. If \\(iharind \\neq 0\\) , an input harm.in is needed.","title":"iharind=0 (int)"},{"location":"input-output/param.html#ihconsv0-isconsv0-int","text":"Heat budget and salt conservation models flags. If ihconsv=0 , the heat budget model is not used. If ihconsv=1 , a heat budget model is invoked, and a number of netcdf files for radiation flux input are read in from sflux/sflux_rad*.nc . If isconsv=1 , the evaporation and precipitation model is evoked but the user needs to turn on the pre-processing flag PREC_EVAP in makefile and recompile. In this case, ihconsv must be 1 , and additional netcdf inputs for precipitation ( sflux/sflux_prc*.nc ) are required. The user can also turn on USE_BULK_FAIRALL in the makefile to use COARE algorithm instead of the default Zeng's bulk aerodynamic module.","title":"ihconsv=0, isconsv=0 (int)"},{"location":"input-output/param.html#ihdif0-int","text":"Flag to use non-zero horizontal diffusivity. If ihdif=0 , it is not used. If \\(ihdif \\neq 0\\) , input hdif.gr3 is needed.","title":"ihdif=0 (int)"},{"location":"input-output/param.html#ihot0-int","text":"Hot start flag. If ihot=0 , cold start; if \\(ihot \\neq 0\\) , hot start from hotstart.nc . If ihot=1 , the time and time step are reset to zero, and outputs start from t=0 accordingly (and you need to adjust other inputs like .th etc). If ihot=2 , the run (and outputs) will continue from the time specified in hotstart.nc . Note With ihot=2 ,you do not need to adjust other inputs but you do need to make sure flux.out is inside outputs/ (even if you used iflux=0 ). If you used \\(iout\\_sta \\neq 0\\) , make sure staout_* are inside outputs/ as well. This is because the code will try to append to these outputs upon restart, and would crash if it cannot find them. On the other hand, you don't need to have the global outputs in outputs/ because nhot_write is a multiple of ihfskip so the new outputs will be written into a new stack. In fact, you can change the core count upon hotstart this way.","title":"ihot=0 (int)"},{"location":"input-output/param.html#ihydraulics0-int","text":"Hydraulic model option. If \\(ihydraulics \\neq 0\\) , hydraulics.in is required (cf. hydraulics user manual).","title":"ihydraulics=0 (int)"},{"location":"input-output/param.html#iloadtide0-int-loadtide_coef-double","text":"Option to specify Self Attraction and Loading (SAL) tide, usually used for basin- or global-scale applications. If iloadtide=0 , SAL is off. If iloadtide=1 , the SAL input is interpolated values from a tide database, e.g., FES2014, given in loadtide_[FREQ].gr3 , where [FREQ] are frequency names (shared with tidal potential, in upper cases like M2) and the two 'depths' inside are amplitude (m) and phases (degrees behind GMT). In this option, SAL is lumped into tidal potential so it shares some parameters with tidal potential in bctides.in (cut-off depth, frequencies). If iloadtide=2 or 3, use a simple scaling for gravity approach (in this option, SAL is applied everywhere and does not share parameters with tidal potential). If iloadtide=2 , a simple scaling specified by loadtide_coef is used to reduce the gravity. If iloadtide=3 , the scaling is dependent on the local depth a la Stepanov & Hughes (2004), with a maximum value of loadtide_coef .","title":"iloadtide=0 (int), loadtide_coef (double)"},{"location":"input-output/param.html#imm0-ibdef10-int","text":"Bed deformation option. Default: 0 (no bed deformation); 1 : with bed deformation (needs ibdef (# of steps during which deformation occurs), and bdef.gr3 ); 2: 3D bottom deformation (need to interact with code).","title":"imm=0, ibdef=10 (int)"},{"location":"input-output/param.html#indvel0-int-ihorcon0-int-hvis_coef00025-double-ishapiro1-niter_shap1-int-shapiro005-double","text":"These parameters (and inter_mom below) control the numerical dissipation in momentum solver; see SCHISM paper (Zhang et al. 2016) for details. indvel determines the method of converting side velocity to node velocity. If indvel=0 , the node velocity is allowed to be discontinuous across elements and additional viscosity/filter is needed to filter out grid-scale noises (spurious 'modes'). If indvel=1 , an inverse-distance interpolation procedure is used instead and the node velocity is continuous across elements; this method requires no additional viscosity/filter unless kriging ELM is used ( inter_mom >0 ). In general, indvel=0 leads to smaller numerical dissipation and better accuracy, but does generally require a velocity B.C. Due to spurious modes or dispersion (oscillation), viscosity/filter should be applied. ihorcon=0 :no horizontal viscosity; =1 : Laplacian (implemented as a filter); =2 : bi-harmonic. For ihorcon/=0 , hvis_coef0 specifies the non-dimensional viscosity. In addition to the viscosity, one can add the Shapiro filter, which is specified by ishapiro =0,\u00b11, 2 (turn off/on Shapiro filter). If ishapiro=1 , shapiro0 specifies the Shapiro filter strength. If ishapiro=-1 , an input called shapiro.gr3 is required which specifies the filter strength at each node (there is a pre-proc script gen_slope_filter2.f90 for this). If ishapiro=2 , a Smagorinsky-like filter is applied and shapiro0 is a coefficient \\((\\gamma_0)\\) , which is on the order of \\(10^3\\) : \\[\\begin{equation} \\label{eq01} \\begin{aligned} \\gamma &= 0.5\\tanh (\\gamma_0 \\Delta t \\hat \\mu)\\\\ \\hat\\mu &= \\sqrt{u_x^2 + v_y^2 + \\frac{(u_y + v_x)^2}{2}} \\end{aligned} \\end{equation}\\] If ishapiro/=0 , niter_shap specifies the number of times the filter is applied. For non-eddying regime applications (nearshore, estuary, river), an easiest option is: indvel=0 , ishapiro=1 ( shapiro0=0.5 ), ihorcon= inter_mom=0 . For applications that include the eddying regime, grid resolution in the eddying regime needs to vary smoothly (Zhang et al. 2016), and the user needs to tweak dissipation carefully. A starting point can be: indvel=ishapiro=inter_mom=0 , ihorcon=2 , hvis_coef0=0.025 . If the amount of dissipation is insufficient in the non-eddying regime, consider using ishapiro=-1 , with an appropriate shapiro.gr3 to turn on Shapiro filter locally to add dissipation, or use ishapiro=2 and shapiro0=1000 .","title":"indvel=0 (int), ihorcon=0 (int), hvis_coef0=0.025 (double), ishapiro=1, niter_shap=1 (int), shapiro0=0.5 (double)"},{"location":"input-output/param.html#inter_mom0-kr_co1-int","text":"Interpolation method at foot of characteristic line during ELM. inter_mom=0 : default linear interpolation; =1 : dual kriging method. If inter_mom=-1 , the depth in krvel.gr3 (0 or 1) will determine the order of interpolation (linear or kriging). If the kriging ELM is used, the general covariance function is specified in kr_co : 1: linear \\(f(h)=-h\\) ; 2: \\((h^2*log(h))\\) ; 3: cubic \\((h^3)\\) ; 4: \\((-h^5)\\) . In general, indvel=0 should be used with inter_mom=0 or inter_mom=1, kr_co=1,2 to avoid large dispersion (with additional viscosity/filter also). indvel=1 can be used with any covariance function without viscosity/filter.","title":"inter_mom=0, kr_co=1 (int)"},{"location":"input-output/param.html#inu_elev0-inu_uv0-int","text":"Sponge layer for elevation and velocity (which is rarely used in SCHISM). Relaxation/nudging of a generic variable is implemented as: \\[\\begin{equation} \\label{eq02} \\widetilde \\varphi = (1-\\gamma)\\varphi + \\gamma\\varphi_{target} \\end{equation}\\] which is a discrete analogue of the restoration equation: \\[\\begin{equation} \\label{eq03} \\frac{\\partial \\varphi}{\\partial t} = \\frac{\\gamma}{\\Delta t} \\left( \\varphi_{target} - \\varphi \\right) \\end{equation}\\] If inu_elev=0 , no relaxation is applied to elevation. If inu_elev=1 , relaxation constants are specified in elev_nudge.gr3 (depth=0 means no relaxation, depth=1 means strongest nudging) and the elevations are relaxed toward 0. Similarly for inu_uv (with input uv_nudge.gr3 ).","title":"inu_elev=0, inu_uv=0 (int)"},{"location":"input-output/param.html#inu_tr0-int-array-nu_sum_multint-step_nu_tr86400-double","text":"Nudging flag for tracer models (e.g. temperature), and nudging step (in sec). When inu_tr=0 , no nudging is done. When inu_tr=1 , relax back to initial conditions. When inu_tr=2 , nudge to values specified in [MOD]_nu.nc , which has a time step of step_nu_tr (in sec). If inu_tr\u22600 , the horizontal relaxation factors are specified in [MOD]_nudge.gr3 (as depths info), and the vertical relaxation factors are specified as a linear function of depths with: vnh[1,2] (transitional depths) and vnf[1,2] (relaxation constants at the 2 depths). The final relaxation constant is either the sum (if nu_sum_mult=1 ) or product (if nu_sum_mult=2 ) of the two, i.e. (horizontal + or * vertical relaxation factors) times dt .","title":"inu_tr(:)=0 (int array), nu_sum_mult(int), step_nu_tr=86400. (double)"},{"location":"input-output/param.html#inunfl0-int","text":"Choice of inundation algorithm. inunfl=1 can be used if the horizontal resolution is fine enough, and this is critical for tsunami simulations. Otherwise use inunfl=0 .","title":"inunfl=0 (int)"},{"location":"input-output/param.html#isav0-int","text":"Parameters for submerged or emergent vegetation. If isav=1 (module on), you need to supply 4 extra inputs: sav_cd.gr3 (form drag coefficient), sav_D.gr3 (depth is stem diameter in meters); sav_N.gr3 (depth is # of stems per m2); and sav_h.gr3 (height of canopy in meters).","title":"isav=0 (int)"},{"location":"input-output/param.html#itr_met3-int-h_tvd5-double","text":"Transport option for all tracers. itr_met=3 for TVD, and itr_met=4 for 3rd order WENO. h_tvd specifies the transition depth (in meters) between upwind and higher-order schemes; i.e. more efficient upwind is used when the local depth < h_tvd . Also in this case, you can additionally toggle between upwind and TVD by specifying regions in tvd.prop . The TVD limiter function is specified in TVD_LIM in mk/include_modules (for code efficiency purpose). If itr_met=3 , 2 tolerances are also required (use recommended values). If itr_met=4 (WENO), there are several additional parameters. The most important ones are epsilon[12] , which controls the numerical dispersion for the 2nd and 3rd-order WENO respectively (note that the code will decide which order is used at each prism based on geometric constraints).","title":"itr_met=3 (int), h_tvd=5. (double)"},{"location":"input-output/param.html#itur0-int","text":"Turbulence closure model selection. If itur=0 , constant diffusivities are used for momentum and transport, and the diffusivities are specified in dfv0 , dfh0 . If itur=-2 , vertically homogeneous but horizontally varying diffusivities are used, which are read in from hvd.mom and hvd.tran . If itur=-1 , horizontally homogeneous but vertically varying diffusivities are used, which are read in from vvd.dat . If itur=2 , the zero-equation Pacanowski and Philander closure is used. In this case, a few extra parameters are required: h1_pp , vdmax_pp1 , vdmin_pp1 , tdmin_pp1 , h2_pp , vdmax_pp2 , vdmin_pp2 , tdmin_pp2 . Eddy viscosity is computed as: \\(\\text{vdiff}=\\text{vdiff_max}/(1+\\text{rich})^2+\\text{vdiff_min}\\) , and diffusivity \\(\\text{tdiff}=\\text{vdiff_max}/(1+\\text{rich})^2+\\text{tdiff_min}\\) , where \\(\\text{rich}\\) is a Richardson number. The limits ( vdiff_max , vdiff_min and tdiff_min ) vary linearly with depth between depths h1_pp and h2_pp . If itur=3 , then the two-equation closure schemes from the GLS model of Umlauf and Burchard (2003) are used. In this case, 2 additional parameters are required: mid , stab , which specify the closure scheme and stability function used: mid= MY is Mellor & Yamada; KL is GLS as k-kl; KE is GLS as \\(k-\\varepsilon\\) ; KW is GLS as \\(k-\\omega\\) ; UB is Umlauf & Burchard's optimal. stab=GA is Galperin's clipping (only for MY); KC is Kantha & Clayson's stability function). Also the user needs to specify max/min diffusivity/viscosity in diffmax.gr3 and diffmin.gr3 , as well as a surface mixing length scale constant xlsc0 . If itur=4 , GOTM turbulence model is invoked; the user needs to turn on pre-processing flag USE_GOTM in makefile and recompile (GOTM5.2 uses cmake, so does not need to be pre-compiled). In this case, the minimum and maximum viscosity/diffusivity are still specified in diffmin.gr3 and diffmax.gr3 . There are some ready-made samples for this input in the source code bundle. A key parameter is the steady state Richardson number. If you wish to tune some parameters inside, you may consult gotm.net for more details. Note GOTM has only been tested up to v5.2, not newer versions of GOTM. Using itur=3 generally gave similar results, but GOTM can produce substantially better stratification in some cases.","title":"itur=0 (int)"},{"location":"input-output/param.html#meth_sink1-int","text":"Option for sinks. If meth_sink =1 , the sink value is reset to 0 if an element is dry with a net sink value locally to prevent further drawdown of groundwater.","title":"meth_sink=1 (int)"},{"location":"input-output/param.html#nadv1-int-dtb_min10-dtb_max30-double","text":"Advection on/off option. If nadv=0 , advection is selectively turned off based on the input file adv.gr3 . If nadv=1 or 2 , advection is on for the whole domain, and backtracking is done using either Euler or 2nd-order Runge-Kutta scheme. dtb_[min,max] are min/max sub-steps allowed in btrack; actual sub-steps are calculated based on local flow gradients.","title":"nadv=1 (int), dtb_min=10, dtb_max=30 (double)"},{"location":"input-output/param.html#nchi0-int","text":"Bottom friction option. If nchi=-1 , and Manning's \\(n\\) is specified in manning.gr3 . If nchi=0 , spatially varying drag coefficients are read in from drag.gr3 (as depth info). For nchi=1 , bottom roughnesses (in meters) are read in from rough.gr3 . If nchi=-1 , an additional parameter is required: hmin_man (in meters) which sets the minimum depth used in the Manning formulation. If nchi=1 , one additional parameter is required: dzb_min (in meters). In this case the drag coefficients are calculated using the log drag law when the bottom cell thickness \\(\\delta_b>=\\text{dzb_min}\\) ; when \\(\\delta_b<\\text{dzb_min}\\) , \\(\\text{Cd}=\\text{Cdmax}\\) , where \\(\\text{Cdmax}=\\text{Cd}(\\delta_b=\\text{dzb_min})\\) . This is to avoid exaggeration of \\(\\text{Cd}\\) in very shallow water.","title":"nchi=0 (int)"},{"location":"input-output/param.html#ncor0-int","text":"Coriolis option. If ncor=0 or -1 , a constant Coriolis parameter is specified. If ncor=0 , coricoef specifies the Coriolis factor. If ncor=-1 , rlatitude specifies the mean latitude used to calculate the Coriolis factor. If ncor=1 , a variable Coriolis parameter, based either on a beta-plane approximation ( ics=1 ) or on the latitude-dependent Coriolis ( ics=2 ), is used, with the lat/lon coordinates read in from hgrid.ll . For ics=1 , the center of beta-plane approximation must be correctly specified in sfea0 .","title":"ncor=0 (int)"},{"location":"input-output/param.html#nws0-int-drampwind1-double-iwind_form1-int-iwindoffint-wtimincdt-double","text":"Wind forcing options and the interval (in seconds) with which the wind input is read in. If nws=0 , no wind is applied (and wtiminc becomes unused). If nws=1 , constant wind is applied to the whole domain at any given time, and the time history of wind is read in from wind.th . If nws=2 , spatially and temporally variable wind is applied and the input consists of a number of netcdf files in the directory sflux/ . The option nws=3 is reserved for coupling with atmospheric model via ESMF caps. If nws=4 , the required input wind.th specifies wind and pressure at each node and at time of multiple of wtiminc . If nws=-1 (requires USE_PAHM), use Holland parametric wind model (barotropic only with wind and atmos. pressure). In this case, the Holland model is called every step so wtiminc is not used. An extra input is needed: hurricane-track.dat . If nws>0 , the ramp-up period (in days) is specified with drampwind . Also the user has the option to scale the wind speed using iwindoff =1 (which requires an additional input windfactor.gr3 ). The wind stress formulation is selected with iwind_form . If nws=2, ihconsv=1 && iwind_form=0 , the stress is calculated from heat exchange routine. If nws=1 or 4 , or nws=2 && ihconsv=0 , or nws=2 && iwind_form\u2260 0 , the stress is calculated from Pond & Pichard formulation (originally from Garret) if iwind_form=-1 , or from Hwang (2018) if iwind_form=1 . If WWM is enabled and icou_elfe_wwm > 0 and iwind_form=-2 , stress is calculated by WWM.","title":"nws=0 (int), drampwind=1. (double), iwind_form=1 (int), iwindoff(int), wtiminc=dt (double)"},{"location":"input-output/param.html#rho01000-shw4184-double","text":"Reference water density for Boussinesq approximation and specific heat of water in J/kg/K.","title":"rho0=1000, shw=4184. (double)"},{"location":"input-output/param.html#rmaxvel10-double","text":"Maximum velocity. This is needed mainly for the air-water exchange as the latter may blow up if the water velocity is above 20m/s.","title":"rmaxvel=10. (double)"},{"location":"input-output/param.html#s1_mxbnt05-s2_mxnbnt35-double","text":"Dimensioning parameters used in inter-subdomain backtracking. Start from s[12]_mxnbt=0.53 , and increase them (gradually) if you get a fatal error like \u201cbtrack: overflow\u201d. Accuracy is not affected by the choice of these two parameters; these only affect memory consumption.","title":"s1_mxbnt=0.5, s2_mxnbnt=3.5 (double)"},{"location":"input-output/param.html#slam0-124-sfea045-double","text":"Centers of projection used to convert lat/lon to Cartesian coordinates. These are used if a variable Coriolis parameter is employed (ncor=1).","title":"slam0=-124, sfea0=45 (double)"},{"location":"input-output/param.html#start_year2000-start_month1-start_day1-int-start_hour0-utc_start8-double","text":"Starting time for simulation. utc_start is hours behind the GMT, and is used to adjust time zone. For example, utc_start=5 is US Eastern Time, and utc_start= -8 is Beijing Time. Note SCHISM's view of the time origin is relatively simple. The code starts from t=0 and marches with time step dt under cold start. It starts from a specified time upon hot start. There are only 2 exceptions: (1) in air-sea exchange ( ihconsv=1 ), the origin info (including utc_start ) specified in these parameters will be compared against the time origins in each sflux file to determine the starting stack; (2) WWM manages its own time origins in wwminput.nml ; it's advisable to align the latter with SCHISM's origin.","title":"start_year=2000, start_month=1, start_day=1 (int), start_hour=0, utc_start=8 (double)"},{"location":"input-output/param.html#thetai06-double","text":"Implicitness parameter (between 0.5 and 1). Recommended value: 0.6. Use '1' to get maximum stability for strong wet/dry.","title":"thetai=0.6 (double)"},{"location":"input-output/param.html#schout-block","text":"","title":"SCHOUT block"},{"location":"input-output/param.html#iout_sta0-nspool_sta10-int","text":"Station output flag. If iout_sta\u22600 , an input station.in is needed. In addition, nspool_sta specifies the spool for station output. In this case, make sure nhot_write is a multiple of nspool_sta .","title":"iout_sta=0, nspool_sta=10 (int)"},{"location":"input-output/param.html#nc_out-1int","text":"Main switch to turn on/off netcdf outputs, useful for other programs (e.g., ESMF) to control outputs.","title":"nc_out =1(int)"},{"location":"input-output/param.html#nhot0-nhot_write8640-int","text":"Hot start output control parameters. If nhot=0 , no hot start output is generated. If nhot=1 , hotstart output is named outputs/hotstart_[process_id]_[it].nc every nhot_write steps, where it is the corresponding time iteration number. nhot_write must be a multiple of ihfskip and nspool_sta . If you want to hotstart a run from step it , you need to combine all process-specific hotstart outputs into a hotstart.nc using combine_hotstart7.f90 ( ./combine_hotstart7 -h for help).","title":"nhot=0, nhot_write=8640 (int)"},{"location":"input-output/param.html#iof_-int","text":"Global output (in netcdf4 format) options, where * stands for module name (e.g. \"hydro\", \"wwm\" etc). The frequency of global outputs is controlled by 2 parameters in CORE : nspool and ihfskip . Output is done every nspool steps, and a new output stack is created every ihfskip steps. Under OLDIO, the outputs are named as outputs/schout_[MPI process id]_[1,2,3,...].nc etc. The combine scripts are then used to gather each output variable across all MPI processes into a single output, e.g., schout_[1,2,3\u2026].nc . With new scribed I/O, outputs look like out2d_1,2,3\u2026].nc etc (and no combining is necessary). In this mode, all 2D outputs are found in out2d* and each 3D output (note that vector output like horizontal velocity counts as 2 outputs) has its own netcdf files, e.g. salinity_[1,2..].nc , horizontalVelX_[1,2..].nc etc. Each output variable is controlled by an I/O flag in param.nml . We only show a few examples below; the rest are similar. Note that variables may be centered at nodes/sides/elements horizontally and whole/half levels vertically. However, at the moment most variables are centered at nodes and whole levels, and most post-processing FORTRAN scripts can only handle this type of outputs (while VisIT can handle other types). iof_hydro(1) = 1 !global elevation output control. If iof_hydro(1)=0, no global elevation is recorded. !If iof_hydro(1)= 1, global elevation for each node is recorded. !The output is either starting from scratch or appended to existing ones depending !on ihot. Some outputs are conditional upon you turn on certain module; e.g. iof_sed(7) = 1 won\u2019t output the bottom depth change unless you turn on USE_SED in makefile. Some \u2018native\u2019 variables (e.g., element- or side-centered) are: iof_hydro(27) = 1 !horizontal velocity defined at side [m/s]. These are the original velocity inside SCHISM","title":"iof_* (int)"},{"location":"input-output/sflux.html","text":"The sflux/ dir is required if nws=2 . In this case, atmoserpic forcings include wind, air pressure and temperature, precipitation, humidity and longwave and shortwave fluxes. These are specified in the netcdf files inside sflux/ dir, and conform to the NetCDF Climate and Forecast (CF) Metadata Convention 1.0. There are 4 types of files in sflux/dir; see this site for sample files. sflux_inputs.txt: This asci file is a namelist sflux_air_1.[XXXX].nc: netcdf files that have time (in days), wind speed at 10m above MSL (u,v), air temperature and pressure and specific humidity; sflux_prc_1.[XXXX].nc: netcdf files that time (in days), have precipitation data; sflux_rad_1.[XXXX].nc: netcdf files that have time (in days), downward long and short (solar) wave radiation fluxes. sflux_input.txt sflux_input.txt has the following basic structure - &sflux_inputs ! file name / All parameters inside this input are optional. Advanced users may consult the source code for a complete list of parameters. Additionally, see sample_input for a detailed example file. sflux_air netcdf sflux_air_1.001 { dimensions: nx_grid = 349 ; ny_grid = 277 ; time = UNLIMITED ; // (8 currently) variables: float time(time) ; time:long_name = \"Time\" ; time:standard_name = \"time\" ; time:units = \"days since 2001-01-01\" ; time:base_date = 2001, 1, 1, 0 ; float lon(ny_grid, nx_grid) ; lon:long_name = \"Longitude\" ; lon:standard_name = \"longitude\" ; lon:units = \"degrees_east\" ; float lat(ny_grid, nx_grid) ; lat:long_name = \"Latitude\" ; lat:standard_name = \"latitude\" ; lat:units = \"degrees_north\" ; float uwind(time, ny_grid, nx_grid) ; uwind:long_name = \"Surface Eastward Air Velocity (10m AGL)\" ; uwind:standard_name = \"eastward_wind\" ; uwind:units = \"m/s\" ; float vwind(time, ny_grid, nx_grid) ; vwind:long_name = \"Surface Northward Air Velocity (10m AGL)\" ; vwind:standard_name = \"northward_wind\" ; vwind:units = \"m/s\" ; float prmsl(time, ny_grid, nx_grid) ; prmsl:long_name = \"Pressure reduced to MSL\" ; prmsl:standard_name = \"air_pressure_at_sea_level\" ; prmsl:units = \"Pa\" ; float stmp(time, ny_grid, nx_grid) ; stmp:long_name = \"Surface Air Temperature (2m AGL)\" ; stmp:standard_name = \"air_temperature\" ; stmp:units = \"K\" ; float spfh(time, ny_grid, nx_grid) ; spfh:long_name = \"Surface Specific Humidity (2m AGL)\" ; spfh:standard_name = \"specific_humidity\" ; spfh:units = \"1\" ; // global attributes: :Conventions = \"CF-1.0\" ; } sflux_prc netcdf sflux_prc_1.001 { dimensions: nx_grid = 349 ; ny_grid = 277 ; time = UNLIMITED ; // (8 currently) variables: float time(time) ; time:long_name = \"Time\" ; time:standard_name = \"time\" ; time:units = \"days since 2001-01-01\" ; time:base_date = 2001, 1, 1, 0 ; float lon(ny_grid, nx_grid) ; lon:long_name = \"Longitude\" ; lon:standard_name = \"longitude\" ; lon:units = \"degrees_east\" ; float lat(ny_grid, nx_grid) ; lat:long_name = \"Latitude\" ; lat:standard_name = \"latitude\" ; lat:units = \"degrees_north\" ; float prate(time, ny_grid, nx_grid) ; prate:long_name = \"Surface Precipitation Rate\" ; prate:standard_name = \"precipitation_flux\" ; prate:units = \"kg/m^2/s\" ; // global attributes: :Conventions = \"CF-1.0\" ; } sflux_rad netcdf sflux_rad_1.001 { dimensions: nx_grid = 349 ; ny_grid = 277 ; time = UNLIMITED ; // (8 currently) variables: float time(time) ; time:long_name = \"Time\" ; time:standard_name = \"time\" ; time:units = \"days since 2001-01-01\" ; time:base_date = 2001, 1, 1, 0 ; float lon(ny_grid, nx_grid) ; lon:long_name = \"Longitude\" ; lon:standard_name = \"longitude\" ; lon:units = \"degrees_east\" ; float lat(ny_grid, nx_grid) ; lat:long_name = \"Latitude\" ; lat:standard_name = \"latitude\" ; lat:units = \"degrees_north\" ; float dlwrf(time, ny_grid, nx_grid) ; dlwrf:long_name = \"Downward Long Wave Radiation Flux\" ; dlwrf:standard_name = \"surface_downwelling_longwave_flux_in_air\" ; dlwrf:units = \"W/m^2\" ; float dswrf(time, ny_grid, nx_grid) ; dswrf:long_name = \"Downward Short Wave Radiation Flux\" ; dswrf:standard_name = \"surface_downwelling_shortwave_flux_in_air\" ; dswrf:units = \"W/m^2\" ; // global attributes: :Conventions = \"CF-1.0\" ; } Note that sflux_rad is only required if the heat exchange module is invoked via ihconsv=1 , and sflux_prc is only required if the salt exchange module is invoked via isconsv=1 . Since a barotropic model cannot do heat/salt exchange properly, these two types of sflux inputs should not be used there. To impose rainfall in a barotropic model, you have to use the source/sink option if_source by converting rainfall rate into sources. We have NARR sflux files from 1979-present, but cannot upload all of them to the web due to disk space limitation. You can find some samples at http://ccrm.vims.edu/yinglong/wiki_files/NARR/ . Two sources of data are allowed for each type of .nc files, and the relative priority is fixed by the file name. For instance sflux_air_1.0003.nc might be blended with a file called sflux_air_2.0003.nc . The \".0003\" component of the name represents the order of the file within the stack of provided input files. For instance, there might be a new file ( 0001 , 0002 , 0003 ) produced every 12 hours in a forecast cycle. Interpolation and prioritization \u00b6 Using air as an example, it is assumed that the file sflux_air_2.0001.nc is more resolved or accurate than sflux_air_1.0001.nc. The two will be blended in the model in a way that favors the \u2018_2\u2019 file. This blending of the fields is only adjustable in the code as described in notes below. The default in sflux_9c.F90 is a 99:1 blend of the \u2018_2\u2019 file to the \u2018_1\u2019 file. As was remarked above, the files are arranged temporally in a stack of files starting with \".0001\". Given the sequence of forecasting and analysis, it is common for atmospheric files to overlap. A file might begin with a brief period of data assimilation plus a few days of forecast. SCHISM assumes that a new file indicates the injection of information, so when it encounters overlap, it advances to the later file. Using NARR files for your simulation (North America only) \u00b6 First, make sure the NARR grid covers your hgrid.ll to ensure proper sptatial interpolation. In your run directory, mkdir sflux and inside it, create symbolic links to the NARR files. e.g., if you run starts from June 10, 2004 and ends June 20, 2004, then sflux_air_1.0001.nc --> narr_air.2004_06_10.nc sflux_air_1.0002.nc --> narr_air.2004_06_11.nc ... sflux_air_1.0011.nc --> narr_air.2004_06_20.nc sflux_air_1.0012.nc --> narr_air.2004_06_21.nc # (extra day to account for time zone difference) Similarly for sflux_rad_*.nc and sflux_prc_*.nc . As described above, the number \"1\" after \"air_\" denotes the first data set used, with the second set taking priority; you can use up to 2 sets in SCHISM (which combines them with some given weights set in sflux_subs.F90); we only use 1 set in this example. Global sflux - NCEP CFSR \u00b6 This web site has many global atmospheric model files, and a very useful source is the NCEP's CFSR. Note that you need to register yourself at the site first. Simply select 'NCEP Climate Forecast System Reanalysis (CFSR)', and then CFSRv2. Under 'Data Access' you can get a sub-set (instead of global files). Then select all variable required by SCHISM: Wind u,v at 10m (Air) pressure reduced to MSL (Air) temperature at 2m AGL Specific humidity at 2m AGL Downward longwave radiation flux at ground level Downward shortwave radiation flux at ground level Precipitation rate at ground level In the new window, select output format as netcdf, and remember to restrict the vertical heights for each variable. Note that pressure is given at a different grid than other variables and so you'd do it separately. You can select a region and computational grid and temporal resolution etc and then submit the request. Once you have downloaded the (compressed) netcdf files, you can use these 3 matlab scripts to process them into sflux_[air,rad,prc]*.nc . Note that the files are bundled differently for difference period (e.g. before and after Oct. 1, 2011) and so you may need to modify those scripts slightly. Preparing your own sflux inputs \u00b6 After familiarize yourself with the NARR files and their format, you may embark on creating your own nc files. The best way is to modify existing matlab scripts ( src/Utility/Sflux_nc/readnc*.m ) included in the source code bundle, which have extensively in-line comments to guide you along the way. Since the time and space interpolation will be used to interpolate sflux info onto hgrid.ll at runtime, you need to make sure that the lon/lat grid in sflux_*_1.* covers hgrid.ll , and the union of time records in sflux*.nc covers the entire simulation period. The time zone info is given by utc_start , and you may pre-pend some records if this value is negative (eastern hemisphere) or append if it is positive. Even if utc_start=0 , the code will need at least one time record beyond rnday for interpolation; simply duplicate the record at rnday if you do not have such info. Wind convention u-component is eastward, v-comp. is northward (normal math convention, not compass convention) Additional files windrot_geo2proj.gr3 : rotates winds in case they do not align with coordinate axes, i.e. lat/lon Some details from sflux_9c.F90 Of all attributes in nc file, only 'base_date' is required. This is the time origin used in each file and the \u2018time\u2019 is then the offset (in days) from this origin. Note that the last number (hour) is NOT used and UTC is always assumed in each file. Use utc_start in param.nml to adjust time zone; The grids for air, rad and prc can be different (but must be the same within each type and each source). Additional requirements for the structured grid in .nc: lon,lat give x,y coord., nx is # of pts in x. Suppose a node in the grid is given by (i,j) (1<=i<=nx), then the quad (i,j), (i+1,j), (i+1,j+1,i,j+1) can be in either counter-clockwise or clockwise direction (but must be self consistent within each set - no mix-and-match) ; Search for \"relative_weight\" (inside netcdf_io ) to change relative weights of the 2 sources for air, rad and prc if needed. All weights must > 0! in case of 2 sources/grids for a variable, use \"1\" as larger grid (i.e. encompassing hgrid.ll) and \"2\" as smaller grid. The code will calculate weights associated with the 2 grids, and if some nodes in hgrid.ll fall outside grid \"2\" the interpolation will be done on grid \"1\" only (see combine_sflux_data, in particular, bad_node_ based on area coordinates outside [0,1]). Both grids must start from stack 1 but may have different # of stacks for each variable. Within each nc file # of time steps can vary. The cumulative time window of '2' does not need to cover the entire simulation (code will use values from '1' only if '2' time is missing), but window of '1' must; air_1_max_window_hours (etc) are set in netcdf_io to define the max time stamp (offset from time origin) within each nc file. Besides those in netcdf_io, max_file_times (max. #of time records in each nc file) in routine get_times_etc() may need to be adjusted as well.","title":"Atmospheric flux (/sflux)"},{"location":"input-output/sflux.html#interpolation-and-prioritization","text":"Using air as an example, it is assumed that the file sflux_air_2.0001.nc is more resolved or accurate than sflux_air_1.0001.nc. The two will be blended in the model in a way that favors the \u2018_2\u2019 file. This blending of the fields is only adjustable in the code as described in notes below. The default in sflux_9c.F90 is a 99:1 blend of the \u2018_2\u2019 file to the \u2018_1\u2019 file. As was remarked above, the files are arranged temporally in a stack of files starting with \".0001\". Given the sequence of forecasting and analysis, it is common for atmospheric files to overlap. A file might begin with a brief period of data assimilation plus a few days of forecast. SCHISM assumes that a new file indicates the injection of information, so when it encounters overlap, it advances to the later file.","title":"Interpolation and prioritization"},{"location":"input-output/sflux.html#using-narr-files-for-your-simulation-north-america-only","text":"First, make sure the NARR grid covers your hgrid.ll to ensure proper sptatial interpolation. In your run directory, mkdir sflux and inside it, create symbolic links to the NARR files. e.g., if you run starts from June 10, 2004 and ends June 20, 2004, then sflux_air_1.0001.nc --> narr_air.2004_06_10.nc sflux_air_1.0002.nc --> narr_air.2004_06_11.nc ... sflux_air_1.0011.nc --> narr_air.2004_06_20.nc sflux_air_1.0012.nc --> narr_air.2004_06_21.nc # (extra day to account for time zone difference) Similarly for sflux_rad_*.nc and sflux_prc_*.nc . As described above, the number \"1\" after \"air_\" denotes the first data set used, with the second set taking priority; you can use up to 2 sets in SCHISM (which combines them with some given weights set in sflux_subs.F90); we only use 1 set in this example.","title":"Using NARR files for your simulation (North America only)"},{"location":"input-output/sflux.html#global-sflux-ncep-cfsr","text":"This web site has many global atmospheric model files, and a very useful source is the NCEP's CFSR. Note that you need to register yourself at the site first. Simply select 'NCEP Climate Forecast System Reanalysis (CFSR)', and then CFSRv2. Under 'Data Access' you can get a sub-set (instead of global files). Then select all variable required by SCHISM: Wind u,v at 10m (Air) pressure reduced to MSL (Air) temperature at 2m AGL Specific humidity at 2m AGL Downward longwave radiation flux at ground level Downward shortwave radiation flux at ground level Precipitation rate at ground level In the new window, select output format as netcdf, and remember to restrict the vertical heights for each variable. Note that pressure is given at a different grid than other variables and so you'd do it separately. You can select a region and computational grid and temporal resolution etc and then submit the request. Once you have downloaded the (compressed) netcdf files, you can use these 3 matlab scripts to process them into sflux_[air,rad,prc]*.nc . Note that the files are bundled differently for difference period (e.g. before and after Oct. 1, 2011) and so you may need to modify those scripts slightly.","title":"Global sflux - NCEP CFSR"},{"location":"input-output/sflux.html#preparing-your-own-sflux-inputs","text":"After familiarize yourself with the NARR files and their format, you may embark on creating your own nc files. The best way is to modify existing matlab scripts ( src/Utility/Sflux_nc/readnc*.m ) included in the source code bundle, which have extensively in-line comments to guide you along the way. Since the time and space interpolation will be used to interpolate sflux info onto hgrid.ll at runtime, you need to make sure that the lon/lat grid in sflux_*_1.* covers hgrid.ll , and the union of time records in sflux*.nc covers the entire simulation period. The time zone info is given by utc_start , and you may pre-pend some records if this value is negative (eastern hemisphere) or append if it is positive. Even if utc_start=0 , the code will need at least one time record beyond rnday for interpolation; simply duplicate the record at rnday if you do not have such info. Wind convention u-component is eastward, v-comp. is northward (normal math convention, not compass convention) Additional files windrot_geo2proj.gr3 : rotates winds in case they do not align with coordinate axes, i.e. lat/lon Some details from sflux_9c.F90 Of all attributes in nc file, only 'base_date' is required. This is the time origin used in each file and the \u2018time\u2019 is then the offset (in days) from this origin. Note that the last number (hour) is NOT used and UTC is always assumed in each file. Use utc_start in param.nml to adjust time zone; The grids for air, rad and prc can be different (but must be the same within each type and each source). Additional requirements for the structured grid in .nc: lon,lat give x,y coord., nx is # of pts in x. Suppose a node in the grid is given by (i,j) (1<=i<=nx), then the quad (i,j), (i+1,j), (i+1,j+1,i,j+1) can be in either counter-clockwise or clockwise direction (but must be self consistent within each set - no mix-and-match) ; Search for \"relative_weight\" (inside netcdf_io ) to change relative weights of the 2 sources for air, rad and prc if needed. All weights must > 0! in case of 2 sources/grids for a variable, use \"1\" as larger grid (i.e. encompassing hgrid.ll) and \"2\" as smaller grid. The code will calculate weights associated with the 2 grids, and if some nodes in hgrid.ll fall outside grid \"2\" the interpolation will be done on grid \"1\" only (see combine_sflux_data, in particular, bad_node_ based on area coordinates outside [0,1]). Both grids must start from stack 1 but may have different # of stacks for each variable. Within each nc file # of time steps can vary. The cumulative time window of '2' does not need to cover the entire simulation (code will use values from '1' only if '2' time is missing), but window of '1' must; air_1_max_window_hours (etc) are set in netcdf_io to define the max time stamp (offset from time origin) within each nc file. Besides those in netcdf_io, max_file_times (max. #of time records in each nc file) in routine get_times_etc() may need to be adjusted as well.","title":"Preparing your own sflux inputs"},{"location":"input-output/vgrid.html","text":"See Numetical Formulation chapter for details of different types of vgrid supported in SCHISM. Following are a few example vgrid.in . An example of SZ grid \u00b6 2 !ivcor (1: LSC2; 2: SZ) 54 18 100. !nvrt(=Nz); kz (# of Z-levels); hs (transition depth between S and Z) Z levels !Z-levels in the lower portion 1 -5000. !level index, z-coordinates 2 -2300. 3 -1800. 4 -1400. 5 -1000. 6 -770. 7 -570. 8 -470. 9 -390. 10 -340. 11 -290. 12 -240. 13 -190. 14 -140. 15 -120. 16 -110. 17 -105. 18 -100. !z-coordinate of the last Z-level must match -h_s S levels !S-levels below 30. 0.7 10. ! constants used in S-transformation: hc, theta_b, theta_f 18 -1. !first S-level (sigma-coordinate must be -1) 19 -0.972222 !levels index, sigma-coordinate 20 -0.944444 . . . 54 0. !last sigma-coordinate must be 0 Notes: - The water column is from the bottom ( kbp , variable in space) to surface (level nvrt ) at each node; - The code will crash if the surface elevation falls below \\(\u2013h_c\\) so make sure \\(h_c\\) is sufficiently large (there is a hardwired lower bound for this around 5m in the code). An example of pure S grid \u00b6 If a \"pure S\" model is desired, use only 1 Z-level and set hs to a very large number (e.g., 1.e6) above. For example, using vgrid.in below leads to a 2D model. 2 !ivcor 2 1 1.e6 Z levels 1 -1.e6 S levels 40. 1. 1.e-4 1 -1. 2 0. An example of \\(LSC^2\\) grid \u00b6 This type of grid requires some user experience and can be generated using scripts (e.g., Utility/Pre-Processing/gen_vqs*.f90 ). There is no limit such as \\(h_c\\) mentioned above, so \\(LSC^2\\) is more robust. 1 !ivcor (1: LSC2; 2: SZ) 39 !nvrt(=Nz) 10 4 4 4 4 10 4 10 10 ... !bottom level indces at all nodes 1 -1. -1. -1. -1. -9. -9. -9. ... !level #, sigma coordinates $\\in [-1,0]$ at level 1 for all nodes. '-9' means level 1 is below the bottom of this node 2 -0.884251 -0.874424 -0.888763 -0.884930 -1. ...","title":"Vertical grid (vgrid.in)"},{"location":"input-output/vgrid.html#an-example-of-sz-grid","text":"2 !ivcor (1: LSC2; 2: SZ) 54 18 100. !nvrt(=Nz); kz (# of Z-levels); hs (transition depth between S and Z) Z levels !Z-levels in the lower portion 1 -5000. !level index, z-coordinates 2 -2300. 3 -1800. 4 -1400. 5 -1000. 6 -770. 7 -570. 8 -470. 9 -390. 10 -340. 11 -290. 12 -240. 13 -190. 14 -140. 15 -120. 16 -110. 17 -105. 18 -100. !z-coordinate of the last Z-level must match -h_s S levels !S-levels below 30. 0.7 10. ! constants used in S-transformation: hc, theta_b, theta_f 18 -1. !first S-level (sigma-coordinate must be -1) 19 -0.972222 !levels index, sigma-coordinate 20 -0.944444 . . . 54 0. !last sigma-coordinate must be 0 Notes: - The water column is from the bottom ( kbp , variable in space) to surface (level nvrt ) at each node; - The code will crash if the surface elevation falls below \\(\u2013h_c\\) so make sure \\(h_c\\) is sufficiently large (there is a hardwired lower bound for this around 5m in the code).","title":"An example of SZ grid"},{"location":"input-output/vgrid.html#an-example-of-pure-s-grid","text":"If a \"pure S\" model is desired, use only 1 Z-level and set hs to a very large number (e.g., 1.e6) above. For example, using vgrid.in below leads to a 2D model. 2 !ivcor 2 1 1.e6 Z levels 1 -1.e6 S levels 40. 1. 1.e-4 1 -1. 2 0.","title":"An example of pure S grid"},{"location":"input-output/vgrid.html#an-example-of-lsc2-grid","text":"This type of grid requires some user experience and can be generated using scripts (e.g., Utility/Pre-Processing/gen_vqs*.f90 ). There is no limit such as \\(h_c\\) mentioned above, so \\(LSC^2\\) is more robust. 1 !ivcor (1: LSC2; 2: SZ) 39 !nvrt(=Nz) 10 4 4 4 4 10 4 10 10 ... !bottom level indces at all nodes 1 -1. -1. -1. -1. -9. -9. -9. ... !level #, sigma coordinates $\\in [-1,0]$ at level 1 for all nodes. '-9' means level 1 is below the bottom of this node 2 -0.884251 -0.874424 -0.888763 -0.884930 -1. ...","title":"An example of \\(LSC^2\\) grid"},{"location":"mesh-generation/cross_regime.html","text":"Mesh generation is most challenging in applications that include eddying (open deep ocean), non-eddying, and the transitional regimes between the previous two regimes. The challenge here is mostly related to the different physics requirements rather than numerics between eddying and non-eddying regimes. Danilov & Wang (2015) demonstrated that the mesh in the eddying regime should vary smoothly to not distort eddying processes. This is understandable also because the bathymetric variations in the deep ocean do not play as an important role as in non-eddying regime, so there is no compelling reason to drastically vary mesh resolution there. One common mistake users make is to over-refine in eddying and transitional regimes. This actually violate the hydrostatic assumption (the horizontal scale >> vertical scale). For example, setting mesh resolution at 500m at 500m depth would likely lead to spurious 'upwelling' (Figure 2 ). To get a good SCHISM baroclinic setup for this type of applications, one needs to pay attention to Horizontal mesh Vertical grid: use \\(\\text{LSC}^2\\) , and at least resolve the surface layer Parameterization: especially important are parameters that control momentum dissipation ( indvel , ihorcon , ishapiro , dt ) The example of South China Sea (SCS) shown below illustrates this type of mistakes made by users (Figure 1 ). A particularly severe challenge is a transitional regime (between eddying and non-eddying regimes) with steep slopes that tend to excite parasitic noises (if the mesh resolution is too fine), and a common symptom for this manifests itself as spurious upwelling of cold water (Figure 2 ). (a) \u2018Wrong\u2019 map for SCS, showing multiple issues with grid design. Steep slopes are prevalent in this region, near small islands and continental shelf breaks. (b) grid near Spratly, showing excessively high resolution in deep water (0.01 degree ~ 1 km). Surface temperature (SST) resulted from the grid generated from Figure 1, showing the excessive spurious upwelling of cold water. For meshgen, always start with modest and quasi-uniform resolution for eddying regime. In SMS, this can be achieved with fewer constraints in the form of arcs. High resolution (<=2km) in deep water (h>=1km) should be avoided (Figure 1 ). At steep slopes, this means that an \u2018outer arc\u2019 (in SMS map) may be needed. With the corrected mesh, the noise is greatly reduced: the remaining noise in southern Philippines can be rectified by adding outer arcs there (Figure 4 ). A corrected SMS map file. Outer arcs are added near shelf break of west coast of Luzon and Spratly Islands, but are missing in the southern Philippines. SST calculated from the corrected grid. The remaining \u2018upwelling\u2019 in the circled area is due to the missing outer arcs in that area (cf. Figure 3). Parameters dt=100s (slightly larger values like 120 s should also work), indvel=0 , ihorcon=2 , ishapiro= -1 . shapiro.gr3 is then generated using gen_slope_filter2.f90 by using larger filter strengths near steep slopes (and small elsewhere). Figure 5a shows the resultant input. In general, the momentum needs to be stabilized with larger viscosity near steep slopes, as bi-harmonic viscosity alone is not sufficient there. Other pre-processing is same as before: the I.C. and B.C. can be derived from HYCOM and FES 2014 (i.e. use type \u20185\u2019 for both elevation and velocity B.C.). In addition, tracers are relaxed to HYCOM values near open boundaries (Figure 5b ). Required pro-processing scripts can be found in Utility/ . Starting from v5.9, users can also try the new Smagorinsky\u2013like filter option ( ishapiro=2 ) with a proper shapiro0 . (a) Filter strength input (shapiro.gr3). Larger values are used near steep slopes. (b) Nudging strength input (TEM_nudge.gr3, SAL_nudge.gr3), generated from gen_slope_filter2.f90, with maximum time scale of 1 day. The meshing challenge is particularly acute when one deals with islands sitting on top of steep slopes. Figure 6 shows 3 attempts to add high resolution near Guam in the Pacific basin mesh. The mesh resolution in the surrounding deep ocean is about 5km, and we need to refine the mesh to about 30m around Guam. The Apra Harbor jetty that requires higher resolution happens to be located close to a steep slope. Combination of wet/dry and forced sharp transition in \u2018new14\u2019 and \u2018new15\u2019 led to spread of upwelled water there. Removing an inner arc in \u2018new15\u2019 helped smoother transition from the outer arc to the inner arc and thus alleviated the upwelling issue. In \u2018new16\u2019, we made more \u2018room\u2019 for transition by moving the inner arc away from the outer arc and coarsening it a little (to match the resolution of the outer arc), thus further reducing the upwelling. However, we had to add more internal arcs to provide adequate resolution nearshore (otherwise the nearshore area would be represented by a few skew elements that have side lengths of a few km\u2019s on the outside and 30m on the inside). Figure 7 shows the details of \u2018new16\u2019 and final mesh. Note that in all three maps, we used 500m isobaths for the outer arc (as representation of start of eddying regime) but the arc veered to 1km isobaths near the harbor as a way to make more room for transition there. Three SMS maps (top) and corresponding results for SST. Details for map \u2018new16\u2019 and the final mesh around Apra Harbor. Skew elements nearshore are fine. Sub-mesoscale If sub-mesoscale processes are of interest, one may need to reduce time step below 100 sec or apply some special parameterization such as niter_shap etc. References \u00b6 Danilov, Sergey & Wang, Qiang. (2015). Resolving eddies by local mesh refinement. Ocean Modelling. 93. 10.1016/j.ocemod.2015.07.006.","title":"Meshing for cross-scale regimes"},{"location":"mesh-generation/cross_regime.html#references","text":"Danilov, Sergey & Wang, Qiang. (2015). Resolving eddies by local mesh refinement. Ocean Modelling. 93. 10.1016/j.ocemod.2015.07.006.","title":"References"},{"location":"mesh-generation/overview.html","text":"This chapter discusses best practice of mesh generation for complex projects and provides tutorials for different mesh generation tools/procedures.","title":"Overview"},{"location":"mesh-generation/meshing-for-compound-floods/extract-thalweg.html","text":"Background \u00b6 Extracting channel networks from grid digital elevation models (DEMs) follows these precedures: (1) fill depressions/sinks in the original DEM; (2) calcuate flow direction and flow accumulation based on eight-direciton method (D8); (3) determine the flow accumulation threshold to derive a digital stream network. Flow accumulation threshold is a parameter that identifies grids with flow accumulation greater than the threshold as a stream network. It varies with DEM resolution, raster size and geomorphic complexity. The optimal threshold is a trial and error based on user's goal. The smaller threhold will generate denser network. Below are river network extracted with three different threshold: 1e5, 1e6, and 1e7, respectively: Scripts \u00b6 pyDEM can be downloaded from the RiverMeshTools repository . Dependencies \u00b6 numpy GDAL geopandas shapely richdem Workflow \u00b6 Pre-processing DEM (optional) 1.1 Split large files Sometimes, it is necessary to split large tif files into smaller ones to avoid memory issues. Script split2tiles.py serves for this purpose: import os , sys from osgeo import gdal dset = gdal . Open ( sys . argv [ 1 ]) width = dset . RasterXSize height = dset . RasterYSize tilesize = 8100 for i in range ( 0 , width , tilesize ): for j in range ( 0 , height , tilesize ): w = min ( i + tilesize , width ) - i h = min ( j + tilesize , height ) - j gdaltranString = \"gdal_translate -ot Float32 -of GTIFF -srcwin \" + str ( i ) + \", \" + str ( j ) + \", \" + str ( w ) + \", \" \\ + str ( h ) + \" \" + sys . argv [ 1 ] + \" \" + sys . argv [ 2 ] + \"_\" + str ( i ) + \"_\" + str ( j ) + \".tif\" os . system ( gdaltranString ) Run the script with this command: python split2tiles.py japan_dem_with_ocean.tif tiles/japan_tile Create tileindex shapefile, which will be used in the next step: gdaltindex tileindex_japan_dem.shp tiles/*.tif 1.2 Merge tiles This process is needed when Each tile and its 8-connected rasters are mereged into one raster file, which will be used in the next step. import subprocess import multiprocessing as mp import numpy as np import geopandas as gpd from osgeo import gdal def merge_tiles ( itile , df , maps , locations ): dx = [ - 8100 , 0 , 8100 , - 8100 , 0 , 8100 , - 8100 , 0 , 8100 ] dy = [ - 8100 , - 8100 , - 8100 , 0 , 0 , 0 , 8100 , 8100 , 8100 ] ullon , ullat = int ( df . location . split ( '_' )[ 2 ]), int ( df . location . split ( '_' )[ 3 ] . split ( '.' )[ 0 ]) tiles = [] for j in np . arange ( 9 ): try : ilon = ullon + dx [ j ] ilat = ullat + dy [ j ] key2 = f ' { ilon } _ { ilat } ' tile_idx = tilemaps [ key2 ] tiles . append ( locations [ tile_idx ]) except : print ( f 'No tile' ) cmd = f 'gdal_merge.py -n -9999 -o Merged/JAPAN_merged_ { str ( itile ) . zfill ( 3 ) } .tif' subprocess . call ( cmd . split () + tiles ) if __name__ == '__main__' : gdf = gpd . read_file ( 'tileindex_japan_dem.shp' ) tilemaps = dict () for i , p in enumerate ( gdf [ 'location' ]): x = gdf . iloc [ i ] . location . split ( '_' )[ 2 ] y = gdf . iloc [ i ] . location . split ( '_' )[ 3 ] . split ( '.' )[ 0 ] key = f ' { x } _ { y } ' tilemaps [ key ] = i npool = 15 pool = mp . Pool ( npool ) pool . starmap ( merge_tiles , [( i , gdf . iloc [ i ], tilemaps , gdf [ 'location' ]) for i in np . arange ( len ( gdf ))]) pool . close () del pool Extract channel networks Extracting channel networks consists of three steps: Fill or breach depressions Algorithm \"Priority-Flood + \\(\\epsilon\\) \" ( Barnes et al., 2014 ) is used to fill depressions. Calculate flow directions based on the given flow coordinate system. In pyDEM, flow directions use a D8 flow coordinate system that appears as follow: D8 flow coordinate system consisted of 9 raster cells. The numbers are local indices that correpond to each neighbor of the center cell. Calculate flow accumulation Flow accumulation is the total number of cells passing through each (raster) cell. With flow accumulations, we can apply a presccribed threshold to determine which cells should be included in the final digital stream network. The details of the algorithm can be found in Ye et al. (2023) . Sample applications \u00b6 Two example applications can be found under subdirectories from pyDEM_Samples.tar . The subdirectory \"Serial\" contains a Python script run_serial.py and an input file tiff/Savannah_river.tif . This can be used for a small domain. The script reads: import glob import time from pylib import * from pyDEM.dem import * import numpy as np np . seterr ( all = 'raise' ) if __name__ == '__main__' : #input tiff files files = glob . glob ( 'tiff/Savannah_river.tif' ) files . sort () acc_limit = 1e7 t0 = time . time () for fname in files : names = [ fname ] #output filename sname = f \"./ { fname . split ( '.' )[ 0 ] . split ( '/' )[ - 1 ] } _ { acc_limit } \" print ( sname ) #declare a dem object S = dem () #read data if not os . path . exists ( ' {} .npz' . format ( sname )): S . proc_demfile ( names , sname = sname , depth_limit = [ - 100 , 1000 ], subdomain_size = 2e10 ) S . read_data ( ' {} .npz' . format ( sname )) #compuate watershed information S . compute_watershed () #extract river network (area_limit: catchment area) S . compute_river ( acc_limit = acc_limit ) #write shapefile for river network gdf = S . write_shapefile ( npt_smooth = None ) gdf . to_file ( f ' { sname } .shp' ) print ( f 'It took { ( time . time () - t0 ) / 60 } mins!' ) For a large domain, a parallel dirver is preferred to speed up the process. A sample script is under Parallel/, named run_mpi_vortex.py , which can run with multiple nodes/cpus with mpi4py . References C. Barnes, R., Lehman, C., Mulla (2014). Priority-flood: An optimal depression-filling and watershed-labeling algorithm for digital elevation models. Computers & Geosciences 62, 117\u2013127. doi:10.1016/j.cageo.2013.04.024. Barnes, Richard. 2016. RichDEM: Terrain Analysis Software. http://github.com/r-barnes/richdem. Ye, F., Cui, L., Zhang, Y., Wang, Z., Moghimi, S., Myers, E., Seroka, G., Zundel, A., Mani, S., Kelley, J.G.W. A parallel Python-based tool for meshing watershed rivers at continental scale, Environmental Modelling & Software, 166. https://doi.org/10.1016/j.envsoft.2023.105731.","title":"Extract thalwegs"},{"location":"mesh-generation/meshing-for-compound-floods/extract-thalweg.html#background","text":"Extracting channel networks from grid digital elevation models (DEMs) follows these precedures: (1) fill depressions/sinks in the original DEM; (2) calcuate flow direction and flow accumulation based on eight-direciton method (D8); (3) determine the flow accumulation threshold to derive a digital stream network. Flow accumulation threshold is a parameter that identifies grids with flow accumulation greater than the threshold as a stream network. It varies with DEM resolution, raster size and geomorphic complexity. The optimal threshold is a trial and error based on user's goal. The smaller threhold will generate denser network. Below are river network extracted with three different threshold: 1e5, 1e6, and 1e7, respectively:","title":"Background"},{"location":"mesh-generation/meshing-for-compound-floods/extract-thalweg.html#scripts","text":"pyDEM can be downloaded from the RiverMeshTools repository .","title":"Scripts"},{"location":"mesh-generation/meshing-for-compound-floods/extract-thalweg.html#dependencies","text":"numpy GDAL geopandas shapely richdem","title":"Dependencies"},{"location":"mesh-generation/meshing-for-compound-floods/extract-thalweg.html#workflow","text":"Pre-processing DEM (optional) 1.1 Split large files Sometimes, it is necessary to split large tif files into smaller ones to avoid memory issues. Script split2tiles.py serves for this purpose: import os , sys from osgeo import gdal dset = gdal . Open ( sys . argv [ 1 ]) width = dset . RasterXSize height = dset . RasterYSize tilesize = 8100 for i in range ( 0 , width , tilesize ): for j in range ( 0 , height , tilesize ): w = min ( i + tilesize , width ) - i h = min ( j + tilesize , height ) - j gdaltranString = \"gdal_translate -ot Float32 -of GTIFF -srcwin \" + str ( i ) + \", \" + str ( j ) + \", \" + str ( w ) + \", \" \\ + str ( h ) + \" \" + sys . argv [ 1 ] + \" \" + sys . argv [ 2 ] + \"_\" + str ( i ) + \"_\" + str ( j ) + \".tif\" os . system ( gdaltranString ) Run the script with this command: python split2tiles.py japan_dem_with_ocean.tif tiles/japan_tile Create tileindex shapefile, which will be used in the next step: gdaltindex tileindex_japan_dem.shp tiles/*.tif 1.2 Merge tiles This process is needed when Each tile and its 8-connected rasters are mereged into one raster file, which will be used in the next step. import subprocess import multiprocessing as mp import numpy as np import geopandas as gpd from osgeo import gdal def merge_tiles ( itile , df , maps , locations ): dx = [ - 8100 , 0 , 8100 , - 8100 , 0 , 8100 , - 8100 , 0 , 8100 ] dy = [ - 8100 , - 8100 , - 8100 , 0 , 0 , 0 , 8100 , 8100 , 8100 ] ullon , ullat = int ( df . location . split ( '_' )[ 2 ]), int ( df . location . split ( '_' )[ 3 ] . split ( '.' )[ 0 ]) tiles = [] for j in np . arange ( 9 ): try : ilon = ullon + dx [ j ] ilat = ullat + dy [ j ] key2 = f ' { ilon } _ { ilat } ' tile_idx = tilemaps [ key2 ] tiles . append ( locations [ tile_idx ]) except : print ( f 'No tile' ) cmd = f 'gdal_merge.py -n -9999 -o Merged/JAPAN_merged_ { str ( itile ) . zfill ( 3 ) } .tif' subprocess . call ( cmd . split () + tiles ) if __name__ == '__main__' : gdf = gpd . read_file ( 'tileindex_japan_dem.shp' ) tilemaps = dict () for i , p in enumerate ( gdf [ 'location' ]): x = gdf . iloc [ i ] . location . split ( '_' )[ 2 ] y = gdf . iloc [ i ] . location . split ( '_' )[ 3 ] . split ( '.' )[ 0 ] key = f ' { x } _ { y } ' tilemaps [ key ] = i npool = 15 pool = mp . Pool ( npool ) pool . starmap ( merge_tiles , [( i , gdf . iloc [ i ], tilemaps , gdf [ 'location' ]) for i in np . arange ( len ( gdf ))]) pool . close () del pool Extract channel networks Extracting channel networks consists of three steps: Fill or breach depressions Algorithm \"Priority-Flood + \\(\\epsilon\\) \" ( Barnes et al., 2014 ) is used to fill depressions. Calculate flow directions based on the given flow coordinate system. In pyDEM, flow directions use a D8 flow coordinate system that appears as follow: D8 flow coordinate system consisted of 9 raster cells. The numbers are local indices that correpond to each neighbor of the center cell. Calculate flow accumulation Flow accumulation is the total number of cells passing through each (raster) cell. With flow accumulations, we can apply a presccribed threshold to determine which cells should be included in the final digital stream network. The details of the algorithm can be found in Ye et al. (2023) .","title":"Workflow"},{"location":"mesh-generation/meshing-for-compound-floods/extract-thalweg.html#sample-applications","text":"Two example applications can be found under subdirectories from pyDEM_Samples.tar . The subdirectory \"Serial\" contains a Python script run_serial.py and an input file tiff/Savannah_river.tif . This can be used for a small domain. The script reads: import glob import time from pylib import * from pyDEM.dem import * import numpy as np np . seterr ( all = 'raise' ) if __name__ == '__main__' : #input tiff files files = glob . glob ( 'tiff/Savannah_river.tif' ) files . sort () acc_limit = 1e7 t0 = time . time () for fname in files : names = [ fname ] #output filename sname = f \"./ { fname . split ( '.' )[ 0 ] . split ( '/' )[ - 1 ] } _ { acc_limit } \" print ( sname ) #declare a dem object S = dem () #read data if not os . path . exists ( ' {} .npz' . format ( sname )): S . proc_demfile ( names , sname = sname , depth_limit = [ - 100 , 1000 ], subdomain_size = 2e10 ) S . read_data ( ' {} .npz' . format ( sname )) #compuate watershed information S . compute_watershed () #extract river network (area_limit: catchment area) S . compute_river ( acc_limit = acc_limit ) #write shapefile for river network gdf = S . write_shapefile ( npt_smooth = None ) gdf . to_file ( f ' { sname } .shp' ) print ( f 'It took { ( time . time () - t0 ) / 60 } mins!' ) For a large domain, a parallel dirver is preferred to speed up the process. A sample script is under Parallel/, named run_mpi_vortex.py , which can run with multiple nodes/cpus with mpi4py . References C. Barnes, R., Lehman, C., Mulla (2014). Priority-flood: An optimal depression-filling and watershed-labeling algorithm for digital elevation models. Computers & Geosciences 62, 117\u2013127. doi:10.1016/j.cageo.2013.04.024. Barnes, Richard. 2016. RichDEM: Terrain Analysis Software. http://github.com/r-barnes/richdem. Ye, F., Cui, L., Zhang, Y., Wang, Z., Moghimi, S., Myers, E., Seroka, G., Zundel, A., Mani, S., Kelley, J.G.W. A parallel Python-based tool for meshing watershed rivers at continental scale, Environmental Modelling & Software, 166. https://doi.org/10.1016/j.envsoft.2023.105731.","title":"Sample applications"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html","text":"Scripts \u00b6 RiverMapper is available from the RiverMeshTools repository under schism-dev. Usage \u00b6 RiverMapper requires two inputs: *.tif, which are DEM tiles in lon/lat from one or more sources. a shapefile with a 'LineString' type, which contains a 1D river network. Note The 1D river network can be any reasonable approximation of the thalwegs. It can be: extracted from DEM using the method presented in the previous section or duplicated from the river network of a hydrological model such as the National Water Model or manually drawn for quick local touch-ups The outputs include: \"total_river_arcs.map\", which contains river arcs to be used for the final meshing in SMS. other *.map files for diagnostic purposes. A sample output looks like this: Sample applications \u00b6 To test the RiverMapper tool, you can start by extracting the \"RiverMapper_Samples/\" directory from RiverMapper_Samples.tar . Find the following two subdirectories: \"Serial\" and \"Parallel\", which provide sample applications for meshing watershed rivers in a smaller domain and a larger domain respectively. Each subdirectory contains a sample Python script and the necessary input files. Note that these two samples use the default settings suitable for small watershed rivers that are narrower than a few hundred meters. Similar settings are used in the latest version of NOAA's operational forecast STOFS3D Atlantic . If you are interested in meshing rivers with a wider range of widths, check samples with more parameter settings below . Meshing watershed rivers in a small domain (Serial mode) \u00b6 For a small domain (covering one or two states), a direct function call to the serial \"make_river_map\" suffices. See the sample script: RiverMapper_Samples/Serial/sample_serial.py , which reads: from RiverMapper.make_river_map import make_river_map if __name__ == \"__main__\" : ''' A sample serial application of RiverMapper ''' make_river_map ( tif_fnames = [ './Inputs/DEMs/GA_dem_merged_ll.tif' ], thalweg_shp_fname = './Inputs/Shapefiles/GA_local.shp' , output_dir = './Outputs/' , ) Under the directory \"RiverMapper_Samples/Serial/\", execute the serial script like this: ./sample_serial.py Note Although only one DEM tile is used in this example, but multiple DEM tiles are allowed. If the tiles are from different DEM sources, they should be arranged from high to low priority in the list. Tiles from the high priority DEM source should have high fidelity and high resolution. The script allows DEM tiles of different sizes and shapes. Meshing rivers in a large domain (Parallel mode) \u00b6 For a large domain such as STOFS3D Atlantic , a parallel driver is provided to automatically group thalwegs based on their parent tiles, then distribute the groups to parallel processors. The sample parallel script is: RiverMapper_Samples/Parallel/sample_parallel.py , which reads: from mpi4py import MPI import os from RiverMapper.river_map_mpi_driver import river_map_mpi_driver if __name__ == \"__main__\" : comm = MPI . COMM_WORLD # ------------------------- sample input --------------------------- dems_json_file = './Inputs/DEMs/dems.json' # specifying files for all DEM tiles thalweg_shp_fname = './Inputs/Shapefiles/LA_local.shp' output_dir = './Outputs/' + f ' { os . path . basename ( thalweg_shp_fname ) . split ( \".\" )[ 0 ] } _ { comm . Get_size () } -core/' # ------------------------- end input section --------------------------- river_map_mpi_driver ( dems_json_file = dems_json_file , thalweg_shp_fname = thalweg_shp_fname , output_dir = output_dir , comm = comm ) In stead of specifying a file list for the DEM tiles as in the serial example, the first argument takes a *.json file that specifies multiple sets of DEMs, for example: { \"CuDEM\" : { \"name\" : \"CuDEM\" , \"glob_pattern\" : \"./Inputs/DEMs/CuDEM/*.tif\" , \"file_list\" : [], \"boxes\" : [] }, \"CRM\" : { \"name\" : \"CRM\" , \"glob_pattern\" : \"./Inputs/DEMs/CRM/*.tif\" , \"file_list\" : [], \"boxes\" : [] } } Note For each DEM source, specify a glob pattern and/or a list of file names; if both are specified, the script will pool all files together and take the unique files. No need to manually specify the bounding \"boxes\", just leave them empty. Different DEM products should be arranged from high priority to low priority. The order of the dictionary key (\"CuDEM\" and \"CRM\") is preserved as long as you are using Python 3.7 or a later version. We may replace the regular dictionary to OrderedDict if there is a need. Under the directory \"RiverMapper_Samples/Parallel/\", execute the parallel script like this: mpirun -n 20 ./sample_parallel.py The exact mpi command may vary based on your system. Advanced Parameterization \u00b6 Mandatory input parameters \u00b6 In the \"Serial\" and \"Parallel\" examples above, you may have noticed there are 3 mandatory Inputs: parameter explanation tif_fnames (or a *.json file if there are many tiles) a list of TIF file names. These TIFs should cover the area of interest and be arranged by priority (higher priority ones in front) thalweg_shp_fname name of a polyline shapefile containing the thalwegs output_dir must specify one. Optional input parameters \u00b6 In addition to the mandatory inpouts, RiverMapper provides a few parameters to fine tune the output polylines or generate special features like levees or pseudo-channels. parameter type explanation selected_thalweg integer numpy array Indices of a subset of thalwegs for which the river arcs will be sought; mainly used by the parallel driver output_prefix string a prefix of the output files, mainly used by the caller of this script; can be empty mpi_print_prefix string a prefix string to identify the calling mpi processe in the output messages; can be empty river_threshold float minimum and maximum river widths (in meters) to be resolved min_arcs integer minimum number of arcs to resolve a channel (including bank arcs, inner arcs and outer arcs) width2narcs_option string or callable pre-defined options ('regular', 'sensitive', 'insensitve') or 'custom' if a user-defined function is specified custom_width2narcs a user-defined function a function that takes one parameter 'width' and returns 'narcs', i.e., the number of arcs in the cross-channel direction elev_scale float scaling factor for elevations; a number of -1 (invert elevations) is useful for finding ridges (e.g., of a barrier island) outer_arc_positions a tuple of floats relative position of outer arcs, e.g., (0.1, 0.2) will add 2 outer arcs on each side of the river (4 in total), 0.1 * riverwidth and 0.2 * riverwidth from the banks. R_coef float coef controlling the along-channel resolutions at river bends (with a radius of R), a larger number leads to coarser resolutions (R*R_coef) length_width_ratio float the ratio between along-channel resolution and cross-channel resolution along_channel_reso_thres a tuple of 2 floats the minimum and maximum along-channel resolution (in meters) snap_point_reso_ratio float scaling the threshold of the point snapping; a negtive number means absolute distance value snap_arc_reso_ratio float scaling the threshold of the arc snapping; a negtive number means absolute distance value n_clean_iter int number of iterations for cleaning; more iterations produce cleaner intersections and better channel connectivity i_close_poly bool whether to add cross-channel arcs to enclose river arcs into a polygon i_smooth_banks bool whether to smooth the river banks at abrupt changes of the curvature i_DEM_cache bool Whether or not to read DEM info from cache. Reading from original *.tif files can be slow, so the default option is True i_OCSMesh bool Whether or not to generate polygon-based outputs to be used as inputs to OCSMesh i_DiagnosticsOutput bool whether to output diagnostic information i_pseudo_channel int 0: default, no pseudo channel, nrow_pseudo_channel and pseudo_channel_width are ignored; 1: fixed-width channel with nrow elements in the cross-channel direction, it can also be used to generate a fixed-width levee for a given levee centerline; 2: implement a pseudo channel when the river is poorly defined in DEM pseudo_channel_width float width of the pseudo channel (in meters) nrow_pseudo_channel int number of rows of elements in the cross-channel direction in the pseudo channel You can change the values of these parameters so that the output river map better fits your application (otherwise default values are used). For example, if you want to add two pairs of outer arcs that flank the main river channel, you can do: make_river_map ( tif_fnames = [ './Inputs/DEMs/GA_dem_merged_ll.tif' ], thalweg_shp_fname = './Inputs/Shapefiles/GA_local.shp' , output_dir = './Outputs/' , outer_arc_positions = ( 0.1 , 0.2 ), ) , where the last argument specifies the relative distances of the outer arcs to the main channel. In this case two outer arcs will be placed to the left of the channel at distances of \" \\(0.1 \\times\\) channel width\" and \" \\(0.2 \\times\\) channel width\" from the left bank; the same goes for the right bank, so 4 outer arcs in total. Parameter presets \u00b6 Tuning the parameters may not be easy at first because there are many of them. To simplify the parameter configuration, RiverMapper offers a class called \"ConfigRiverMap\", which provides commonly used parameter presets. These presets are \"class methods\" in config_river_map.py , and each preset (class method, or factory method) comes with a short description in the code. For example, the preset \"LooselyFollowRivers\" means that \"Small-scale river curvatures may not be exactly followed, but channel connectivity is still preserved\", and this is the sample code: from RiverMapper.config_river_map import ConfigRiverMap river_map_config = ConfigRiverMap . LooselyFollowRivers () make_river_map ( tif_fnames = [ './Inputs/DEMs/GA_dem_merged_ll.tif' ], thalweg_shp_fname = './Inputs/Shapefiles/GA_local.shp' , output_dir = './Outputs/' , ** river_map_config . optional , ) and the operator \"**\" unpacks the optional parameters from the configuration. Another utility of the \"ConfigRiverMap\" class is to facilitate the parameter transfer from the parallel driver to the core routine. The stardard way of setting the parameters in the parallel mode is as follows: from mpi4py import MPI import os from RiverMapper.river_map_mpi_driver import river_map_mpi_driver from RiverMapper.config_river_map import ConfigRiverMap if __name__ == \"__main__\" : comm = MPI . COMM_WORLD # ------------------------- sample input --------------------------- dems_json_file = '/sciclone/schism10/Hgrid_projects/STOFS3D-V6/v16/Inputs/dems.json' # specifying files for all DEM tiles thalweg_shp_fname = '/sciclone/schism10/Hgrid_projects/STOFS3D-V6/v16/Shapefiles/CUDEM_Merged_for_v16.shp' output_dir = './Outputs/' + f ' { os . path . basename ( thalweg_shp_fname ) . split ( \".\" )[ 0 ] } _ { comm . Get_size () } -core/' river_map_config = ConfigRiverMap () # ------------------------- end input section --------------------------- river_map_mpi_driver ( dems_json_file = dems_json_file , thalweg_shp_fname = thalweg_shp_fname , output_dir = output_dir , river_map_config = river_map_config , comm = comm ) Comparing with the parallel example in the previous section, the above example adds a few lines of code that does the following: importing the \"ConfigRiverMap\" class creating a default configuration \"river_map_config\", passing the configration to the parallel driver. Since the default configuration is used, this example is essentially the same as the previous parallel example. But it facilitates further parameter tweaking, e.g.: river_map_config = ConfigRiverMap . LooselyFollowRivers () river_map_config . optional [ 'outer_arc_positions' ] = ( 0.1 , 0.2 ) river_map_config . optional [ 'i_real_clean' ] = True , without changing other parts of the code. More parameterization \u00b6 By tweaking the parameters, RiverMapper can also aid in the meshing of a wider range of river sizes or other channel-like features. Hudson River and tributaries \u00b6 This example shows how to customize cross-channel divisions for a main channel that is a few kilometers wide and smaller tributaries. from mpi4py import MPI import os from RiverMapper.river_map_mpi_driver import river_map_mpi_driver from RiverMapper.config_river_map import ConfigRiverMap if __name__ == \"__main__\" : comm = MPI . COMM_WORLD # ------------------------- sample input --------------------------- dems_json_file = '/sciclone/schism10/Hgrid_projects/Shared_with_KM/Inputs/dems.json' # specifying files for all DEM tiles thalweg_shp_fname = '/sciclone/schism10/Hgrid_projects/Shared_with_KM/Inputs/Thalwegs/thalweg_v16_subset_Hudson2.shp' output_dir = './Outputs/' + f ' { os . path . basename ( thalweg_shp_fname ) . split ( \".\" )[ 0 ] } _ { comm . Get_size () } -core/' river_map_config = ConfigRiverMap () # initialize a default configuration river_map_config . optional [ 'river_threshold' ] = ( 2 , 5000 ) # change the search range of river banks to accomodate for Hudson River river_map_config . optional [ 'along_channel_reso_thres' ] = ( 5 , 1200 ) # change the maximum element length from 300 (default for small rivers) to 1200 river_map_config . optional [ 'length_width_ratio' ] = 4.0 # set element aspect ratio as needed # Customize a width-to-narcs function and pass it to the configuration. def width2narcs ( width ): # do not change this line even if width is not used narcs = 5 # you can specify more sophisticated configurations here as needed return narcs # narcs is the number of rows in the cross-channel direction. # pass the customized function to the configuration river_map_config . optional [ 'custom_width2narcs' ] = width2narcs # ------------------------- end input section --------------------------- river_map_mpi_driver ( dems_json_file = dems_json_file , thalweg_shp_fname = thalweg_shp_fname , output_dir = output_dir , river_map_config = river_map_config , comm = comm ) The above code adds more customization to the parallel example. Please read the comments which explain each piece of customization. In particular, note how to pass a customized width-to-narcs function to the configuration. This function takes the width of a river and returns the number of rows in the cross-channel directions. Note The option 'river_threshold' specifies the min and max river width to be resolved, which affects the search range of river banks. A large value like 5000 m used here can slow down the execution compared to the default value (600 m, for small watershed rivers). In the future, we will allow users to select rivers and specify different values for this option. Here, a simplest function is used that specifies five rows of arcs regardless of river width, and the result is shown below: Of course you can specify more sophisticated functions depending on your needs, e.g., nrow = int ( min_arcs + np . ceil ( width / 100 )) # add one arc for every increase of 100 m or nrow = int ( min_arcs + np . floor ( 0.35 * width ** 0.25 )) # add one arc for every increase of one order of magnitude or even make a master plan (similar to the master grid for SCHISM's vgrid ) of how many arcs should be used for a given river width. Levees \u00b6 In the STOFS-3D-Atlantic domain, levees are important features to be incorporated in the model mesh. Instead of parameterizing them as hydraulic structures, the levees are explicitly represented by meter-scale elements, with two rows of nodes resolving the feet of the levee and another two rows resolving the top of the levee: With the levee centerlines available from National Levee Database, the levee map can be easily made by invoking the pseudo channel option of RiverMapper: river_map_config = ConfigRiverMap . Levees () Notice that the along-channel (in this case along-levee) resolution also adapts for bends, just like for rivers. Barrier islands \u00b6 Barrier islands are long and narrow topographical features similar to river channels. In fact, the map of a barrier island can be made in the same way as river channels if the sign of the DEM's elevation values is inverted. This can be done by setting the optional parameter \"elev_scale\" to \"-1\", or directly invoking the preset \"BarrierIsland\": river_map_config = ConfigRiverMap . BarrierIsland () Note The above two sample applications can also be found in RiverMapper_Samples.tar Experimental Features \u00b6 Global arc cleaning \u00b6 The experimental option \"i_real_clean\" has been removed from the parameter list, because it has superseded all other options for river confluence cleaning. It is the only cleaning option in the latest code and enabled by default. The idea is simple: arc vertices that are too close to any vertex or arc segment are snapped to the closest vertices. A critical step is defining how close is close. Setting a global threshold value would not work well because a larger value tends to over-simplify small rivers thus not ensuring channel connectivity and a smaller value causes insufficient cleaning for larger rivers. As a result, a spatially varying threshold is specified for each vertex based on the cross-channel resolution at that location. This ensures a sufficent level of cleaning while maintaining channel connectivity. For example, the resolution around a confluence is largely determined by the smallest branch: For a continental application like STOFS-3D-Atlantic that includes about 30,000 rivers, the cleaning takes about 10 minutes. Since the algorithm is fairly efficient, several iterations of cleaning are implemented allowing the threshold gradually increasing from a small value to the target value; in other words, the most close-by vertices are snapped first, which prevents overly aggressive snapping and slightly improve the quality of the end product. Outputs for OCSMesh \u00b6 The \"i_OCSMesh\" option leads to an extra shapefile output containing river polygons, which serves as an input to OCSMesh . The option is enabled by default because the polygon-based output may be useful for other mesh generators too. Outputting river mesh elements \u00b6 It may be desirable in some circumstances to directly discretize river polygons into elements (quadrangles and triangles). However, this is not the intended function of the tool at least by its original design but rather a task for mesh generators. In addition, the accuracy and efficiency of SCHISM are not sensitive to how mesh generators decide to form the elements (as quads or triangles), as long as they adhere to the given river arcs or polygons. We can implement this option if there is a need.","title":"Generate river map"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#scripts","text":"RiverMapper is available from the RiverMeshTools repository under schism-dev.","title":"Scripts"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#usage","text":"RiverMapper requires two inputs: *.tif, which are DEM tiles in lon/lat from one or more sources. a shapefile with a 'LineString' type, which contains a 1D river network. Note The 1D river network can be any reasonable approximation of the thalwegs. It can be: extracted from DEM using the method presented in the previous section or duplicated from the river network of a hydrological model such as the National Water Model or manually drawn for quick local touch-ups The outputs include: \"total_river_arcs.map\", which contains river arcs to be used for the final meshing in SMS. other *.map files for diagnostic purposes. A sample output looks like this:","title":"Usage"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#sample-applications","text":"To test the RiverMapper tool, you can start by extracting the \"RiverMapper_Samples/\" directory from RiverMapper_Samples.tar . Find the following two subdirectories: \"Serial\" and \"Parallel\", which provide sample applications for meshing watershed rivers in a smaller domain and a larger domain respectively. Each subdirectory contains a sample Python script and the necessary input files. Note that these two samples use the default settings suitable for small watershed rivers that are narrower than a few hundred meters. Similar settings are used in the latest version of NOAA's operational forecast STOFS3D Atlantic . If you are interested in meshing rivers with a wider range of widths, check samples with more parameter settings below .","title":"Sample applications"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#meshing-watershed-rivers-in-a-small-domain-serial-mode","text":"For a small domain (covering one or two states), a direct function call to the serial \"make_river_map\" suffices. See the sample script: RiverMapper_Samples/Serial/sample_serial.py , which reads: from RiverMapper.make_river_map import make_river_map if __name__ == \"__main__\" : ''' A sample serial application of RiverMapper ''' make_river_map ( tif_fnames = [ './Inputs/DEMs/GA_dem_merged_ll.tif' ], thalweg_shp_fname = './Inputs/Shapefiles/GA_local.shp' , output_dir = './Outputs/' , ) Under the directory \"RiverMapper_Samples/Serial/\", execute the serial script like this: ./sample_serial.py Note Although only one DEM tile is used in this example, but multiple DEM tiles are allowed. If the tiles are from different DEM sources, they should be arranged from high to low priority in the list. Tiles from the high priority DEM source should have high fidelity and high resolution. The script allows DEM tiles of different sizes and shapes.","title":"Meshing watershed rivers in a small domain (Serial mode)"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#meshing-rivers-in-a-large-domain-parallel-mode","text":"For a large domain such as STOFS3D Atlantic , a parallel driver is provided to automatically group thalwegs based on their parent tiles, then distribute the groups to parallel processors. The sample parallel script is: RiverMapper_Samples/Parallel/sample_parallel.py , which reads: from mpi4py import MPI import os from RiverMapper.river_map_mpi_driver import river_map_mpi_driver if __name__ == \"__main__\" : comm = MPI . COMM_WORLD # ------------------------- sample input --------------------------- dems_json_file = './Inputs/DEMs/dems.json' # specifying files for all DEM tiles thalweg_shp_fname = './Inputs/Shapefiles/LA_local.shp' output_dir = './Outputs/' + f ' { os . path . basename ( thalweg_shp_fname ) . split ( \".\" )[ 0 ] } _ { comm . Get_size () } -core/' # ------------------------- end input section --------------------------- river_map_mpi_driver ( dems_json_file = dems_json_file , thalweg_shp_fname = thalweg_shp_fname , output_dir = output_dir , comm = comm ) In stead of specifying a file list for the DEM tiles as in the serial example, the first argument takes a *.json file that specifies multiple sets of DEMs, for example: { \"CuDEM\" : { \"name\" : \"CuDEM\" , \"glob_pattern\" : \"./Inputs/DEMs/CuDEM/*.tif\" , \"file_list\" : [], \"boxes\" : [] }, \"CRM\" : { \"name\" : \"CRM\" , \"glob_pattern\" : \"./Inputs/DEMs/CRM/*.tif\" , \"file_list\" : [], \"boxes\" : [] } } Note For each DEM source, specify a glob pattern and/or a list of file names; if both are specified, the script will pool all files together and take the unique files. No need to manually specify the bounding \"boxes\", just leave them empty. Different DEM products should be arranged from high priority to low priority. The order of the dictionary key (\"CuDEM\" and \"CRM\") is preserved as long as you are using Python 3.7 or a later version. We may replace the regular dictionary to OrderedDict if there is a need. Under the directory \"RiverMapper_Samples/Parallel/\", execute the parallel script like this: mpirun -n 20 ./sample_parallel.py The exact mpi command may vary based on your system.","title":"Meshing rivers in a large domain (Parallel mode)"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#advanced-parameterization","text":"","title":"Advanced Parameterization"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#mandatory-input-parameters","text":"In the \"Serial\" and \"Parallel\" examples above, you may have noticed there are 3 mandatory Inputs: parameter explanation tif_fnames (or a *.json file if there are many tiles) a list of TIF file names. These TIFs should cover the area of interest and be arranged by priority (higher priority ones in front) thalweg_shp_fname name of a polyline shapefile containing the thalwegs output_dir must specify one.","title":"Mandatory input parameters"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#optional-input-parameters","text":"In addition to the mandatory inpouts, RiverMapper provides a few parameters to fine tune the output polylines or generate special features like levees or pseudo-channels. parameter type explanation selected_thalweg integer numpy array Indices of a subset of thalwegs for which the river arcs will be sought; mainly used by the parallel driver output_prefix string a prefix of the output files, mainly used by the caller of this script; can be empty mpi_print_prefix string a prefix string to identify the calling mpi processe in the output messages; can be empty river_threshold float minimum and maximum river widths (in meters) to be resolved min_arcs integer minimum number of arcs to resolve a channel (including bank arcs, inner arcs and outer arcs) width2narcs_option string or callable pre-defined options ('regular', 'sensitive', 'insensitve') or 'custom' if a user-defined function is specified custom_width2narcs a user-defined function a function that takes one parameter 'width' and returns 'narcs', i.e., the number of arcs in the cross-channel direction elev_scale float scaling factor for elevations; a number of -1 (invert elevations) is useful for finding ridges (e.g., of a barrier island) outer_arc_positions a tuple of floats relative position of outer arcs, e.g., (0.1, 0.2) will add 2 outer arcs on each side of the river (4 in total), 0.1 * riverwidth and 0.2 * riverwidth from the banks. R_coef float coef controlling the along-channel resolutions at river bends (with a radius of R), a larger number leads to coarser resolutions (R*R_coef) length_width_ratio float the ratio between along-channel resolution and cross-channel resolution along_channel_reso_thres a tuple of 2 floats the minimum and maximum along-channel resolution (in meters) snap_point_reso_ratio float scaling the threshold of the point snapping; a negtive number means absolute distance value snap_arc_reso_ratio float scaling the threshold of the arc snapping; a negtive number means absolute distance value n_clean_iter int number of iterations for cleaning; more iterations produce cleaner intersections and better channel connectivity i_close_poly bool whether to add cross-channel arcs to enclose river arcs into a polygon i_smooth_banks bool whether to smooth the river banks at abrupt changes of the curvature i_DEM_cache bool Whether or not to read DEM info from cache. Reading from original *.tif files can be slow, so the default option is True i_OCSMesh bool Whether or not to generate polygon-based outputs to be used as inputs to OCSMesh i_DiagnosticsOutput bool whether to output diagnostic information i_pseudo_channel int 0: default, no pseudo channel, nrow_pseudo_channel and pseudo_channel_width are ignored; 1: fixed-width channel with nrow elements in the cross-channel direction, it can also be used to generate a fixed-width levee for a given levee centerline; 2: implement a pseudo channel when the river is poorly defined in DEM pseudo_channel_width float width of the pseudo channel (in meters) nrow_pseudo_channel int number of rows of elements in the cross-channel direction in the pseudo channel You can change the values of these parameters so that the output river map better fits your application (otherwise default values are used). For example, if you want to add two pairs of outer arcs that flank the main river channel, you can do: make_river_map ( tif_fnames = [ './Inputs/DEMs/GA_dem_merged_ll.tif' ], thalweg_shp_fname = './Inputs/Shapefiles/GA_local.shp' , output_dir = './Outputs/' , outer_arc_positions = ( 0.1 , 0.2 ), ) , where the last argument specifies the relative distances of the outer arcs to the main channel. In this case two outer arcs will be placed to the left of the channel at distances of \" \\(0.1 \\times\\) channel width\" and \" \\(0.2 \\times\\) channel width\" from the left bank; the same goes for the right bank, so 4 outer arcs in total.","title":"Optional input parameters"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#parameter-presets","text":"Tuning the parameters may not be easy at first because there are many of them. To simplify the parameter configuration, RiverMapper offers a class called \"ConfigRiverMap\", which provides commonly used parameter presets. These presets are \"class methods\" in config_river_map.py , and each preset (class method, or factory method) comes with a short description in the code. For example, the preset \"LooselyFollowRivers\" means that \"Small-scale river curvatures may not be exactly followed, but channel connectivity is still preserved\", and this is the sample code: from RiverMapper.config_river_map import ConfigRiverMap river_map_config = ConfigRiverMap . LooselyFollowRivers () make_river_map ( tif_fnames = [ './Inputs/DEMs/GA_dem_merged_ll.tif' ], thalweg_shp_fname = './Inputs/Shapefiles/GA_local.shp' , output_dir = './Outputs/' , ** river_map_config . optional , ) and the operator \"**\" unpacks the optional parameters from the configuration. Another utility of the \"ConfigRiverMap\" class is to facilitate the parameter transfer from the parallel driver to the core routine. The stardard way of setting the parameters in the parallel mode is as follows: from mpi4py import MPI import os from RiverMapper.river_map_mpi_driver import river_map_mpi_driver from RiverMapper.config_river_map import ConfigRiverMap if __name__ == \"__main__\" : comm = MPI . COMM_WORLD # ------------------------- sample input --------------------------- dems_json_file = '/sciclone/schism10/Hgrid_projects/STOFS3D-V6/v16/Inputs/dems.json' # specifying files for all DEM tiles thalweg_shp_fname = '/sciclone/schism10/Hgrid_projects/STOFS3D-V6/v16/Shapefiles/CUDEM_Merged_for_v16.shp' output_dir = './Outputs/' + f ' { os . path . basename ( thalweg_shp_fname ) . split ( \".\" )[ 0 ] } _ { comm . Get_size () } -core/' river_map_config = ConfigRiverMap () # ------------------------- end input section --------------------------- river_map_mpi_driver ( dems_json_file = dems_json_file , thalweg_shp_fname = thalweg_shp_fname , output_dir = output_dir , river_map_config = river_map_config , comm = comm ) Comparing with the parallel example in the previous section, the above example adds a few lines of code that does the following: importing the \"ConfigRiverMap\" class creating a default configuration \"river_map_config\", passing the configration to the parallel driver. Since the default configuration is used, this example is essentially the same as the previous parallel example. But it facilitates further parameter tweaking, e.g.: river_map_config = ConfigRiverMap . LooselyFollowRivers () river_map_config . optional [ 'outer_arc_positions' ] = ( 0.1 , 0.2 ) river_map_config . optional [ 'i_real_clean' ] = True , without changing other parts of the code.","title":"Parameter presets"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#more-parameterization","text":"By tweaking the parameters, RiverMapper can also aid in the meshing of a wider range of river sizes or other channel-like features.","title":"More parameterization"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#hudson-river-and-tributaries","text":"This example shows how to customize cross-channel divisions for a main channel that is a few kilometers wide and smaller tributaries. from mpi4py import MPI import os from RiverMapper.river_map_mpi_driver import river_map_mpi_driver from RiverMapper.config_river_map import ConfigRiverMap if __name__ == \"__main__\" : comm = MPI . COMM_WORLD # ------------------------- sample input --------------------------- dems_json_file = '/sciclone/schism10/Hgrid_projects/Shared_with_KM/Inputs/dems.json' # specifying files for all DEM tiles thalweg_shp_fname = '/sciclone/schism10/Hgrid_projects/Shared_with_KM/Inputs/Thalwegs/thalweg_v16_subset_Hudson2.shp' output_dir = './Outputs/' + f ' { os . path . basename ( thalweg_shp_fname ) . split ( \".\" )[ 0 ] } _ { comm . Get_size () } -core/' river_map_config = ConfigRiverMap () # initialize a default configuration river_map_config . optional [ 'river_threshold' ] = ( 2 , 5000 ) # change the search range of river banks to accomodate for Hudson River river_map_config . optional [ 'along_channel_reso_thres' ] = ( 5 , 1200 ) # change the maximum element length from 300 (default for small rivers) to 1200 river_map_config . optional [ 'length_width_ratio' ] = 4.0 # set element aspect ratio as needed # Customize a width-to-narcs function and pass it to the configuration. def width2narcs ( width ): # do not change this line even if width is not used narcs = 5 # you can specify more sophisticated configurations here as needed return narcs # narcs is the number of rows in the cross-channel direction. # pass the customized function to the configuration river_map_config . optional [ 'custom_width2narcs' ] = width2narcs # ------------------------- end input section --------------------------- river_map_mpi_driver ( dems_json_file = dems_json_file , thalweg_shp_fname = thalweg_shp_fname , output_dir = output_dir , river_map_config = river_map_config , comm = comm ) The above code adds more customization to the parallel example. Please read the comments which explain each piece of customization. In particular, note how to pass a customized width-to-narcs function to the configuration. This function takes the width of a river and returns the number of rows in the cross-channel directions. Note The option 'river_threshold' specifies the min and max river width to be resolved, which affects the search range of river banks. A large value like 5000 m used here can slow down the execution compared to the default value (600 m, for small watershed rivers). In the future, we will allow users to select rivers and specify different values for this option. Here, a simplest function is used that specifies five rows of arcs regardless of river width, and the result is shown below: Of course you can specify more sophisticated functions depending on your needs, e.g., nrow = int ( min_arcs + np . ceil ( width / 100 )) # add one arc for every increase of 100 m or nrow = int ( min_arcs + np . floor ( 0.35 * width ** 0.25 )) # add one arc for every increase of one order of magnitude or even make a master plan (similar to the master grid for SCHISM's vgrid ) of how many arcs should be used for a given river width.","title":"Hudson River and tributaries"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#levees","text":"In the STOFS-3D-Atlantic domain, levees are important features to be incorporated in the model mesh. Instead of parameterizing them as hydraulic structures, the levees are explicitly represented by meter-scale elements, with two rows of nodes resolving the feet of the levee and another two rows resolving the top of the levee: With the levee centerlines available from National Levee Database, the levee map can be easily made by invoking the pseudo channel option of RiverMapper: river_map_config = ConfigRiverMap . Levees () Notice that the along-channel (in this case along-levee) resolution also adapts for bends, just like for rivers.","title":"Levees"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#barrier-islands","text":"Barrier islands are long and narrow topographical features similar to river channels. In fact, the map of a barrier island can be made in the same way as river channels if the sign of the DEM's elevation values is inverted. This can be done by setting the optional parameter \"elev_scale\" to \"-1\", or directly invoking the preset \"BarrierIsland\": river_map_config = ConfigRiverMap . BarrierIsland () Note The above two sample applications can also be found in RiverMapper_Samples.tar","title":"Barrier islands"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#experimental-features","text":"","title":"Experimental Features"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#global-arc-cleaning","text":"The experimental option \"i_real_clean\" has been removed from the parameter list, because it has superseded all other options for river confluence cleaning. It is the only cleaning option in the latest code and enabled by default. The idea is simple: arc vertices that are too close to any vertex or arc segment are snapped to the closest vertices. A critical step is defining how close is close. Setting a global threshold value would not work well because a larger value tends to over-simplify small rivers thus not ensuring channel connectivity and a smaller value causes insufficient cleaning for larger rivers. As a result, a spatially varying threshold is specified for each vertex based on the cross-channel resolution at that location. This ensures a sufficent level of cleaning while maintaining channel connectivity. For example, the resolution around a confluence is largely determined by the smallest branch: For a continental application like STOFS-3D-Atlantic that includes about 30,000 rivers, the cleaning takes about 10 minutes. Since the algorithm is fairly efficient, several iterations of cleaning are implemented allowing the threshold gradually increasing from a small value to the target value; in other words, the most close-by vertices are snapped first, which prevents overly aggressive snapping and slightly improve the quality of the end product.","title":"Global arc cleaning"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#outputs-for-ocsmesh","text":"The \"i_OCSMesh\" option leads to an extra shapefile output containing river polygons, which serves as an input to OCSMesh . The option is enabled by default because the polygon-based output may be useful for other mesh generators too.","title":"Outputs for OCSMesh"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#outputting-river-mesh-elements","text":"It may be desirable in some circumstances to directly discretize river polygons into elements (quadrangles and triangles). However, this is not the intended function of the tool at least by its original design but rather a task for mesh generators. In addition, the accuracy and efficiency of SCHISM are not sensitive to how mesh generators decide to form the elements (as quads or triangles), as long as they adhere to the given river arcs or polygons. We can implement this option if there is a need.","title":"Outputting river mesh elements"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html","text":"Overview \u00b6 Here we provide three sample projects to illustrate the procedure of meshing for compound flood simulations. These examples use SMS to merge the automatic arcs with existing manual arcs and generate the final mesh. The projects are organized in order of increasing complexity. Note The main purpose is to illustrate the necessary steps to get a clean map coverage for meshing, and you're welcome to employ any tools or methods that suit your preference. The key is to organize different map features (such as coastal water bodies, watershed rivers, hydraulic structures) in individual SMS map coverages and merge them properly to avoid unwanted intersections. Calcasieu Lake \u00b6 The first example illustrates how you may extend an existing coastal model mesh to include higher-grounds and small rivers in the watershed. Step 1. Start from an existing map coverage. Assume you have a manually made SMS map for a traditional coastal simulation like this: The spatial domain (orange color) covers everything below the sea level in the study area. Step 2. Include more upland areas of interest: Define a boundary that delineates the landward limit of the new domain of interest, for example: Step 3. Clip the automatic arcs so that they are only present in the areas of interest. Typically, we want to put the automatic arcs (watershed rivers) only in the extended region. This can be done in various ways, e.g., using GIS tools or scripts. For this simple project, using SMS or GIS tools is straightforward, and here is an example using the clipping tool (similar to that in ArcGIS or QGIS) inside SMS: Duplicate the full domain map coverage (from Step 2) and name it as \"extended\" Select the polygon that corresponds to the extended region, remove other polygons by invert selection and delete: Use the clipping tool in the toolbox, and clip the automatic arcs inside the extended region. The results look like: Step 4. Merge the clipped automatic arcs and generate the mesh. Note If you want to set a uniform mesh resolution in the extended region, you should do it before merging, because the polygon of the extended region will be split into many parts afterwards, making it labor intensive to set attributes for them manually. Set the element size as: After merging, you should clean the final coverage and build polygons again. The element size set in the extended region will be inherited (as of SMS 13.3.5) even though it has been split into many parts by river arcs: Note Sometimes a few parts split from the original extended region may not inherit the polygon attributes and default to \"paving\", in this case you may need to manually set the polygon attributes or design another map coverage to facilitate the selection. This is elaborated below . And here is the final mesh: Coastal areas in Texas \u00b6 This example is similar to the first one, but the existing map is more complex. Step 1. Start from an existing map coverage. This manual map consists of many polygons and some of them are islands (empty polygons, not meshed). Step 2. Include more upland areas of interest: Include islands of interest. For example, the yellow polygons in the figure above are islands, which have a mesh type of \"None\". Set them to \"Paving\" so that they will be meshed. If many islands need to be set to \"paving\" in the existing map coverage, you can directly edit the *.map file and replace all occurrences of the string \"NOMESH\" to \"PAVE 0.3\". Define a boundary that delineates the landward limit of the new domain, for example: Step 3. Clip the automatic arcs so that they are only present in the areas of interest. Similar to the first example, the extended region is the difference between the newly defined full domain and the original domain (which also includes any islands of interest): The clipped arcs look like: Depending on your needs, you may want the automatic arcs to intersect with the existing arcs (set buffer=0 in this case) or leave a buffer distance between the two groups of arcs. We typically don't let automatic arcs intersect with existing arcs, but this requires some further considerations (see below ) to ensure channel connectivity. Here, we provide an example using Python scripting: Merge the newly defined the land boundary with the existing coverage: , clean the merged coverage and rebuild polygons in SMS. Save the original coverage and the merged coverage (full domain) as polygon shapefiles. Use the Python script below to clip the automatic arcs: import geopandas as gpd # ------------------------- inputs --------------------------- wdir = '/sciclone/schism10/Hgrid_projects/GoM/' original = gpd . read_file ( f ' { wdir } /original.shp' ) full_domain = gpd . read_file ( f ' { wdir } /full.shp' ) islands = gpd . read_file ( f ' { wdir } /islands.shp' ) buffer_distance = 50e-5 # set to 0 if no buffer is needed # ------------------------- end inputs --------------------------- # buffer the original domain so that the clipped arcs don't intersect with the original domain original_buf = gpd . GeoDataFrame ( geometry = original . buffer ( buffer_distance )) # the extended region is the \"watershed\" region where the auto arcs are placed extended_region = full_domain . overlay ( original_buf , how = 'difference' ) . dissolve () # add any islands back islands_buf = gpd . GeoDataFrame ( geometry = islands . buffer ( - buffer_distance )) # \"minus\" because we want the river arcs contained in the islands extended_region = extended_region . append ( islands_buf ) # clip the auto arcs to the extended region total_arcs = gpd . read_file ( f ' { wdir } /total_arcs.shp' ) total_arcs_clipped = total_arcs . clip ( extended_region ) total_arcs_clipped . to_file ( f ' { wdir } /total_arcs_clipped.shp' ) The usage of this simple script is self-evident and you can use it as a starting point for your own project. Scripting is recommended for more complex projects with many individual map coverages. Step 4. Merge the clipped automatic arcs and generate the mesh. See details in the SECOFS example. SECOFS (South-east Coastal Forecast System) \u00b6 This example is based on the SECOFS domain. This project has an additional component in the map module, i.e., the levee and dam system from the National Levee Database. In a more complex project like this one, it is recommended to use a script to clip the automatic arcs inside the extended (watershed) region. The SCHISM Git repo provides a clipping script for SECOFS: $your_schism_dir /src/Utility/Pre-Processing/SECOFS/Grid/clip_autoarcs.py This script is similar to the one shown in the Texas example above, but it has more steps. The rest of the procedures of automatic arcs preperation is similar to what have been shown in the previous examples and not repeated here. Preparation \u00b6 The SECOFS SMS project has the following components: For a complex meshing project, it is imperative to keep different features in seperate maps. Merging individual maps should be done as the last step. In this project, the purpose of each SMS map coverage is as follows: lbnd: land boundary roughly along the 10-m contour. levee*: Levees from National Levee Database. auto*arcs: Automatically generated river arcs, clipped inside the watershed region (see clipping the river arcs ) coast: This map includes all manually made polygons (including quad patches) and the coastline. merge coverge: Merged map of all individual maps above. Attention Never edit the merged map directly, unless you are willing to take the time to exactly reproduce the changes in all individual maps (which is more time consuming in most cases, so don't do it). For a complex project, breaking the consistency between the merged map and the individual maps makes it practically impossible for any significant changes in the future. Clean the merged map \u00b6 Since SMS 13.3, the cleaning is very efficient even for a map with tens of thousands of arcs. However, you may need to clean the merged map multiple times until there is no more warning messages. For STOFS3D or SECOFS, use with the following parameters: Build polygons \u00b6 Make sure there is no warning message after the polygons are built; otherwise, go back to the cleaning step and try again. Finalize the mesh \u00b6 Delete the disjoint nodes: Renumber nodes: Save the mesh as *.2dm: ** Mesh quality and skew elements ** \u00b6 Although the script tries to optimize the convergence of river arcs at river intersections , skew elements may occasionally occur. Normally these small 'bad' elements do not affect the efficiency or stability of SCHISM simulations. However, it's advisable to edit out extremely small/skew elements. You may remedy them using the following script provided in RiverMapper : RiverMeshTools/RiverMapper/RiverMapper/improve_hgrid.py The script automatically checks for small and skew elements, then improve the mesh by merging, removing, or relaxing the problematic elements. As a general rule of thumb, SCHISM can comfortably handle elements >= \\(1m^2\\) ( \\(10^{-10}\\) in lon/lat), and skewness<=60. You can specify these parameters in the script; see the \" main \" section of the script for usage. Alternatively, you can use ACE/xmgredit5 or SMS to check and fix mesh quality manually. Attention Avoid overly depending on mesh adjustments in the final stage, as the underlying issue often originates from the SMS coverages or the merging process. In these instances, it is best to address the problems directly within the SMS coverages. Additional notes for STOFS/SECOFS developers \u00b6 These notes are primarily intended as a reference for developers, although other users might also find parts of the content beneficial. Strategy for editing the coastal coverage \u00b6 Edit the coastal coverage when local refinements are needed in an area of interest. Rules to follow (for consistency among STOFS3D/SECOFS developers): The manual arcs should at least be better than the auto arcs; use the shapefile of the auto arcs as a background in SMS to help you decide. In particular, this means you need to accommodate for tributaries when placing a manual polygon for a main channel, lake, or estuary: No need to create buffers for manual polygons; the clipping procedure automatically creates a 50-meter buffer zone around all manual polygons. Attention Arcs not included in a polygon do not have a buffer; this setting is intentional. Unless you have a clear plan, don't mix features from other coverages (e.g., levees and auto arcs) in the coastal coverage, which is reserved for manual editing. Doing so means that you assume the responsiblity of keeping the manual edits up-to-date with external changes that may be more easily done in other coverages. For example, the National Levee Database add/remove features from time to time; the requirements on the auto arcs may change or there may be improvements in the RiverMapper tool itself. In addition, putting auto arcs in this coverage means that you will spend extra time trying to satisfy the first rule of explicitly accommodating for the connectivity with tributaries. Set watershed resolution \u00b6 To avoid over-refinement, most watershed polygons should have a specified mesh resolution, which can be set via the \"constant paving\" or \"scalar paving density\" option in each polygon's attributes. Selecting the watershed polygons may involve much labor because many small polygons are generated after the river arcs are merged into the final map. Instead of manual selection, use the \"select*\" map coverage to select all polygons more efficiently. Activate the \"select*\" coverage: Select the big polygon, right click on it, and click \"Select intersecting objects\": Intersect it with \"merge coverage\" with the following parameters: It will take about 10 minutes to do the selection for the STOFS3D domain. For STOFS3D, right click on the selected polygons and set \"mesh type\" in \"polygon attributes\" to scalar paving density: Set scalar options using the watershed_resolution scatter dataset from the preparation step: In addition, set the polygon attribute of the \"island\" between Chesapeake Bay and Delaware Bay as \"None\": For SECOFS, \"Constant paving\" with the following parameters is used:","title":"Meshing in SMS"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#overview","text":"Here we provide three sample projects to illustrate the procedure of meshing for compound flood simulations. These examples use SMS to merge the automatic arcs with existing manual arcs and generate the final mesh. The projects are organized in order of increasing complexity. Note The main purpose is to illustrate the necessary steps to get a clean map coverage for meshing, and you're welcome to employ any tools or methods that suit your preference. The key is to organize different map features (such as coastal water bodies, watershed rivers, hydraulic structures) in individual SMS map coverages and merge them properly to avoid unwanted intersections.","title":"Overview"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#calcasieu-lake","text":"The first example illustrates how you may extend an existing coastal model mesh to include higher-grounds and small rivers in the watershed. Step 1. Start from an existing map coverage. Assume you have a manually made SMS map for a traditional coastal simulation like this: The spatial domain (orange color) covers everything below the sea level in the study area. Step 2. Include more upland areas of interest: Define a boundary that delineates the landward limit of the new domain of interest, for example: Step 3. Clip the automatic arcs so that they are only present in the areas of interest. Typically, we want to put the automatic arcs (watershed rivers) only in the extended region. This can be done in various ways, e.g., using GIS tools or scripts. For this simple project, using SMS or GIS tools is straightforward, and here is an example using the clipping tool (similar to that in ArcGIS or QGIS) inside SMS: Duplicate the full domain map coverage (from Step 2) and name it as \"extended\" Select the polygon that corresponds to the extended region, remove other polygons by invert selection and delete: Use the clipping tool in the toolbox, and clip the automatic arcs inside the extended region. The results look like: Step 4. Merge the clipped automatic arcs and generate the mesh. Note If you want to set a uniform mesh resolution in the extended region, you should do it before merging, because the polygon of the extended region will be split into many parts afterwards, making it labor intensive to set attributes for them manually. Set the element size as: After merging, you should clean the final coverage and build polygons again. The element size set in the extended region will be inherited (as of SMS 13.3.5) even though it has been split into many parts by river arcs: Note Sometimes a few parts split from the original extended region may not inherit the polygon attributes and default to \"paving\", in this case you may need to manually set the polygon attributes or design another map coverage to facilitate the selection. This is elaborated below . And here is the final mesh:","title":"Calcasieu Lake"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#coastal-areas-in-texas","text":"This example is similar to the first one, but the existing map is more complex. Step 1. Start from an existing map coverage. This manual map consists of many polygons and some of them are islands (empty polygons, not meshed). Step 2. Include more upland areas of interest: Include islands of interest. For example, the yellow polygons in the figure above are islands, which have a mesh type of \"None\". Set them to \"Paving\" so that they will be meshed. If many islands need to be set to \"paving\" in the existing map coverage, you can directly edit the *.map file and replace all occurrences of the string \"NOMESH\" to \"PAVE 0.3\". Define a boundary that delineates the landward limit of the new domain, for example: Step 3. Clip the automatic arcs so that they are only present in the areas of interest. Similar to the first example, the extended region is the difference between the newly defined full domain and the original domain (which also includes any islands of interest): The clipped arcs look like: Depending on your needs, you may want the automatic arcs to intersect with the existing arcs (set buffer=0 in this case) or leave a buffer distance between the two groups of arcs. We typically don't let automatic arcs intersect with existing arcs, but this requires some further considerations (see below ) to ensure channel connectivity. Here, we provide an example using Python scripting: Merge the newly defined the land boundary with the existing coverage: , clean the merged coverage and rebuild polygons in SMS. Save the original coverage and the merged coverage (full domain) as polygon shapefiles. Use the Python script below to clip the automatic arcs: import geopandas as gpd # ------------------------- inputs --------------------------- wdir = '/sciclone/schism10/Hgrid_projects/GoM/' original = gpd . read_file ( f ' { wdir } /original.shp' ) full_domain = gpd . read_file ( f ' { wdir } /full.shp' ) islands = gpd . read_file ( f ' { wdir } /islands.shp' ) buffer_distance = 50e-5 # set to 0 if no buffer is needed # ------------------------- end inputs --------------------------- # buffer the original domain so that the clipped arcs don't intersect with the original domain original_buf = gpd . GeoDataFrame ( geometry = original . buffer ( buffer_distance )) # the extended region is the \"watershed\" region where the auto arcs are placed extended_region = full_domain . overlay ( original_buf , how = 'difference' ) . dissolve () # add any islands back islands_buf = gpd . GeoDataFrame ( geometry = islands . buffer ( - buffer_distance )) # \"minus\" because we want the river arcs contained in the islands extended_region = extended_region . append ( islands_buf ) # clip the auto arcs to the extended region total_arcs = gpd . read_file ( f ' { wdir } /total_arcs.shp' ) total_arcs_clipped = total_arcs . clip ( extended_region ) total_arcs_clipped . to_file ( f ' { wdir } /total_arcs_clipped.shp' ) The usage of this simple script is self-evident and you can use it as a starting point for your own project. Scripting is recommended for more complex projects with many individual map coverages. Step 4. Merge the clipped automatic arcs and generate the mesh. See details in the SECOFS example.","title":"Coastal areas in Texas"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#secofs-south-east-coastal-forecast-system","text":"This example is based on the SECOFS domain. This project has an additional component in the map module, i.e., the levee and dam system from the National Levee Database. In a more complex project like this one, it is recommended to use a script to clip the automatic arcs inside the extended (watershed) region. The SCHISM Git repo provides a clipping script for SECOFS: $your_schism_dir /src/Utility/Pre-Processing/SECOFS/Grid/clip_autoarcs.py This script is similar to the one shown in the Texas example above, but it has more steps. The rest of the procedures of automatic arcs preperation is similar to what have been shown in the previous examples and not repeated here.","title":"SECOFS (South-east Coastal Forecast System)"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#preparation","text":"The SECOFS SMS project has the following components: For a complex meshing project, it is imperative to keep different features in seperate maps. Merging individual maps should be done as the last step. In this project, the purpose of each SMS map coverage is as follows: lbnd: land boundary roughly along the 10-m contour. levee*: Levees from National Levee Database. auto*arcs: Automatically generated river arcs, clipped inside the watershed region (see clipping the river arcs ) coast: This map includes all manually made polygons (including quad patches) and the coastline. merge coverge: Merged map of all individual maps above. Attention Never edit the merged map directly, unless you are willing to take the time to exactly reproduce the changes in all individual maps (which is more time consuming in most cases, so don't do it). For a complex project, breaking the consistency between the merged map and the individual maps makes it practically impossible for any significant changes in the future.","title":"Preparation"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#clean-the-merged-map","text":"Since SMS 13.3, the cleaning is very efficient even for a map with tens of thousands of arcs. However, you may need to clean the merged map multiple times until there is no more warning messages. For STOFS3D or SECOFS, use with the following parameters:","title":"Clean the merged map"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#build-polygons","text":"Make sure there is no warning message after the polygons are built; otherwise, go back to the cleaning step and try again.","title":"Build polygons"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#finalize-the-mesh","text":"Delete the disjoint nodes: Renumber nodes: Save the mesh as *.2dm:","title":"Finalize the mesh"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#mesh-quality-and-skew-elements","text":"Although the script tries to optimize the convergence of river arcs at river intersections , skew elements may occasionally occur. Normally these small 'bad' elements do not affect the efficiency or stability of SCHISM simulations. However, it's advisable to edit out extremely small/skew elements. You may remedy them using the following script provided in RiverMapper : RiverMeshTools/RiverMapper/RiverMapper/improve_hgrid.py The script automatically checks for small and skew elements, then improve the mesh by merging, removing, or relaxing the problematic elements. As a general rule of thumb, SCHISM can comfortably handle elements >= \\(1m^2\\) ( \\(10^{-10}\\) in lon/lat), and skewness<=60. You can specify these parameters in the script; see the \" main \" section of the script for usage. Alternatively, you can use ACE/xmgredit5 or SMS to check and fix mesh quality manually. Attention Avoid overly depending on mesh adjustments in the final stage, as the underlying issue often originates from the SMS coverages or the merging process. In these instances, it is best to address the problems directly within the SMS coverages.","title":"** Mesh quality and skew elements **"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#additional-notes-for-stofssecofs-developers","text":"These notes are primarily intended as a reference for developers, although other users might also find parts of the content beneficial.","title":"Additional notes for STOFS/SECOFS developers"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#strategy-for-editing-the-coastal-coverage","text":"Edit the coastal coverage when local refinements are needed in an area of interest. Rules to follow (for consistency among STOFS3D/SECOFS developers): The manual arcs should at least be better than the auto arcs; use the shapefile of the auto arcs as a background in SMS to help you decide. In particular, this means you need to accommodate for tributaries when placing a manual polygon for a main channel, lake, or estuary: No need to create buffers for manual polygons; the clipping procedure automatically creates a 50-meter buffer zone around all manual polygons. Attention Arcs not included in a polygon do not have a buffer; this setting is intentional. Unless you have a clear plan, don't mix features from other coverages (e.g., levees and auto arcs) in the coastal coverage, which is reserved for manual editing. Doing so means that you assume the responsiblity of keeping the manual edits up-to-date with external changes that may be more easily done in other coverages. For example, the National Levee Database add/remove features from time to time; the requirements on the auto arcs may change or there may be improvements in the RiverMapper tool itself. In addition, putting auto arcs in this coverage means that you will spend extra time trying to satisfy the first rule of explicitly accommodating for the connectivity with tributaries.","title":"Strategy for editing the coastal coverage"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#set-watershed-resolution","text":"To avoid over-refinement, most watershed polygons should have a specified mesh resolution, which can be set via the \"constant paving\" or \"scalar paving density\" option in each polygon's attributes. Selecting the watershed polygons may involve much labor because many small polygons are generated after the river arcs are merged into the final map. Instead of manual selection, use the \"select*\" map coverage to select all polygons more efficiently. Activate the \"select*\" coverage: Select the big polygon, right click on it, and click \"Select intersecting objects\": Intersect it with \"merge coverage\" with the following parameters: It will take about 10 minutes to do the selection for the STOFS3D domain. For STOFS3D, right click on the selected polygons and set \"mesh type\" in \"polygon attributes\" to scalar paving density: Set scalar options using the watershed_resolution scatter dataset from the preparation step: In addition, set the polygon attribute of the \"island\" between Chesapeake Bay and Delaware Bay as \"None\": For SECOFS, \"Constant paving\" with the following parameters is used:","title":"Set watershed resolution"},{"location":"mesh-generation/meshing-for-compound-floods/overview.html","text":"Meshing for a compound flood simulation can be very challenging. It is crucial to accurately and economically resolve the small rivers in the watershed to ensure hydraulic connectivity while minimizing the mesh size. Additionally, flood risk reduction structures such as levees and dams also need to be represented in the mesh. The mesh of STOFS3D has gone through major upgrades from STOFS3D v4 to v6, which serves as a good illustration of different meshing techniques: In the v4 mesh, small watershed rivers are resolved by a 1D representation, using 1D river segments from the National Water Model as feature arcs to guide the meshing. In the v5 mesh, characteristic contours of the DEM are extracted and used to represent river banks and thalwegs. However, extensive manual cleaning is required due to the potential messiness of these contours. In the v6 mesh, the river arcs are automatically generated by using pyDEM and RiverMapper , both of which are included in SCHISM's GitHub repo . Here is another sample v6 mesh that is zoomed in on the complex river network in South Carolina: The meshing procedure used in v6 is preferred due to its minimal need for manual labor and its ability to produce the best mesh quality out of the three versions. The procedure includes three steps: Extracting thalwegs from DEM tiles Generate an SMS map that contains river arcs Meshing in SMS Publication \u00b6 A parallel Python-based tool for meshing watershed rivers at continental scale","title":"Overview"},{"location":"mesh-generation/meshing-for-compound-floods/overview.html#publication","text":"A parallel Python-based tool for meshing watershed rivers at continental scale","title":"Publication"},{"location":"modules/age.html","text":"AGE module is different from other tracer modules in that it works with even number of tracers, with the 1st half being the age tracer concentration and the 2nd half being the corresponding \u2018ages\u2019 (Shen and Haas 2004). The code hardwires the I.C. flag for this module to be \u20181\u2019, i.e. horizontally variable conditions for all tracers specified in AGE_hvar_*.ic . Inside each .ic for the 2nd half of tracers, set a uniform 0 at all nodes. For tracers in the 1st half, the user specifies the age concentration to be either 0 or 1, the latter in specific regions where the age tracers will be continuously injected into the domain. For this reason, we suggest setting all B.C. flags for this module to be \u20180\u2019 in bctides.in . The vertical positions where the age tracers are injected are specified in param.nml in the array level_age(1: ntracer_age/2) ; e.g. for ntracer_age=4 , we may specify: level_age = 9, -999 to inject the 1st age tracer at level 9, and the 2nd tracer at all levels (and the code will reset the tracer concentrations to 1 at the same \u2018injection\u2019 elements and level(s) at each time step). The output flags for the water \u2018age\u2019 in days are specified for half of the total number; e.g., iof_age(1:2)=1, 0 .","title":"AGE"},{"location":"modules/analysis-mode.html","text":"Under this module the user can output several internal arrays inside the code, and this is useful for detailed analysis like momentum and tracer budget etc. We have implemented some commonly requested terms in the momentum and transport equations, which can be found in the code by searching for _ANALYSIS and also in param.nml under iof_ana . The user can also use this module to output additional terms if they are familiar with the source code. Note that invoking this module may slow down the code.","title":"Analysis mode"},{"location":"modules/cosine.html","text":"A complete manual for this module can be found here .","title":"CoSiNe"},{"location":"modules/dvd.html","text":"Klingbeil et al. (2014) proposed a theory of estimating numerically induced mixing coefficients. At the moment we have only implemented this module for 1 tracer (salinity). The I.C. for this module is hardwired to be 0 and the code will set it automatically. The B.C. flags should also be 0 in general, so is the nudging flag. The main output is iof_dvd(1) which corresponds to numerical mixing for salinity in \\(\\text{PSU}^2/s\\) . References Klingbeil, K., Mohammadi-Aragh, M., Gr\u00e4we, U., Burchard, H. (2014) Quantification of spurious dissipation and mixing \u2013 Discrete variance decay in a Finite-Volume framework, Ocean Modelling, https://doi.org/10.1016/j.ocemod.2014.06.001.","title":"DVD"},{"location":"modules/fabm.html","text":"The fabm module is the SCHISM host implementation for the separatly available Framework for Aquatic Biogeochemical models (FABM). Within the FABM framework, a number of host-agnostic ecosystem models have been implemented, such that they work within many different hydrodynamic host models, including a python host and Fortran hosts from zero to three-dimensional, and now including SCHISM. For these hosts, FABM's internal loops are arranged for optimal numerical performance. Obtaining the FABM framework code \u00b6 The FABM framework code is hosted separately, as are some of the ecosystem model codes. The SCHISM host provided here is compatible with both the deprecated version 0 of the FABM framework and the current version 1 . The required FABM code can be downloaded from 1. the official repository https://github.com/fabm-model/fabm 2. our development fork that closely follows the official repository, and includes modularization of some the existing SCHISM modules refactored within FABM. 3. any fork of FABM as of their SHA:048673 (2017-09-15). Compiling with FABM \u00b6 The FABM framework and its contained models are compiled within the SCHISM build when using cmake cmake [...] -DUSE_FABM=ON -DFABM_BASEDIR=/your/path/to/fabm/ Developing a FABM biogeochemical model \u00b6 Documentation on how to implement an ecosystem model in FABM is provided on the FABM wiki page https://github.com/fabm-model/fabm/wiki/Developing-a-new-biogeochemical-model Implementation of SCHISM as a FABM host \u00b6 Calls to FABM infrastructure from Hydro/schism_init.F90 \u00b6 Initialization of FABM schism_init.F90 calls fabm_schism_init_model and gets back the number of tracers to be transported. This step reads the FABM configuration, specifically the files fabm.yaml and fabm_schism.in . The FABM package is initialized, which builds up its infrastructure tree. Now, FABM knows how many state variables, surface state variables, bottom state variables and diagnostic variables are required. | Post-Initialization of FABM At this stage, the necessary arrays are allocated within SCHISM by the routine fabm_schism_init_stage2 . Pointers to the state variables and forcings are set for FABM, further arrays are allocated based on the grid layout. An output netcdf file is created by fabm_schism_create_output_netcdf to store diagnostics and bottom state variables. This netcdf file can also used for hotstart, however this step can be merged into SCHISM's netcdf infrastructure now. | Initialize concentrations fabm_schism_init_concentrations is called to set the initial concentrations from the FABM configuration. Read 2D hotstart data from netcdf With fabm_schism_read_horizontal_state_from_netcdf , the 2d hotstart information, e.g. for bottom state variable concentrations on elements, is read from a global netcdf. | Calls to FABM infrastructure from Hydro/schism_step.F90 \u00b6 During the integration, SCHISM calls FABM to get the rates of change of the state variables and the swimming and sinking speeds of moving state variables at each timestep based on the current environmental conditions. Most of the forcing (e.g. temperature) can be linked during the initialization. Currently, the bottom stress in the element center is calculated exclusively for FABM within schism_step.F90 . timestep call The major call to FABMs ecosystem models within schism_step.F90 using fabm_schism_do . Within this call, the light conditions are calculated, further forcing is updated in FABM, diagnostic variables are updated, the rates of change of state variables are collected from FABM and put into the bdy_frc , flux_bt , and flux_sf arrays. The current swimming and sinking speeds are taken from FABM and put into the wsett array. The changes of bottom and surface state variables are calculated with a simple Euler integration step, which is a potentially weak feature. The temporal integration of bottom and surface state variables can potentially improved, e.g. iterated if necessary. | write output by SCHISM All state variables are written by writeout_nc at each output time step by SCHISM's output infrastructure. write specific output The routine fabm_schism_write_output_netcdf is called for the output timesteps. The diagnostic variables to be written are collected before, which includes temporal averaging, if required. This step can be merged into the SCHISM output infrastructure.","title":"FABM"},{"location":"modules/fabm.html#obtaining-the-fabm-framework-code","text":"The FABM framework code is hosted separately, as are some of the ecosystem model codes. The SCHISM host provided here is compatible with both the deprecated version 0 of the FABM framework and the current version 1 . The required FABM code can be downloaded from 1. the official repository https://github.com/fabm-model/fabm 2. our development fork that closely follows the official repository, and includes modularization of some the existing SCHISM modules refactored within FABM. 3. any fork of FABM as of their SHA:048673 (2017-09-15).","title":"Obtaining the FABM framework code"},{"location":"modules/fabm.html#compiling-with-fabm","text":"The FABM framework and its contained models are compiled within the SCHISM build when using cmake cmake [...] -DUSE_FABM=ON -DFABM_BASEDIR=/your/path/to/fabm/","title":"Compiling with FABM"},{"location":"modules/fabm.html#developing-a-fabm-biogeochemical-model","text":"Documentation on how to implement an ecosystem model in FABM is provided on the FABM wiki page https://github.com/fabm-model/fabm/wiki/Developing-a-new-biogeochemical-model","title":"Developing a FABM biogeochemical model"},{"location":"modules/fabm.html#implementation-of-schism-as-a-fabm-host","text":"","title":"Implementation of SCHISM as a FABM host"},{"location":"modules/fabm.html#calls-to-fabm-infrastructure-from-hydroschism_initf90","text":"Initialization of FABM schism_init.F90 calls fabm_schism_init_model and gets back the number of tracers to be transported. This step reads the FABM configuration, specifically the files fabm.yaml and fabm_schism.in . The FABM package is initialized, which builds up its infrastructure tree. Now, FABM knows how many state variables, surface state variables, bottom state variables and diagnostic variables are required. | Post-Initialization of FABM At this stage, the necessary arrays are allocated within SCHISM by the routine fabm_schism_init_stage2 . Pointers to the state variables and forcings are set for FABM, further arrays are allocated based on the grid layout. An output netcdf file is created by fabm_schism_create_output_netcdf to store diagnostics and bottom state variables. This netcdf file can also used for hotstart, however this step can be merged into SCHISM's netcdf infrastructure now. | Initialize concentrations fabm_schism_init_concentrations is called to set the initial concentrations from the FABM configuration. Read 2D hotstart data from netcdf With fabm_schism_read_horizontal_state_from_netcdf , the 2d hotstart information, e.g. for bottom state variable concentrations on elements, is read from a global netcdf. |","title":"Calls to FABM infrastructure from Hydro/schism_init.F90"},{"location":"modules/fabm.html#calls-to-fabm-infrastructure-from-hydroschism_stepf90","text":"During the integration, SCHISM calls FABM to get the rates of change of the state variables and the swimming and sinking speeds of moving state variables at each timestep based on the current environmental conditions. Most of the forcing (e.g. temperature) can be linked during the initialization. Currently, the bottom stress in the element center is calculated exclusively for FABM within schism_step.F90 . timestep call The major call to FABMs ecosystem models within schism_step.F90 using fabm_schism_do . Within this call, the light conditions are calculated, further forcing is updated in FABM, diagnostic variables are updated, the rates of change of state variables are collected from FABM and put into the bdy_frc , flux_bt , and flux_sf arrays. The current swimming and sinking speeds are taken from FABM and put into the wsett array. The changes of bottom and surface state variables are calculated with a simple Euler integration step, which is a potentially weak feature. The temporal integration of bottom and surface state variables can potentially improved, e.g. iterated if necessary. | write output by SCHISM All state variables are written by writeout_nc at each output time step by SCHISM's output infrastructure. write specific output The routine fabm_schism_write_output_netcdf is called for the output timesteps. The diagnostic variables to be written are collected before, which includes temporal averaging, if required. This step can be merged into the SCHISM output infrastructure.","title":"Calls to FABM infrastructure from Hydro/schism_step.F90"},{"location":"modules/generic-tracer.html","text":"We provide this module to users as template for potential addition of behavior etc. As is, the module simulates multiple classes of passive tracers with constant settling velocity gen_wsett ( gen_wsett <0 =>swimming velocity), with no body forces and zero fluxes at surface and bottom. The number of generic tracers is specified as ntracer_gen . I.C. flag is flag_ic(3) , and nudging flag is inu_tr(3) in param.nml . The output flags are iof_gen(1:ntracer_gen) .","title":"Generic tracer module"},{"location":"modules/hydraulics.html","text":"The manual for this module can be found here .","title":"Hydraulics"},{"location":"modules/icm.html","text":"State variables and sub-modules in ICM \u00b6 Core Module 1 PB1 : Diatom g/m^3 2 PB2 : Green Algae g/m^3 3 PB3 : Cyanobacteria g/m^3 4 RPOC : Refractory Particulate Organic Carbon g/m^3 5 LPOC : Labile Particulate Organic Carbon g/m^3 6 DOC : Dissolved Orgnaic Carbon g/m^3 7 RPON : Refractory Particulate Organic Nitrogen g/m^3 8 LPON : Labile Particulate Organic Nitrogen g/m^3 9 DON : Dissolved Orgnaic Nitrogen g/m^3 10 NH4 : Ammonium Nitrogen g/m^3 11 NO3 : Nitrate Nitrogen g/m^3 12 RPOP : Refractory Particulate Organic Phosphorus g/m^3 13 LPOP : Labile Particulate Organic Phosphorus g/m^3 14 DOP : Dissolved Orgnaic Phosphorus g/m^3 15 PO4 : Total Phosphate g/m^3 16 COD : Chemical Oxygen Demand g/m^3 17 DOX : Dissolved Oxygen g/m^3 Silica Module 1 SU : Particulate Biogenic Silica g/m^3 2 SA : Available Silica g/m^3 Zooplankton Module 1 ZB1 : 1st zooplankton g/m^3 2 ZB2 : 2nd zooplankton g/m^3 pH Module 1 TIC : Total Inorganic Carbon g/m^3 2 ALK : Alkalinity g[CaCO3]/m^3 3 CA : Dissolved Calcium g[CaCO3]/m^3 4 CACO3 : Calcium Carbonate g[CaCO3]/m^3 CBP Module 1 SRPOC : Slow Refractory Particulate Organic Carbon g/m^3 2 SRPON : Slow Refractory Particulate Organic Nitro. g/m^3 3 SRPOP : Slow Refractory Particulate Organic Phosp. g/m^3 4 PIP : Particulate Inorganic Phosphate g/m^3 SAV Module (no transport variables) VEG Module (no transport variables) SFM Module (no transport variables) 1. Core Module \u00b6 1.1 Mass Balance Equations of State Variables in ICM \u00b6 **Note: ** a). settling of variables are addressed in separate section, and not included in the equations below b). When iCBP=0, equations of ( \\(\\text{SRPOC},\\text{SRPON},\\text{SRPOP},\\text{PIP}\\) ) are omiited, and \\((FCP_4^m,FCM_4^m,FNP_5^m,FNM_5^m,FPP_5^m,FPM_5^m)=0, (KC_S,KN_S,KP_S,KP_P)=0\\) Phytoplankton (PB1, PB2, PB3) : \\[\\begin{flalign} & d\\text{PB}^i = \\text{GP}^i-\\text{MT}^i-\\text{PR}^i \\text{ , i=1,3} \\\\ \\end{flalign}\\] Carbon (RPOC, LPOC, DOC) : \\[\\begin{flalign} & d\\text{RPOC} = -KC_1 \\cdot \\text{RPOC}+ \\sum_{m=1,3} \\left( FCP_1^m \\cdot \\text{PR}^m + FCM_1^m \\cdot \\text{MT}^m \\right)\\\\ & d\\text{LPOC} = -KC_2 \\cdot \\text{LPOC}+ \\sum_{m=1,3} \\left( FCP_2^m \\cdot \\text{PR}^m + FCM_2^m \\cdot \\text{MT}^m \\right) \\\\ & \\begin{split} & d\\text{DOC}=KC_1 \\cdot \\text{RPOC}+ KC_2 \\cdot \\text{LPOC} + KC_S \\cdot \\text{SRPOC} -K_{HR} \\cdot \\text{DOC} -Denit \\cdot \\text{DOC} \\\\ & + \\sum_{m=1,3} FCP_3^m \\cdot \\text{PR}^m + \\sum_{m=1,3} \\left[FCM_3^m+ \\left(1-\\sum_{i=1,4} FCM_i^m \\right) \\cdot \\frac{KhDO^m}{DO+KhDO^m} \\right] \\cdot \\text{MT}^m \\\\ & \\end{split} \\\\ & d\\text{SRPOC} = -KC_S \\cdot \\text{SRPOC}+ \\sum_{m=1,3} \\left( FCP_4^m \\cdot \\text{PR}^m + FCM_4^m \\cdot \\text{MT}^m \\right)\\\\ \\end{flalign}\\] Nitrogen (RPON, LPON, DON, NH4, NO3) : \\[\\begin{flalign} & d\\text{RPON} = -KN_1 \\cdot \\text{RPON}+ \\sum_{m=1,3} n2c^m \\cdot \\left( FNP_1^m \\cdot \\text{PR}^m + FNM_1^m \\cdot \\text{MT}^m \\right) \\\\ & d\\text{LPON} = -KN_2 \\cdot \\text{LPON}+ \\sum_{m=1,3} n2c^m \\cdot \\left( FNP_2^m \\cdot \\text{PR}^m + FNM_2^m \\cdot \\text{MT}^m \\right) \\\\ & \\begin{split} & d\\text{DON} = KN_1 \\cdot \\text{RPON} + KN_2 \\cdot \\text{LPON} + KN_S \\cdot \\text{SRPON} -KN_3 \\cdot \\text{DON} \\\\ & + \\sum_{m=1,3} n2c^m \\cdot \\left( FNP_3^m \\cdot \\text{PR}^m + FNM_3^m \\cdot \\text{MT}^m \\right) & \\end{split} \\\\ & d\\text{NH4} = KN_3 \\cdot \\text{DON}-Nit \\cdot \\text{NH4}+ \\sum_{m=1,3} n2c^m \\cdot \\left( FNP_4^m \\cdot \\text{PR}^m + FNM_4^m \\cdot \\text{MT}^m -fPN^m \\cdot \\text{GP}^m \\right) \\\\ & d\\text{NO3} = Nit \\cdot \\text{NH4}-dn2c \\cdot Denit \\cdot \\text{DOC}-\\sum_{m=1,3} n2c^m \\cdot \\left( 1-fPN^m \\right) \\cdot \\text{GP}^m \\\\ & d\\text{SRPON} = -KN_S \\cdot \\text{SRPON}+ \\sum_{m=1,3} n2c^m \\cdot \\left( FNP_5^m \\cdot \\text{PR}^m + FNM_5^m \\cdot \\text{MT}^m \\right)\\\\ \\end{flalign}\\] Phosphorus (RPOP, LPOP, DOP, PO4) : \\[\\begin{flalign} & d\\text{RPOP}= -KP_1 \\cdot \\text{RPOP}+ \\sum_{m=1,3} p2c^m \\cdot \\left( FPP_1^m \\cdot \\text{PR}^m + FPM_1^m \\cdot \\text{MT}^m \\right) \\\\ & d\\text{LPOP}= -KP_2 \\cdot \\text{LPOP}+ \\sum_{m=1,3} p2c^m \\cdot \\left( FPP_2^m \\cdot \\text{PR}^m + FPM_2^m \\cdot \\text{MT}^m \\right) \\\\ & \\begin{split} & d\\text{DOP} = KP_1 \\cdot \\text{RPOP} + KP_2 \\cdot \\text{LPOP} + KP_S \\cdot \\text{SRPOP} -KP_3 \\cdot \\text{DOP} \\\\ & + \\sum_{m=1,3} p2c^m \\cdot \\left( FPP_3^m \\cdot \\text{PR}^m + FPM_3^m \\cdot \\text{MT}^m \\right) & \\end{split} \\\\ & d\\text{PO4} = KP_3 \\cdot \\text{DOP} + KP_P \\cdot \\text{PIP} + \\sum_{m=1,3} p2c^m \\cdot \\left( FPP_4^m \\cdot \\text{PR}^m + FPM_4^m \\cdot \\text{MT}^m - \\text{GP}^m \\right) \\\\ & d\\text{SRPOP} = -KP_S \\cdot \\text{SRPOP}+ \\sum_{m=1,3} p2c^m \\cdot \\left( FPP_5^m \\cdot \\text{PR}^m + FPM_5^m \\cdot \\text{MT}^m \\right)\\\\ & d\\text{PIP} = -KP_P \\cdot \\text{PIP} \\\\ \\end{flalign}\\] Oxygen (COD, DO) : \\[\\begin{flalign} & d\\text{COD} = -K_{COD} \\cdot \\text{COD} \\\\ & \\begin{split} \\\\ & d\\text{DO} = -o2n \\cdot Nit \\cdot \\text{NH4} -o2c \\cdot K_{HR} \\cdot \\text{DOC} -K_{COD} \\cdot \\text{COD} \\\\ & + \\sum_{m=1,3} o2c \\cdot \\left[ \\left(1.3-0.3 \\cdot fPN^m \\right) \\cdot \\text{GP}^m -\\left(1- \\sum_{i=1,4} FCM_i^m \\right) \\cdot \\frac{DO}{DO+KhDO^m} \\cdot \\text{MT}^m \\right] \\\\ & \\end{split} \\\\ \\end{flalign}\\] 1.2. Pre-Calculation \u00b6 1.2.1. Growth, metabolism, predation \u00b6 \\[\\begin{flalign} & \\text{GP}^i = \\text{GPM}^i \\cdot f(T) \\cdot f(Sal) \\cdot f(I) \\cdot \\text{min} \\left[ f(N),f(P),f(S) \\right] \\cdot \\text{PB}^i \\\\ & \\text{MT}^i = \\text{MTR}^i \\cdot \\text{GP} +\\text{MTB}^i \\cdot \\text{exp} \\left[ KT_{MT}^i \\cdot \\left( T-T_{MT}^i \\right) \\right] \\cdot \\text{PB}^i \\\\ & \\text{PR}^i = \\begin{cases} & \\text{PRR}^i \\cdot \\text{exp} \\left[ KT_{MT}^i \\cdot \\left( T-T_{MT}^i \\right) \\right] \\cdot \\text{PB}^i \\text{, iPR=0} \\\\ & \\text{PRR}^i \\cdot \\text{exp} \\left[ KT_{MT}^i \\cdot \\left( T-T_{MT}^i \\right) \\right] \\cdot \\left( \\text{PB}^i \\right)^2 \\text{, iPR=1} \\\\ \\end{cases} \\\\ \\end{flalign}\\] \\[\\begin{flalign} & f(I)= \\frac{\\text{mLight}}{\\sqrt{\\text{mLight}^2+IK^2}} \\\\ & f(T)= \\begin{cases} \\text{exp}\\left[-KTGP_1^i \\cdot \\left( T-TGP^i \\right)^2 \\right] \\text{, if }T < TGP^i \\\\ \\text{exp}\\left[-KTGP_2^i \\cdot \\left( T-TGP^i \\right)^2 \\right] \\text{, if }T \\geq TGP^i \\\\ \\end{cases} \\\\ & f(N)= \\frac{\\text{DIN}}{\\text{DIN}+KhN^i} \\\\ & f(P)= \\frac{\\text{PO4d}}{\\text{PO4d}+KhP^i} \\\\ & f(Sal)= \\frac{KhSal_i^2}{KhSal_i^2+Sal^2} \\\\ \\end{flalign}\\] 1.2.2. Decay rates of orgnaic matter \u00b6 \\[\\begin{flalign} & KC_i = \\left( KC_i^0+KC_i^{alg} \\cdot APB \\right) \\cdot KT_M \\\\ & KN_i = \\left( KN_i^0+KN_i^{alg} \\cdot APB \\cdot \\frac{mKhN}{mKhN+DIN} \\right) \\cdot KT_M \\\\ & KP_i = \\left( KP_i^0+KP_i^{alg} \\cdot APB \\cdot \\frac{mKhP}{mKhP+PO4_d} \\right) \\cdot KT_M \\\\ \\end{flalign}\\] \\[\\begin{flalign} KT_M=\\text{exp} \\left[ KT_{RM}^i \\cdot \\left( T-T_{RM}^i \\right) \\right] \\end{flalign}\\] 1.2.3. Respiration, denitrification, decay of COD, nitrification \u00b6 \\[\\begin{flalign} & K_{HR} = KC_3 \\cdot \\frac{DO}{KhDO_{OX}+DO} \\\\ & K_{COD}= \\frac{DO}{KhCOD+DO} \\cdot KCD \\cdot \\text{exp}[KT_{RCOD} \\cdot (T-T_{RCOD})] \\\\ & Denit = an2c \\cdot KC_3 \\cdot \\frac{KhDO_{OX}}{KhDO_{OX}+DO} \\cdot \\frac{NO3}{KhNO3_{dn}+NO3} \\\\ & Nit = Nit^{max} \\cdot \\frac{DO}{KhDO_n+DO} \\cdot \\frac{KhNH4_n}{KhNH4_n+NH4} \\cdot \\begin{cases} \\text{exp}[-KT_{Nit}^1 \\cdot (T_{Nit}-T)] \\text{, if } T<T_{Nit} \\\\ \\text{exp}[-KT_{Nit}^2 \\cdot (T-T_{Nit})] \\text{, if } T \\geq T_{Nit}\\\\ \\end{cases} \\end{flalign}\\] 1.3 Light \u00b6 1.4 Surface/bottom fluxes \u00b6 DO reareation \u00b6 1.4 2D spatially varying parameters \u00b6 1.6 TSS \u00b6 Old User Guide of ICM . \u00b6","title":"ICM"},{"location":"modules/icm.html#state-variables-and-sub-modules-in-icm","text":"Core Module 1 PB1 : Diatom g/m^3 2 PB2 : Green Algae g/m^3 3 PB3 : Cyanobacteria g/m^3 4 RPOC : Refractory Particulate Organic Carbon g/m^3 5 LPOC : Labile Particulate Organic Carbon g/m^3 6 DOC : Dissolved Orgnaic Carbon g/m^3 7 RPON : Refractory Particulate Organic Nitrogen g/m^3 8 LPON : Labile Particulate Organic Nitrogen g/m^3 9 DON : Dissolved Orgnaic Nitrogen g/m^3 10 NH4 : Ammonium Nitrogen g/m^3 11 NO3 : Nitrate Nitrogen g/m^3 12 RPOP : Refractory Particulate Organic Phosphorus g/m^3 13 LPOP : Labile Particulate Organic Phosphorus g/m^3 14 DOP : Dissolved Orgnaic Phosphorus g/m^3 15 PO4 : Total Phosphate g/m^3 16 COD : Chemical Oxygen Demand g/m^3 17 DOX : Dissolved Oxygen g/m^3 Silica Module 1 SU : Particulate Biogenic Silica g/m^3 2 SA : Available Silica g/m^3 Zooplankton Module 1 ZB1 : 1st zooplankton g/m^3 2 ZB2 : 2nd zooplankton g/m^3 pH Module 1 TIC : Total Inorganic Carbon g/m^3 2 ALK : Alkalinity g[CaCO3]/m^3 3 CA : Dissolved Calcium g[CaCO3]/m^3 4 CACO3 : Calcium Carbonate g[CaCO3]/m^3 CBP Module 1 SRPOC : Slow Refractory Particulate Organic Carbon g/m^3 2 SRPON : Slow Refractory Particulate Organic Nitro. g/m^3 3 SRPOP : Slow Refractory Particulate Organic Phosp. g/m^3 4 PIP : Particulate Inorganic Phosphate g/m^3 SAV Module (no transport variables) VEG Module (no transport variables) SFM Module (no transport variables)","title":"State variables and sub-modules in ICM"},{"location":"modules/icm.html#1-core-module","text":"","title":"1. Core Module"},{"location":"modules/icm.html#11-mass-balance-equations-of-state-variables-in-icm","text":"**Note: ** a). settling of variables are addressed in separate section, and not included in the equations below b). When iCBP=0, equations of ( \\(\\text{SRPOC},\\text{SRPON},\\text{SRPOP},\\text{PIP}\\) ) are omiited, and \\((FCP_4^m,FCM_4^m,FNP_5^m,FNM_5^m,FPP_5^m,FPM_5^m)=0, (KC_S,KN_S,KP_S,KP_P)=0\\) Phytoplankton (PB1, PB2, PB3) : \\[\\begin{flalign} & d\\text{PB}^i = \\text{GP}^i-\\text{MT}^i-\\text{PR}^i \\text{ , i=1,3} \\\\ \\end{flalign}\\] Carbon (RPOC, LPOC, DOC) : \\[\\begin{flalign} & d\\text{RPOC} = -KC_1 \\cdot \\text{RPOC}+ \\sum_{m=1,3} \\left( FCP_1^m \\cdot \\text{PR}^m + FCM_1^m \\cdot \\text{MT}^m \\right)\\\\ & d\\text{LPOC} = -KC_2 \\cdot \\text{LPOC}+ \\sum_{m=1,3} \\left( FCP_2^m \\cdot \\text{PR}^m + FCM_2^m \\cdot \\text{MT}^m \\right) \\\\ & \\begin{split} & d\\text{DOC}=KC_1 \\cdot \\text{RPOC}+ KC_2 \\cdot \\text{LPOC} + KC_S \\cdot \\text{SRPOC} -K_{HR} \\cdot \\text{DOC} -Denit \\cdot \\text{DOC} \\\\ & + \\sum_{m=1,3} FCP_3^m \\cdot \\text{PR}^m + \\sum_{m=1,3} \\left[FCM_3^m+ \\left(1-\\sum_{i=1,4} FCM_i^m \\right) \\cdot \\frac{KhDO^m}{DO+KhDO^m} \\right] \\cdot \\text{MT}^m \\\\ & \\end{split} \\\\ & d\\text{SRPOC} = -KC_S \\cdot \\text{SRPOC}+ \\sum_{m=1,3} \\left( FCP_4^m \\cdot \\text{PR}^m + FCM_4^m \\cdot \\text{MT}^m \\right)\\\\ \\end{flalign}\\] Nitrogen (RPON, LPON, DON, NH4, NO3) : \\[\\begin{flalign} & d\\text{RPON} = -KN_1 \\cdot \\text{RPON}+ \\sum_{m=1,3} n2c^m \\cdot \\left( FNP_1^m \\cdot \\text{PR}^m + FNM_1^m \\cdot \\text{MT}^m \\right) \\\\ & d\\text{LPON} = -KN_2 \\cdot \\text{LPON}+ \\sum_{m=1,3} n2c^m \\cdot \\left( FNP_2^m \\cdot \\text{PR}^m + FNM_2^m \\cdot \\text{MT}^m \\right) \\\\ & \\begin{split} & d\\text{DON} = KN_1 \\cdot \\text{RPON} + KN_2 \\cdot \\text{LPON} + KN_S \\cdot \\text{SRPON} -KN_3 \\cdot \\text{DON} \\\\ & + \\sum_{m=1,3} n2c^m \\cdot \\left( FNP_3^m \\cdot \\text{PR}^m + FNM_3^m \\cdot \\text{MT}^m \\right) & \\end{split} \\\\ & d\\text{NH4} = KN_3 \\cdot \\text{DON}-Nit \\cdot \\text{NH4}+ \\sum_{m=1,3} n2c^m \\cdot \\left( FNP_4^m \\cdot \\text{PR}^m + FNM_4^m \\cdot \\text{MT}^m -fPN^m \\cdot \\text{GP}^m \\right) \\\\ & d\\text{NO3} = Nit \\cdot \\text{NH4}-dn2c \\cdot Denit \\cdot \\text{DOC}-\\sum_{m=1,3} n2c^m \\cdot \\left( 1-fPN^m \\right) \\cdot \\text{GP}^m \\\\ & d\\text{SRPON} = -KN_S \\cdot \\text{SRPON}+ \\sum_{m=1,3} n2c^m \\cdot \\left( FNP_5^m \\cdot \\text{PR}^m + FNM_5^m \\cdot \\text{MT}^m \\right)\\\\ \\end{flalign}\\] Phosphorus (RPOP, LPOP, DOP, PO4) : \\[\\begin{flalign} & d\\text{RPOP}= -KP_1 \\cdot \\text{RPOP}+ \\sum_{m=1,3} p2c^m \\cdot \\left( FPP_1^m \\cdot \\text{PR}^m + FPM_1^m \\cdot \\text{MT}^m \\right) \\\\ & d\\text{LPOP}= -KP_2 \\cdot \\text{LPOP}+ \\sum_{m=1,3} p2c^m \\cdot \\left( FPP_2^m \\cdot \\text{PR}^m + FPM_2^m \\cdot \\text{MT}^m \\right) \\\\ & \\begin{split} & d\\text{DOP} = KP_1 \\cdot \\text{RPOP} + KP_2 \\cdot \\text{LPOP} + KP_S \\cdot \\text{SRPOP} -KP_3 \\cdot \\text{DOP} \\\\ & + \\sum_{m=1,3} p2c^m \\cdot \\left( FPP_3^m \\cdot \\text{PR}^m + FPM_3^m \\cdot \\text{MT}^m \\right) & \\end{split} \\\\ & d\\text{PO4} = KP_3 \\cdot \\text{DOP} + KP_P \\cdot \\text{PIP} + \\sum_{m=1,3} p2c^m \\cdot \\left( FPP_4^m \\cdot \\text{PR}^m + FPM_4^m \\cdot \\text{MT}^m - \\text{GP}^m \\right) \\\\ & d\\text{SRPOP} = -KP_S \\cdot \\text{SRPOP}+ \\sum_{m=1,3} p2c^m \\cdot \\left( FPP_5^m \\cdot \\text{PR}^m + FPM_5^m \\cdot \\text{MT}^m \\right)\\\\ & d\\text{PIP} = -KP_P \\cdot \\text{PIP} \\\\ \\end{flalign}\\] Oxygen (COD, DO) : \\[\\begin{flalign} & d\\text{COD} = -K_{COD} \\cdot \\text{COD} \\\\ & \\begin{split} \\\\ & d\\text{DO} = -o2n \\cdot Nit \\cdot \\text{NH4} -o2c \\cdot K_{HR} \\cdot \\text{DOC} -K_{COD} \\cdot \\text{COD} \\\\ & + \\sum_{m=1,3} o2c \\cdot \\left[ \\left(1.3-0.3 \\cdot fPN^m \\right) \\cdot \\text{GP}^m -\\left(1- \\sum_{i=1,4} FCM_i^m \\right) \\cdot \\frac{DO}{DO+KhDO^m} \\cdot \\text{MT}^m \\right] \\\\ & \\end{split} \\\\ \\end{flalign}\\]","title":"1.1 Mass Balance Equations of State Variables in ICM"},{"location":"modules/icm.html#12-pre-calculation","text":"","title":"1.2. Pre-Calculation"},{"location":"modules/icm.html#121-growth-metabolism-predation","text":"\\[\\begin{flalign} & \\text{GP}^i = \\text{GPM}^i \\cdot f(T) \\cdot f(Sal) \\cdot f(I) \\cdot \\text{min} \\left[ f(N),f(P),f(S) \\right] \\cdot \\text{PB}^i \\\\ & \\text{MT}^i = \\text{MTR}^i \\cdot \\text{GP} +\\text{MTB}^i \\cdot \\text{exp} \\left[ KT_{MT}^i \\cdot \\left( T-T_{MT}^i \\right) \\right] \\cdot \\text{PB}^i \\\\ & \\text{PR}^i = \\begin{cases} & \\text{PRR}^i \\cdot \\text{exp} \\left[ KT_{MT}^i \\cdot \\left( T-T_{MT}^i \\right) \\right] \\cdot \\text{PB}^i \\text{, iPR=0} \\\\ & \\text{PRR}^i \\cdot \\text{exp} \\left[ KT_{MT}^i \\cdot \\left( T-T_{MT}^i \\right) \\right] \\cdot \\left( \\text{PB}^i \\right)^2 \\text{, iPR=1} \\\\ \\end{cases} \\\\ \\end{flalign}\\] \\[\\begin{flalign} & f(I)= \\frac{\\text{mLight}}{\\sqrt{\\text{mLight}^2+IK^2}} \\\\ & f(T)= \\begin{cases} \\text{exp}\\left[-KTGP_1^i \\cdot \\left( T-TGP^i \\right)^2 \\right] \\text{, if }T < TGP^i \\\\ \\text{exp}\\left[-KTGP_2^i \\cdot \\left( T-TGP^i \\right)^2 \\right] \\text{, if }T \\geq TGP^i \\\\ \\end{cases} \\\\ & f(N)= \\frac{\\text{DIN}}{\\text{DIN}+KhN^i} \\\\ & f(P)= \\frac{\\text{PO4d}}{\\text{PO4d}+KhP^i} \\\\ & f(Sal)= \\frac{KhSal_i^2}{KhSal_i^2+Sal^2} \\\\ \\end{flalign}\\]","title":"1.2.1. Growth, metabolism, predation"},{"location":"modules/icm.html#122-decay-rates-of-orgnaic-matter","text":"\\[\\begin{flalign} & KC_i = \\left( KC_i^0+KC_i^{alg} \\cdot APB \\right) \\cdot KT_M \\\\ & KN_i = \\left( KN_i^0+KN_i^{alg} \\cdot APB \\cdot \\frac{mKhN}{mKhN+DIN} \\right) \\cdot KT_M \\\\ & KP_i = \\left( KP_i^0+KP_i^{alg} \\cdot APB \\cdot \\frac{mKhP}{mKhP+PO4_d} \\right) \\cdot KT_M \\\\ \\end{flalign}\\] \\[\\begin{flalign} KT_M=\\text{exp} \\left[ KT_{RM}^i \\cdot \\left( T-T_{RM}^i \\right) \\right] \\end{flalign}\\]","title":"1.2.2. Decay rates of orgnaic matter"},{"location":"modules/icm.html#123-respiration-denitrification-decay-of-cod-nitrification","text":"\\[\\begin{flalign} & K_{HR} = KC_3 \\cdot \\frac{DO}{KhDO_{OX}+DO} \\\\ & K_{COD}= \\frac{DO}{KhCOD+DO} \\cdot KCD \\cdot \\text{exp}[KT_{RCOD} \\cdot (T-T_{RCOD})] \\\\ & Denit = an2c \\cdot KC_3 \\cdot \\frac{KhDO_{OX}}{KhDO_{OX}+DO} \\cdot \\frac{NO3}{KhNO3_{dn}+NO3} \\\\ & Nit = Nit^{max} \\cdot \\frac{DO}{KhDO_n+DO} \\cdot \\frac{KhNH4_n}{KhNH4_n+NH4} \\cdot \\begin{cases} \\text{exp}[-KT_{Nit}^1 \\cdot (T_{Nit}-T)] \\text{, if } T<T_{Nit} \\\\ \\text{exp}[-KT_{Nit}^2 \\cdot (T-T_{Nit})] \\text{, if } T \\geq T_{Nit}\\\\ \\end{cases} \\end{flalign}\\]","title":"1.2.3. Respiration, denitrification, decay of COD, nitrification"},{"location":"modules/icm.html#13-light","text":"","title":"1.3 Light"},{"location":"modules/icm.html#14-surfacebottom-fluxes","text":"","title":"1.4 Surface/bottom fluxes"},{"location":"modules/icm.html#do-reareation","text":"","title":"DO reareation"},{"location":"modules/icm.html#14-2d-spatially-varying-parameters","text":"","title":"1.4 2D spatially varying parameters"},{"location":"modules/icm.html#16-tss","text":"","title":"1.6 TSS"},{"location":"modules/icm.html#old-user-guide-of-icm","text":"","title":"Old User Guide of ICM."},{"location":"modules/marsh-migration.html","text":"This module ( USE_MARSH ) is not a tracer module and simulates the long-term migration of marshes under sea level rise. It is usually invoked together with SED (with optional morphological acceleration) and optionally with WWM; cf. Nunez et al. (2020) . The only parameter for this module is slr_rate (sea-level rise rate in mm/yr). The output flag is iof_marsh , which is an integer of either 0 (no marsh) or 1 (has marsh) at an element. Optionally, the user might also consider invoking the vegetation option in the code isav in conjunction with the marsh module to simulate the form drag and turbulence induced by the marsh vegetation. Additional inputs are required to specify the I.C. for marsh extent ( marsh_init.prop ) as well as migration barrier info ( marsh_barrier.prop ); both use 0 or 1 to specify \u2018on/off\u2019. References Nunez, K., Zhang, Y., Herman, J., Reay, W. and Hershner, C. (2020) A multi-scale approach for simulating tidal marsh evolution, Ocean Dynamics, https://doi.org/10.1007/s10236-020-01380-6","title":"Marsh migration"},{"location":"modules/overview.html","text":"Attention Note that some modules are under active development and we will update the info as it becomes available. SCHISM modules can be broadly divided into two categories: tracer and non-tracer modules. The main difference is that tracer modules share more infrastructure with the main hydro code base, e.g. using the transport solver, with I.C. and B.C.\u2019s that resemble those for the temperature and salinity, and sharing the source inputs ( msource.th ). Most modules also require additional inputs of their own (e.g. wwminput.nml for WWM). There are 12 tracer modules and they are (in order of appearance and precedence in bctides.in ; the names in brackets are used in input names; e.g. TEM_1.th etc) - Temperature [ TEM ] Salinity [ SAL ] Generic tracer [ GEN ]: generic tracer module with a settle velocity gen_wsett in param.nml ). The user can use this module as a template to add their own tracer behavior etc (by modifying the code sections bounded by USE_GEN ); AGE [ AGE ]: water age module of Delhez & Deleersnijder (2002) and Shen and Haas (2004); SED3D [ SED ]: 3D non-cohesive sediment transport module; EcoSim [ ECO ]: EcoSim of Paul Bissett; ICM [ ICM ]: USACE\u2019s water quality model of CE-QUAL-ICM CoSINE [ COS ]: Carbon, Silicate, Nitrogen Ecosystem model of Prof. Fei Chai (U. of Maine) Fecalbacteria [ FIB ]: fecal indicating bacteria model; TIMOR: not active at the moment FABM [ FBM ]: Framework for Aquatic Biogeochemical Models, a flexible biogeochemical model framework; DVD [ DVD ]: numerical mixing analysis of Klingbeit et al. (2014) The B.C. flags for each invoked tracer module are specified in bctides.in . For example, if you invoked GEN (1 class), SED (1 class), and ICM (21 state variables inside), the boundary condition at an open segment may look like - 39 2 0 3 4 1 2 2 ![# of nodes], elev, vel, T,S, GEN, SED, ICM 0.5 !constant elev 0.1 !relax for T 0.1 !relax for S 0.5 !relax for GEN 0. !constant SED concentration 1.e-3 !relax for SED 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. !ICM concentrations 1.e-3 !relax for ICM [next segment...] And in addition, you\u2019ll need to prepare inputs: SAL_3D.th.nc and GEN_*.th . Similarly, msource.th should also include the tracer concentrations for all invoked modules; for the example shown above, a line in the msource.th should look like this (assuming 2 sources in source_sink.in): 86400. 10. 10. 0. 0. -9999. -9999. 0. 0. -9999. ...-9999. !time (sec), T, S, GEN, SED, ICM <-------------> 21x2 values for ICM For some tracer modules the user also needs to specify number of tracer classes inside the module in param.nml : ntracer_gen = 2 !user defined module (USE_GEN) ntracer_age = 4 !age calculation (USE_AGE). Must be =2*N where N is # of age tracers sed_class = 5 !SED3D (USE_SED) eco_class = 27 !EcoSim The output flags for all modules are iof_[name] , where name is the lower case of the module name; e.g. iof_wwm() . See the sample param.nml for a complete list of output flags as well as the variable names that appear in the netcdf outputs. Some modules have additional parameters specified in param.nml ; e.g., gen_wsett , flag_fib etc. See the sample param.nml for explanation.","title":"Overview"},{"location":"modules/pahm.html","text":"The manual for Parametric Hurricane Modeling System (PaHM) can be found here","title":"PaHM"},{"location":"modules/particle-tracking.html","text":"This is not a module per se; rather the stand-alone code Utility/Particle_Tracking/ptrack*.f90 takes the outputs from SCHISM. SCHISM supports a 3D particle tracking, which can also be used for simple oil spill simulation. The code can do forward/backward tracking and has simple dispersion and beach retention processes for oil spill. The inputs to this code are: hgrid.gr3 , vgrid.in , particle.bp , and schout*.nc . The main parameters are set in particle.bp . Below is a sample: 1 !screen outputs 0 !mod_part (0: passive; 1: oil spill) 1 !ibf (forward (=1) or backward (=-1) tracking) 1 !istiff (1: fixed distance from free surface) 1 -124 46.25 !ics slam0 sfea0 (see param.nml) 0.1 8. 90. 10 960 9 ! h0, rnday, dt, nspool, ihfskip, ndeltp (same as param.nml except for the last one, which is # of sub-divisions within each step) 16 !# number of particles 1 84600. 385000 510000 -5. !particle id, start time (s), starting x,y, and z relative to the instant surface (<=0) 2 84610. 300000 450000 0. ... The main output is particle.pth , which uses the drogue format that can be visualized with ACE/xmvis6. Figure 1 shows an example. Particle tracking with SCHISM.","title":"Particle tracking"},{"location":"modules/sed2d.html","text":"The manual for this module can be found here . This module may be eventualy removed as users can use SED3D under polymorphism.","title":"2D Sediment model"},{"location":"modules/sed3d.html","text":"The 3D sediment model inside SCHISM (USE_SED, also referred to as \u2018SED3D\u2019 sometimes to differentiate it from the 2D sediment module \u2018SED2D\u2019) is adapted from Community Sediment Transport Model ( Warner et al. 2008 ). The algorithm is implemented on UGs and we have also reworked several components and added a morphological module (Exner equation). Detailed are reported in Pinto et al. (2012) . Also note that for best results this module should be run in conjunction with the wave model (WWM) to account for the wave-enhanced bottom stress. The main parameter input is sediment.nml , which is a namelist file. The sample file has comments /explanations for each parameter; a few important ones are explained below: sed_morph : This parameter controls active morphology. Nbed : The # of bed layers affects the stability of the sorting, and Nbed=1 works robustly with sed_morph>0 . Other inputs include sed_class and output flags in param.nml , and a few .ic files: bedthick.ic , bed_frac_[1,2..].ic , and I.C. for concentrations of all classes ( *_[hvar]_[1,2\u2026].ic or ( *_[vvar]_[1,2\u2026].ic ). The B.C. inputs may include SED_[1,2..].th , SED_3D.th.nc . The nudging inputs may be SED_nudge.gr3 and SED_nu.nc . The outputs from SED3D can be combined and visualized just as other SCHISM outputs. A common crash occurs when the active morphology is on. At a river inflow boundary, often the depths will decrease over time due to deposition there and eventually the boundary will become dry/blocked. A work-around is to use a combination of \u2018bare-rock\u2019 bed around the boundary (specified in bedthick.ic ), and \u2018clear-water\u2019 inflow as B.C. (sediment concentration =0 in bctides.in ) , and then input the incoming sediment concentration as point sources ( msource.th ) a distance away from the boundary. References Pinto, L., Fortunato, A.B., Zhang, Y., Oliveira, A. and Sancho, F.E.P. (2012) Development and validation of a three-dimensional morphodynamic modelling system, Ocean Mod., 57-58, 1-14. Warner, J.C., Sherwood, C.R., Signell, R.P., Harris, C.K., Arango, H.G. 2008. Development of a three-dimensional, regional, coupled wave, current, and sediment-transport model. Comput. Geosci. 34 (10), 1284\u20131306. doi: 10.1016/j.cageo.2008.02.012","title":"3D Sediment model"},{"location":"modules/single-class-ice.html","text":"Theory \u00b6 The single-class ice/snow module is taken from FESOM2, courtesy of Dr. Sergey Danilov's group. The info below is from the FESOM2 manual with minor modifications to show some new additions. Dynamical part solves the ice motion equation: \\[\\begin{equation} \\label{ice01} m(\\partial_t + \\pmb{f} \\times) \\pmb{u}=a\\tau - aC_d\\rho_o (\\pmb{u}-\\pmb{u}_o)|\\pmb{u}-\\pmb{u}_o| +\\pmb{F} -mg\\nabla H \\end{equation}\\] Here \\(m\\) is the ice plus snow mass per unit area, \\(C_d\\) the ice-ocean drag coefficient, \\(\\rho_o\\) the water density, \\(a\\) the ice compactness, \\(\\pmb{u}\\) and \\(\\pmb{u}_o\\) the ice and ocean velocities, \\(\\tau\\) the wind stress, \\(H\\) the sea surface elevation, \\(g\\) the acceleration due to gravity and \\(F_j = \\partial_i \\sigma_{ij}\\) is the force from stresses within the ice. Here we use Cartesian coordinates for brevity, with \\(i, j = 1, 2\\) implying \\(x\\) and \\(y\\) directions, and the implementation of spherical coordinates will be discussed further. Summation over repeating coordinate indices is implied. The stress tensor is symmetric. The mass \\(m\\) is the combination of ice and snow contributions \\[\\begin{equation} m=\\rho_{ice}h_{ice}+\\rho_sh_s \\end{equation}\\] with \\(\\rho_{ice}\\) and \\(\\rho_s\\) , respectively, the densities of ice and snow and \\(h_{ice}\\) and \\(h_s\\) their mean thicknesses (volumes per unit area). For the visco-plastic (VP) rheology (Hibler, 1979) one writes \\[\\begin{equation} \\label{ice02} \\sigma_{ij}=2\\eta (\\dot{\\epsilon}_{ij} -0.5 \\delta_{ij} \\dot{\\epsilon}_{kk}) + \\zeta \\delta_{ij} \\dot{\\epsilon}_{kk} -0.5\\delta_{ij} P \\end{equation}\\] where \\[\\begin{equation} \\dot{\\epsilon}_{ij}=0.5(\\partial u_i / \\partial x_j + \\partial u_j / \\partial x_i) \\end{equation}\\] is the deformation rate tensor, \\(\\eta\\) and \\(\\zeta\\) are the moduli (\u2018viscosities\u2019) and \\(P\\) the pressure. Both the stress and deformation rate tensors are symmetric, so they are characterized by three independent components. The standard VP rheology adopts the following scheme of computing pressure \\(P\\) and moduli \\(\\eta\\) and \\(\\zeta\\) : \\[\\begin{equation} P_0=h_{ice}p^* exp[-C(1-a)], P=P_0\\frac{\\Delta}{(\\Delta+\\Delta_{min}}, \\zeta=\\frac{0.5P_0}{\\Delta+\\Delta_{min}}, \\eta=\\frac{\\zeta}{e^2} \\end{equation}\\] \\(e=2\\) (the ellipticity parameter), \\(C=20\\) , \\(\\Delta_{min}=2.e-9 s^{-1}\\) , and \\(p^*=15000 Pa\\) are default values, they are adjusted in practice. In this scheme, \\(\\Delta_{min}\\) serves for viscous regularization of plastic behavior in areas where \\(\\Delta t\\) is very small. We note that recent multi-category ice implementations (such as CICE, see Hunke and Lipscomb 2008) use different parameterization for \\(P_0\\) , which takes into account the distribution of ice over thickness categories. This does not change the basic equations ( \\(\\ref{ice01}\\) , \\(\\ref{ice02}\\) ). In our case we deal with three tracers, the area coverage \\(a\\) , ice volume \\(h_{ice}\\) and snow volume \\(h_s\\) . They are advected with ice velocities and modified through thermodynamical forcing \\[\\begin{equation} \\label{ice03} \\partial_t a+\\nabla(a\\pmb{u})=S_a, \\partial_t h_{ice}+\\nabla(h_{ice}\\pmb{u})=S_{ice}, \\partial_t h_s+\\nabla(h_s\\pmb{u})=S_s \\end{equation}\\] with \\(S_a\\) , \\(S_{ice}\\) and \\(S_s\\) the sources due to the exchange with atmosphere and ocean. The system ( \\(\\ref{ice01}, \\ref{ice02}, \\ref{ice03}\\) ), augmented with appropriate model of sources and boundary conditions, defines the sea ice model. We use the boundary conditions of no slip for momentum and no flux for tracers at lateral walls. The well known difficulty in solving these equation is related to the rheology term in the momentum equation, which makes this equation very stiff and would require time steps of fractions of second if stepped explicitly. There are two ways of handling this difficulty. The first one treats the rheology part in an implicit way, with linearization for the moduli, as suggested by Zhang and Hibler (1997). As mentioned elsewhere (see, e. g., Lemieux and Tremblay, 2009), it does not warrant full convergence, which requires a full nonlinear solver (for example, a Jacobian-free Newton-Krylov one, see Lemieux et al. 2012). The latter is still too expensive computationally, so the VP option used by us is similar in spirit to that of Zhang and Hibler (see section 2.4). The second way is to reformulate the VP approach by adding pseudo-elasticity. It raises the time order of the system \\(\\ref{ice01}, \\ref{ice02}\\) to the second, which makes the CFL limitation on the explicit time step much less severe than in the original VP framework. Below is the formulation for a modified elastic-visco-plastic (mEVP) due to Bouillon et al. (2013). It can be considered as a pseudo-time solver for VP rheology. In this case one writes \\[\\begin{equation} \\begin{aligned} \\alpha (\\sigma_1^{p+1} - \\sigma_1^{p})=\\frac{P_0}{\\Delta^p+\\Delta_{min}} (\\dot{\\epsilon}_1^p -\\Delta^p)-\\sigma_1^{p} \\\\ \\alpha (\\sigma_2^{p+1} - \\sigma_2^{p})=\\frac{P_0}{(\\Delta^p+\\Delta_{min})e^2} \\dot{\\epsilon}_2p -\\sigma_2^{p} \\\\ \\alpha (\\sigma_{12}^{p+1} - \\sigma_{12}^{p})=\\frac{P_0}{(\\Delta^p+\\Delta_{min})e^2} \\dot{\\epsilon}_{12}^p -\\sigma_{12}^{p} \\end{aligned} \\end{equation}\\] for stresses and \\[\\begin{equation} \\beta(\\pmb{u}^{p+1}-\\pmb{u}^p)=-\\pmb{u}^{p+1}+\\pmb{u}^n-\\Delta t \\pmb{f}\\times \\pmb{u}^{p+1}+\\frac{\\Delta t}{m}[\\pmb{F}^{p+1}+a\\tau+C_da\\rho_o(\\pmb{u}_o^n-\\pmb{u}^{p+1})|\\pmb{u}_o^n-\\pmb{u}^p| -mg\\nabla H^n] \\end{equation}\\] for velocity. We define: \\[\\begin{equation} \\sigma_1=\\sigma_{11}+\\sigma_{22}, \\sigma_2=\\sigma_{11}-\\sigma_{22} \\end{equation}\\] and similarly for deformation: \\[\\begin{equation} \\dot{\\epsilon}_1=\\dot{\\epsilon}_{11}+\\dot{\\epsilon}_{22}, \\dot{\\epsilon}_2=\\dot{\\epsilon}_{11}-\\dot{\\epsilon}_{22} \\end{equation}\\] Here \\(\\alpha\\) and \\(\\beta\\) are some large constants. The subscript \\(p\\) is related to pseudotime iterations, replacing subcycling of the standard EVP, and \\(n\\) is the previous time step. Fields are initialized with values at time step \\(n\\) for \\(p = 1\\) , and their values for the last iteration \\(p = N_{EVP}\\) are taken as solutions for time step \\(n+ 1\\) . Clearly, if \\(N_{EVP}\\) is sufficiently large, the VP solutions have to be recovered. In order that CFL limitations be satisfied, the product \\(\\alpha\\beta\\) should be sufficiently large (see Bouillon et al. (2013)). The regime of the standard EVP scheme ( \\(N_{EVP} = 120\\) and \\(T_{EVP} = \\Delta t/3\\) ) will be approximately recovered for \\(\\alpha =\\beta = 40\\) and \\(N_{EVP} = 120\\) , but much larger values have to be used on fine meshes to warrant absence of noise. For this reason, in SCHISM we have added a new option where \\(\\alpha\\) and \\(\\beta\\) are functions of the mesh size: \\[\\begin{equation} \\alpha =\\beta=\\frac{C}{tanh(BA/\\Delta t_{ice})} \\end{equation}\\] where \\(A\\) is element area, \\(C\\) is the minimum, and \\(B\\) is an adjustable coefficient that controls how quickly \\(\\alpha\\) and \\(\\beta\\) depart from their minimum, \\(\\Delta t_{ice}\\) is the time step used in the ice model. One expects that if this scheme is stable and converged, it should produce solutions identical to those of converging VP solver. In reality, it will not be run for full convergence, which is still too expensive, and some difference will be preserved. The sea-ice model described here implements the three approaches mentioned above, which will be referred further as VP, EVP and mEVP. The reason of keeping all them is two-fold. First, it facilitates the comparison of results with other models which may be using one of these approaches. Second, their numerical efficiency and performance depend on applications, and one may wish to select the most appropriate approach. The tracer transport equation ( \\(\\ref{ice03}\\) ) is solved using a FCT scheme. Usage \u00b6 Compile with USE_ICE on; The time step for this moule is controlled by nstep_ice in param.nml . In addition, the output handles are found in SCHOUT section. The code will compute the ice-ocean stress at cells covered by ice; The main parameter input for this module is ice.nml (you can find a sample in sample_inputs/ ), where you specify the ice thermodynamic constants etc. You can specify the new mEVP option with mevp_coef . Control dispersion/diffusion in transport by using the parameters in ice.nml and ice_fct.gr3 . This is important for very fine mesh size. References \u00b6 Bouillon, S., Fichefet, T., Legat, V., Madec, G., 2013. The elastic-viscous-plastic method revisited, Ocean Modelling 71, 2\u201312. Lemieux, J.-F., Knoll, D., Tremblay, B., Holland, D., Losch, M., 2012. A comparison of the Jacobian-free Newton\u2013Krylov method and the EVP model for solving the sea ice momentum equation with a viscous-plastic formulation: a serial algorithm study. Journal of Computational Physics 231 (17), 5926\u20135944. Lemieux, J.-F., Tremblay, B., 2009. Numerical convergence of viscousplastic sea ice models. Journal of Geophysical Research 114, C05009. Zhang, J., Hibler, W.D, On an efficient numerical method for modeling sea ice dynamics, J. Geophys. Res., 102, 8691\u20138702, 1997.","title":"Single-class ice module"},{"location":"modules/single-class-ice.html#theory","text":"The single-class ice/snow module is taken from FESOM2, courtesy of Dr. Sergey Danilov's group. The info below is from the FESOM2 manual with minor modifications to show some new additions. Dynamical part solves the ice motion equation: \\[\\begin{equation} \\label{ice01} m(\\partial_t + \\pmb{f} \\times) \\pmb{u}=a\\tau - aC_d\\rho_o (\\pmb{u}-\\pmb{u}_o)|\\pmb{u}-\\pmb{u}_o| +\\pmb{F} -mg\\nabla H \\end{equation}\\] Here \\(m\\) is the ice plus snow mass per unit area, \\(C_d\\) the ice-ocean drag coefficient, \\(\\rho_o\\) the water density, \\(a\\) the ice compactness, \\(\\pmb{u}\\) and \\(\\pmb{u}_o\\) the ice and ocean velocities, \\(\\tau\\) the wind stress, \\(H\\) the sea surface elevation, \\(g\\) the acceleration due to gravity and \\(F_j = \\partial_i \\sigma_{ij}\\) is the force from stresses within the ice. Here we use Cartesian coordinates for brevity, with \\(i, j = 1, 2\\) implying \\(x\\) and \\(y\\) directions, and the implementation of spherical coordinates will be discussed further. Summation over repeating coordinate indices is implied. The stress tensor is symmetric. The mass \\(m\\) is the combination of ice and snow contributions \\[\\begin{equation} m=\\rho_{ice}h_{ice}+\\rho_sh_s \\end{equation}\\] with \\(\\rho_{ice}\\) and \\(\\rho_s\\) , respectively, the densities of ice and snow and \\(h_{ice}\\) and \\(h_s\\) their mean thicknesses (volumes per unit area). For the visco-plastic (VP) rheology (Hibler, 1979) one writes \\[\\begin{equation} \\label{ice02} \\sigma_{ij}=2\\eta (\\dot{\\epsilon}_{ij} -0.5 \\delta_{ij} \\dot{\\epsilon}_{kk}) + \\zeta \\delta_{ij} \\dot{\\epsilon}_{kk} -0.5\\delta_{ij} P \\end{equation}\\] where \\[\\begin{equation} \\dot{\\epsilon}_{ij}=0.5(\\partial u_i / \\partial x_j + \\partial u_j / \\partial x_i) \\end{equation}\\] is the deformation rate tensor, \\(\\eta\\) and \\(\\zeta\\) are the moduli (\u2018viscosities\u2019) and \\(P\\) the pressure. Both the stress and deformation rate tensors are symmetric, so they are characterized by three independent components. The standard VP rheology adopts the following scheme of computing pressure \\(P\\) and moduli \\(\\eta\\) and \\(\\zeta\\) : \\[\\begin{equation} P_0=h_{ice}p^* exp[-C(1-a)], P=P_0\\frac{\\Delta}{(\\Delta+\\Delta_{min}}, \\zeta=\\frac{0.5P_0}{\\Delta+\\Delta_{min}}, \\eta=\\frac{\\zeta}{e^2} \\end{equation}\\] \\(e=2\\) (the ellipticity parameter), \\(C=20\\) , \\(\\Delta_{min}=2.e-9 s^{-1}\\) , and \\(p^*=15000 Pa\\) are default values, they are adjusted in practice. In this scheme, \\(\\Delta_{min}\\) serves for viscous regularization of plastic behavior in areas where \\(\\Delta t\\) is very small. We note that recent multi-category ice implementations (such as CICE, see Hunke and Lipscomb 2008) use different parameterization for \\(P_0\\) , which takes into account the distribution of ice over thickness categories. This does not change the basic equations ( \\(\\ref{ice01}\\) , \\(\\ref{ice02}\\) ). In our case we deal with three tracers, the area coverage \\(a\\) , ice volume \\(h_{ice}\\) and snow volume \\(h_s\\) . They are advected with ice velocities and modified through thermodynamical forcing \\[\\begin{equation} \\label{ice03} \\partial_t a+\\nabla(a\\pmb{u})=S_a, \\partial_t h_{ice}+\\nabla(h_{ice}\\pmb{u})=S_{ice}, \\partial_t h_s+\\nabla(h_s\\pmb{u})=S_s \\end{equation}\\] with \\(S_a\\) , \\(S_{ice}\\) and \\(S_s\\) the sources due to the exchange with atmosphere and ocean. The system ( \\(\\ref{ice01}, \\ref{ice02}, \\ref{ice03}\\) ), augmented with appropriate model of sources and boundary conditions, defines the sea ice model. We use the boundary conditions of no slip for momentum and no flux for tracers at lateral walls. The well known difficulty in solving these equation is related to the rheology term in the momentum equation, which makes this equation very stiff and would require time steps of fractions of second if stepped explicitly. There are two ways of handling this difficulty. The first one treats the rheology part in an implicit way, with linearization for the moduli, as suggested by Zhang and Hibler (1997). As mentioned elsewhere (see, e. g., Lemieux and Tremblay, 2009), it does not warrant full convergence, which requires a full nonlinear solver (for example, a Jacobian-free Newton-Krylov one, see Lemieux et al. 2012). The latter is still too expensive computationally, so the VP option used by us is similar in spirit to that of Zhang and Hibler (see section 2.4). The second way is to reformulate the VP approach by adding pseudo-elasticity. It raises the time order of the system \\(\\ref{ice01}, \\ref{ice02}\\) to the second, which makes the CFL limitation on the explicit time step much less severe than in the original VP framework. Below is the formulation for a modified elastic-visco-plastic (mEVP) due to Bouillon et al. (2013). It can be considered as a pseudo-time solver for VP rheology. In this case one writes \\[\\begin{equation} \\begin{aligned} \\alpha (\\sigma_1^{p+1} - \\sigma_1^{p})=\\frac{P_0}{\\Delta^p+\\Delta_{min}} (\\dot{\\epsilon}_1^p -\\Delta^p)-\\sigma_1^{p} \\\\ \\alpha (\\sigma_2^{p+1} - \\sigma_2^{p})=\\frac{P_0}{(\\Delta^p+\\Delta_{min})e^2} \\dot{\\epsilon}_2p -\\sigma_2^{p} \\\\ \\alpha (\\sigma_{12}^{p+1} - \\sigma_{12}^{p})=\\frac{P_0}{(\\Delta^p+\\Delta_{min})e^2} \\dot{\\epsilon}_{12}^p -\\sigma_{12}^{p} \\end{aligned} \\end{equation}\\] for stresses and \\[\\begin{equation} \\beta(\\pmb{u}^{p+1}-\\pmb{u}^p)=-\\pmb{u}^{p+1}+\\pmb{u}^n-\\Delta t \\pmb{f}\\times \\pmb{u}^{p+1}+\\frac{\\Delta t}{m}[\\pmb{F}^{p+1}+a\\tau+C_da\\rho_o(\\pmb{u}_o^n-\\pmb{u}^{p+1})|\\pmb{u}_o^n-\\pmb{u}^p| -mg\\nabla H^n] \\end{equation}\\] for velocity. We define: \\[\\begin{equation} \\sigma_1=\\sigma_{11}+\\sigma_{22}, \\sigma_2=\\sigma_{11}-\\sigma_{22} \\end{equation}\\] and similarly for deformation: \\[\\begin{equation} \\dot{\\epsilon}_1=\\dot{\\epsilon}_{11}+\\dot{\\epsilon}_{22}, \\dot{\\epsilon}_2=\\dot{\\epsilon}_{11}-\\dot{\\epsilon}_{22} \\end{equation}\\] Here \\(\\alpha\\) and \\(\\beta\\) are some large constants. The subscript \\(p\\) is related to pseudotime iterations, replacing subcycling of the standard EVP, and \\(n\\) is the previous time step. Fields are initialized with values at time step \\(n\\) for \\(p = 1\\) , and their values for the last iteration \\(p = N_{EVP}\\) are taken as solutions for time step \\(n+ 1\\) . Clearly, if \\(N_{EVP}\\) is sufficiently large, the VP solutions have to be recovered. In order that CFL limitations be satisfied, the product \\(\\alpha\\beta\\) should be sufficiently large (see Bouillon et al. (2013)). The regime of the standard EVP scheme ( \\(N_{EVP} = 120\\) and \\(T_{EVP} = \\Delta t/3\\) ) will be approximately recovered for \\(\\alpha =\\beta = 40\\) and \\(N_{EVP} = 120\\) , but much larger values have to be used on fine meshes to warrant absence of noise. For this reason, in SCHISM we have added a new option where \\(\\alpha\\) and \\(\\beta\\) are functions of the mesh size: \\[\\begin{equation} \\alpha =\\beta=\\frac{C}{tanh(BA/\\Delta t_{ice})} \\end{equation}\\] where \\(A\\) is element area, \\(C\\) is the minimum, and \\(B\\) is an adjustable coefficient that controls how quickly \\(\\alpha\\) and \\(\\beta\\) depart from their minimum, \\(\\Delta t_{ice}\\) is the time step used in the ice model. One expects that if this scheme is stable and converged, it should produce solutions identical to those of converging VP solver. In reality, it will not be run for full convergence, which is still too expensive, and some difference will be preserved. The sea-ice model described here implements the three approaches mentioned above, which will be referred further as VP, EVP and mEVP. The reason of keeping all them is two-fold. First, it facilitates the comparison of results with other models which may be using one of these approaches. Second, their numerical efficiency and performance depend on applications, and one may wish to select the most appropriate approach. The tracer transport equation ( \\(\\ref{ice03}\\) ) is solved using a FCT scheme.","title":"Theory"},{"location":"modules/single-class-ice.html#usage","text":"Compile with USE_ICE on; The time step for this moule is controlled by nstep_ice in param.nml . In addition, the output handles are found in SCHOUT section. The code will compute the ice-ocean stress at cells covered by ice; The main parameter input for this module is ice.nml (you can find a sample in sample_inputs/ ), where you specify the ice thermodynamic constants etc. You can specify the new mEVP option with mevp_coef . Control dispersion/diffusion in transport by using the parameters in ice.nml and ice_fct.gr3 . This is important for very fine mesh size.","title":"Usage"},{"location":"modules/single-class-ice.html#references","text":"Bouillon, S., Fichefet, T., Legat, V., Madec, G., 2013. The elastic-viscous-plastic method revisited, Ocean Modelling 71, 2\u201312. Lemieux, J.-F., Knoll, D., Tremblay, B., Holland, D., Losch, M., 2012. A comparison of the Jacobian-free Newton\u2013Krylov method and the EVP model for solving the sea ice momentum equation with a viscous-plastic formulation: a serial algorithm study. Journal of Computational Physics 231 (17), 5926\u20135944. Lemieux, J.-F., Tremblay, B., 2009. Numerical convergence of viscousplastic sea ice models. Journal of Geophysical Research 114, C05009. Zhang, J., Hibler, W.D, On an efficient numerical method for modeling sea ice dynamics, J. Geophys. Res., 102, 8691\u20138702, 1997.","title":"References"},{"location":"modules/wwm.html","text":"A preliminary (but outdated) manual for this module can be found in: src/WWMIII/Manual/manual.tex . For the detailed theory and numerical methods used in WWM, you can consult Dr. Aron Roland\u2019s PhD thesis . Note A good resource for beginners is a mini live manual by Ms. Christelle Auguste (U. of Tasmania).","title":"WWM"},{"location":"schism/barotropic-solver.html","text":"General formulation \u00b6 SCHISM solves the barotropic equations first ( Eqs 1-3 ) first, as the transport and turbulent closure equations lag one time step behind (in other words, the baroclinic pressure gradient term in the momentum equation is treated explicitly in SCHISM). The transport and turbulent closure equations will be discussed later. Due to the hydrostatic approximation, the vertical velocity \\(w\\) is solved from the 3D continuity equation after the horizontal velocity is found. To solve the coupled Eqs. 1 and 3 , we first discretize them and the vertical boundary conditions semi-implicitly in time as - \\[\\begin{equation} \\label{eq01} \\frac{\\eta^{n+1} - \\eta^{n}}{\\Delta t} + \\theta \\nabla \\cdot \\int_{-h}^{\\eta} \\pmb{u}^{n+1} dz + (1-\\theta) \\nabla \\cdot \\int_{-h}^{\\eta} \\pmb{u}^{n} dz = 0 \\end{equation}\\] \\[\\begin{equation} \\label{eq02} \\frac{\\pmb{u}^{n+1} - \\pmb{u}^*}{\\Delta t} = \\pmb{f} - g \\theta \\nabla \\eta^{n+1} - g(1-\\theta)\\nabla\\eta^n + \\pmb{m}_z^{n+1} - \\alpha\\left|\\pmb{u}\\right|\\pmb{u}^{n+1} L(x, y, z) \\end{equation}\\] \\[\\begin{equation} \\label{eq03} \\begin{aligned} \\text{for 3D cells: } \\begin{cases} \\nu^n \\frac{\\partial \\pmb{u}^{n+1}}{\\partial z} = \\pmb{\\tau}_{w}^{n+1}, \\text{ at } z=\\eta^n\\\\ \\nu^n \\frac{\\partial \\pmb{u}^{n+1}}{\\partial z} = \\chi^n \\pmb{u}_{b}^{n+1}, \\text{ at } z=-h \\end{cases} \\end{aligned} \\end{equation}\\] where superscripts denote the time step, \\(0 \\leq \\theta \\leq 1\\) is the implicitness factor, \\(\\pmb{u}^*(x, y, z, t^n)\\) is the back-tracked value calculated with Eulerian-Lagrangian Method (ELM; see here ), and \\(\\chi^n = C_D \\left| \\pmb{u}_{b}^{n} \\right|\\) . The elevations in the 2nd and 3rd terms of Eq. \\(\\ref{eq01}\\) are treated explicitly, which effectively amounts to a linearization procedure. A Galerkin weighted residual statement in the weak form for Eq. \\(\\ref{eq01}\\) reads: \\[\\begin{equation} \\label{eq04} \\int_\\Omega \\phi_i \\frac{\\eta^{n+1} - \\eta^{n}}{\\Delta t} d\\Omega + \\theta \\left[ -\\int_\\Omega \\nabla \\phi_i \\cdot \\pmb{U}^{n+1} d\\Omega + \\int_\\Gamma \\phi_i U_n^{n+1} d\\Gamma \\right] + (1-\\theta) \\left[ -\\int_\\Omega \\nabla \\phi_i \\cdot \\pmb{U}^{n} d\\Omega + \\int_\\Gamma \\phi_i U_n^n d\\Gamma \\right] = 0, (i = 1, ... , N_p) \\end{equation}\\] Where \\(N_p\\) is the total number of nodes, \\(\\Gamma \\equiv \\Gamma_\\nu + \\overline{\\Gamma}_\\nu\\) is the boundary of the entire domain \\(\\Omega\\) , with \\(\\Gamma_\\nu\\) corresponding to the boundary sagments where natural boundary conditions are specified, \\(\\pmb{U} = \\int_{-h}^{\\eta} \\pmb{u}dz\\) is the depth-integrated velocity, \\(U_n\\) is its normal component along the boundary, and \\(\\hat{U}_n\\) is the boundary condition. In SCHISM, linear shape functions are used (area coordinates for triangles and bi-linear function for quads); thus, \\(\\phi_i\\) are familier \"hat\" functions. Locally 2D case \u00b6 Since there is only one degree of freedom in the vertical dimention in this case, a straightforward integration of Eq. \\(\\ref{eq02}\\) gives - \\[\\begin{equation} \\label{eq05} \\pmb{U}^{n+1} = \\check{\\pmb{G}} - g\\theta\\Delta t \\frac{H^2}{\\tilde{H}} \\nabla \\eta^{n+1} \\end{equation}\\] Where \\(\\check{\\pmb{G}}\\) incorporates explicit term - \\[\\begin{equation} \\label{eq06} \\check{\\pmb{G}} = \\frac{H}{\\tilde{H}}\\left[ \\pmb{U}^* + \\Delta t \\left( \\pmb{F} + \\pmb{\\tau}_w - g(1-\\theta)H\\nabla\\eta^n \\right) \\right] \\end{equation}\\] and \\(\\pmb{F}\\) is the depth integrated term of \\(\\pmb{f}\\) , and \\(\\tilde{H}\\) is the depth enhanced by the bottom friction and form drag - \\[\\begin{equation} \\label{eq07} \\tilde{H} = H + \\left( \\chi + \\alpha \\left| \\pmb{u} \\right| H\\right)\\Delta t \\end{equation}\\] The net effect of the vegetation is therefore equivalent to increase in the bottom drag, since the 3D structure of the flow/vegetation is not accounted for. Substituting Eq. \\(\\ref{eq05}\\) into Eq. \\(\\ref{eq04}\\) results in an integral equation for the unknown \\(\\eta^{n+1}\\) alone. Locally 3D case \u00b6 We first integrate Eq. \\(\\ref{eq02}\\) from bottom to surface - \\[\\begin{equation} \\label{eq08} \\frac{\\pmb{U}^{n+1}-\\pmb{U}^*}{\\Delta t} = \\pmb{F} - gH\\theta\\nabla\\eta^{n+1} - gH(1-\\theta)\\nabla\\eta^n + \\pmb{\\tau}_w - \\chi\\pmb{u}_b^{n+1} - \\alpha\\overline{\\left| \\pmb{u} \\right|} \\pmb{U}^{\\alpha} \\end{equation}\\] where we have performed linearization of the vegetation term - \\[\\begin{equation} \\label{eq09} \\int_{-h}^{z_v} \\left|\\pmb{u}\\right|\\pmb{u}dz \\approx \\overline{\\left| \\pmb{u} \\right|} \\equiv \\overline{\\left| \\pmb{u} \\right|} \\pmb{U}^{\\alpha} , (\\text{where, }\\pmb{U}^{\\alpha} = \\int_{-h}^{z_v}\\pmb{u}dz) \\end{equation}\\] \\[\\begin{equation} \\label{eq10} \\overline{\\left| \\pmb{u} \\right|} = \\frac{1}{H^\\alpha} \\int_{-h}{z_v} \\left| \\pmb{u}^n \\right| dz \\end{equation}\\] and \\(H^\\alpha = z_v +h\\) is the height of vegetation. Note that similar procedures have been used for other nonlinear terms (e.g. the quadratic bottom drag). To eliminate \\(\\pmb{u}_b^{n+1}\\) in Eq \\(\\ref{eq08}\\) , we invoke the discretized momentum equation at the bottom cell and utilize the fact that the Reynolds stress is constant within the boundary layer, as shown in Zhang and Baptista (2008) - \\[\\begin{equation} \\label{eq11} \\frac{\\pmb{u}_b^{n+1} - \\pmb{u}_b^*}{\\Delta t} = \\pmb{f}_b - g\\theta\\nabla\\eta^{n+1} - g(1-\\theta)\\nabla\\eta^n - \\alpha\\left|\\pmb{u}_b\\right|\\pmb{u}_b^{n+1} \\end{equation}\\] from which \\(\\pmb{u}_b^{n+1}\\) can be formally solved as - \\[\\begin{equation} \\label{eq12} \\pmb{u}_b^{n+1} = \\frac{1}{1+\\alpha\\left|\\pmb{u}_b\\right|\\Delta t} \\left[\\pmb{u}_b^* +\\pmb{f}_b\\Delta t - g(1-\\theta)\\Delta t \\nabla \\eta^n \\right] - \\frac{g\\theta\\Delta t}{1+\\alpha\\left|\\pmb{u}_b\\right|\\Delta t}\\nabla\\eta^{n+1} \\end{equation}\\] The subscript \\(b\\) denotes the top of the bottom cell. Note that the main difference from the original formulation of Zhang and Baptista (2008) is the appearance of the vegetation term. The remaining task is to find \\(\\pmb{U}^\\alpha\\) . We\u2019ll discuss two scenarios of submerged and emergent vegetation. Emergent vegetation \u00b6 When the vegetation is locally emergent, i.e., \\(H^\\alpha \\geq H\\) , we have \\(\\pmb{U}^\\alpha = \\pmb{U}^{n+1}\\) , and therefore \\(\\pmb{U}^{n+1}\\) can be found from Eq. \\(\\ref{eq08}\\) and \\(\\ref{eq12}\\) as - \\[\\begin{equation} \\label{eq13} \\pmb{U}^{n+1} = \\pmb{G}_1 - \\frac{g\\theta\\hat{H}\\Delta t}{1+\\alpha\\overline{\\left| \\pmb{u} \\right|} \\Delta t} \\nabla\\eta^{n+1} \\end{equation}\\] where \\(\\pmb{G}_1\\) contains explicit terms - \\[\\begin{equation} \\label{eq14} \\pmb{G}_1 = \\frac{\\pmb{U}^* + (\\pmb{F}+\\pmb{\\tau}_w)\\Delta t - g(1-\\theta)\\hat{H}\\Delta t \\nabla\\eta^n-\\tilde{\\chi}\\Delta t (\\pmb{u}_b^*+\\pmb{f}_b\\Delta t)}{1+\\alpha\\overline{\\left| \\pmb{u} \\right|} \\Delta t} \\end{equation}\\] \\[\\begin{equation} \\label{eq15} \\tilde{\\chi} = \\frac{\\chi}{1+\\alpha \\left| \\pmb{u}_b \\right| \\Delta t} \\end{equation}\\] and \\(\\hat{H}\\) is a friction modified depth - \\[\\begin{equation} \\label{eq16} \\hat{H} = H - \\tilde{\\chi}\\Delta t \\end{equation}\\] Compared to the original formulation in Zhang and Baptista (2008) , the only change in this depth is the vegetation term in \\(\\tilde{\\chi}\\) . Submerged vegetation \u00b6 When the vegetation is submerged, i.e., \\(H^\\alpha < H\\) , strong shear and turbulence develop between the vegetation and the overlying flow above it ( ST94 ). Nepf and Vivoni (2000) demonstrated that there are two zones for submerged aquatic vegetation (SAV). In the upper canopy (called the \u2018vertical exchange zone\u2019), mean shear at the top of the canopy produces vertical turbulent exchange with the overlying water, which plays a significant role in the momentum balance. The lower canopy (\u2018longitudinal change zone\u2019 as in Nepf and Vivoni, 2000 ) communicates with surrounding water predominantly through longitudinal advection. The extent of the vertical exchange of momentum between the vegetation zone and overlying water is dependent on the submergence. We first integrate the momentum equation (Eq. \\(\\ref{eq02}\\) ) from the bottom to the top of canopy - \\[\\begin{equation} \\label{eq17} \\pmb{U}^\\alpha = \\pmb{U}^{*\\alpha} + \\pmb{F}^\\alpha\\Delta t - g\\theta H^\\alpha \\Delta t \\nabla\\eta^{n+1} - g(1-\\theta)H^\\alpha\\Delta t \\nabla \\eta^n - \\alpha \\Delta t \\overline{\\left| \\pmb{u} \\right|} \\pmb{U}^\\alpha + \\Delta t\\nu \\Bigr\\rvert_{-h}^{z_v} \\end{equation}\\] where \\[\\begin{equation} \\label{eq18} \\begin{aligned} \\pmb{U}^{*\\alpha} = \\int_{-h}^{z_v}\\pmb{u}^* dz\\\\ \\pmb{F}^\\alpha = \\int_{-h}^{z_v}\\pmb{f}dz \\end{aligned} \\end{equation}\\] The Reynolds stress at the top of canopy can be calculated from theory proposed by ST94. These authors found through lab experiments that the stress variation inside the vegetation layer approximately follows an exponential law \\[\\begin{equation} \\label{eq19} \\nu\\frac{\\partial\\pmb{u}}{\\partial z} \\equiv \\overline{u'w'} = \\pmb{R}_0 e^{\\beta_2 (z-z_v)} \\text{ for } z \\leq z_v \\end{equation}\\] where \\(\\pmb{R}_0\\) is the stress at \\(z=z_v\\) , and \\(\\beta_2\\) is determined by an empirical formula - \\[\\begin{equation} \\label{eq20} \\beta_2 = \\sqrt{\\frac{\\sqrt{N_v}}{H^\\alpha}} \\left[ -0.32 - 0.85 \\log_{10} \\left( \\frac{H - H^\\alpha}{H^\\alpha} I\\right) \\right] \\end{equation}\\] where \\(I\\) is an energy gradient - \\[\\begin{equation} \\label{eq21} I = \\frac{\\chi \\left| \\pmb{u}_b \\right|}{gH} \\end{equation}\\] which is estimated from the previous time step in the model. The stress term in Eq. \\(\\ref{eq19}\\) therefore becomes \\[\\begin{equation} \\label{eq22} \\nu\\frac{\\partial\\pmb{u}}{\\partial z}\\Bigr\\rvert_{-h}^{z_v} = \\beta \\chi \\pmb{u}_b^{n+1} \\end{equation}\\] where \\(\\beta = e^{\\beta_2(z_v - z_b)}-1\\) , and \\(z_b\\) is the location of the top of the bottom grid cell. Substituting Eq. \\(\\ref{eq22}\\) and Eq. \\(\\ref{eq12}\\) into Eq. \\(\\ref{eq17}\\) we can solve for \\(\\pmb{U}^\\alpha\\) as - \\[\\begin{equation} \\label{eq23} \\pmb{U}^\\alpha = \\pmb{G}_3 - \\frac{g\\theta\\hat{H}^\\alpha\\Delta t}{1+\\alpha\\overline{\\left| \\pmb{u}\\right|}\\Delta t}\\nabla \\eta^{n+1} \\end{equation}\\] \\[\\begin{equation} \\label{eq24} \\pmb{G}_3 = \\frac{\\pmb{U}^{*\\alpha}+\\pmb{F}^\\alpha\\Delta t + \\beta\\tilde{\\chi}\\Delta t(\\pmb{u}_b^* + \\pmb{f}_b\\Delta t) - g(1-\\theta)\\hat{H}^\\alpha\\Delta t \\nabla \\eta^n}{1+\\alpha\\overline{\\left| \\pmb{u} \\right|}\\Delta t} \\end{equation}\\] \\[\\begin{equation} \\label{eq25} \\hat{H}^\\alpha = H^\\alpha + \\beta\\tilde{\\chi}\\Delta t \\end{equation}\\] Finally, substituting Eq. \\(\\ref{eq23}\\) and Eq. \\(\\ref{eq12}\\) into Eq. \\(\\ref{eq08}\\) results in a relationship between \\(\\pmb{U}^{n+1}\\) and \\(\\eta^{n+1}\\) - \\[\\begin{equation} \\label{eq26} \\pmb{U}^{n+1} = \\pmb{G}_2 - g\\theta\\overline{\\overline{H}}\\Delta t \\nabla \\eta^{n+1} \\end{equation}\\] \\[\\begin{equation} \\label{eq27} \\overline{\\overline{H}} = H - \\tilde{\\chi}\\Delta t - c\\hat{H}^\\alpha \\end{equation}\\] \\[\\begin{equation} \\label{eq28} c = \\frac{\\alpha\\overline{\\left| \\pmb{u} \\right|}\\Delta t}{1 + \\alpha\\overline{\\left| \\pmb{u} \\right|}\\Delta t} \\end{equation}\\] \\[\\begin{equation} \\label{eq29} \\pmb{G}_2 = \\pmb{U}^* - c\\pmb{U}^{*\\alpha} + (\\pmb{F} + \\pmb{\\tau_w})\\Delta t - c\\pmb{F}^\\alpha\\Delta t - \\tilde{\\chi}\\Delta t(1+\\beta c)(\\pmb{u}_b^*+\\pmb{f}_b\\Delta t) - g(1-\\theta)\\overline{\\overline{H}}\\Delta t \\nabla\\eta^n \\end{equation}\\] General case \u00b6 In summary, the depth-integrated velocity can be expressed in compact form as - \\[\\begin{equation} \\label{eq30} \\pmb{U}^{n+1} = \\pmb{E} - g\\theta\\breve{H}\\Delta t\\nabla\\eta^{n+1} \\end{equation}\\] where, \\[\\begin{equation} \\label{eq31} \\begin{aligned} \\breve{H} = \\begin{cases} \\frac{H^2}{\\breve{H}}, \\text{ 2D }\\\\ \\frac{\\hat{H}}{1+\\alpha\\overline{\\left| \\pmb{u} \\right|}\\Delta t}, \\text{ 3D emergent }\\\\ \\overline{\\overline{H}}, \\text{ 3D submerged } \\end{cases} \\end{aligned} \\end{equation}\\] \\[\\begin{equation} \\label{eq32} \\begin{aligned} \\pmb{E} = \\begin{cases} \\breve{\\pmb{G}}, \\text{ 2D }\\\\ \\pmb{G}_1, \\text{ 3D emergent }\\\\ \\pmb{G}_2, \\text{ 3D submerged } \\end{cases} \\end{aligned} \\end{equation}\\] Substituting Eq. \\(\\ref{eq30}\\) back into Eq. \\(\\ref{eq04}\\) gives an equation for the unknown elevations alone - \\[\\begin{equation} \\label{eq33} I_1 = I_4 - \\theta\\Delta t I_3 - (1-\\theta)\\Delta t I_5 - \\theta\\Delta t I_6 \\text{, for } i=1, \\cdots, N_p \\end{equation}\\] where, \\[\\begin{equation} \\label{eq34} I_1 = \\int_\\Omega \\left[ \\phi_i \\eta^{n+1} + g\\theta^2\\Delta t^2\\ \\check{H}\\nabla\\phi_i\\cdot\\nabla\\eta^{n+1}\\right]d\\Omega \\end{equation}\\] \\[\\begin{equation} \\label{eq35} I_4 = \\int_\\Omega \\left[ \\phi_i\\eta^n + \\theta\\Delta t \\nabla\\phi_i\\cdot\\pmb{E} + (1-\\theta)\\Delta t \\nabla\\phi_i \\cdot\\pmb{U}^n \\right]d\\Omega \\end{equation}\\] \\[\\begin{equation} \\label{eq36} I_3 = \\int_{\\Gamma_\\nu} \\phi_i\\hat{U}_n^{n+1}d\\Gamma_\\nu \\end{equation}\\] \\[\\begin{equation} \\label{eq37} I_5 = \\int_\\Gamma \\phi_i U_n^n d\\Gamma \\end{equation}\\] \\[\\begin{equation} \\label{eq38} I_6 = \\int_{\\overline{\\Gamma}_\\nu} \\phi_i U_n^{n+1} d\\overline{\\Gamma}_\\nu \\end{equation}\\] Following standard finite-element procedures, and using appropriate essential and natural boundary conditions, SCHISM solves Eq. \\(\\ref{eq33}\\) to determine the elevations at all nodes. Note that the RHS terms \\(I_{3-6}\\) are known; in the case of \\(I_6\\) , the integrals on \\(\\overline{\\Gamma}_\\nu\\) need not be evaluated since the essential boundary conditions are imposed by eliminating corresponding rows and columns of the matrix. The matrix resulting from Eq. \\(\\ref{eq33}\\) is sparse and symmetric. It is also positive-definite as long as the depth \\(\\breve{H}\\) is non-negative ( ihhat=1 ); numerical experiments indicated that even this restriction can be relaxed for many practical applications that include shallow areas. We show that the addition of vegetation does not introduce additional stability constraint. The effects of the vegetation on \\(\\breve{H}\\) are generally similar to the bottom friction. For the 2D case, \\(\\breve{H}\\) is always positive. For the 3D emergent case, the vegetation term in the denominator is positive and so does not change the sign. For the 3D submerged case, as \\(\\alpha \\rightarrow 0\\) , previous results of Zhang and Baptista (2008) are recovered. As \\(\\alpha \\rightarrow \\infty\\) (i.e., very dense vegetation), the friction term (the second term in Eq. \\(\\ref{eq27}\\) ) dwarfs in comparison with the vegetation term (the third term in Eq. \\(\\ref{eq27}\\) ), and therefore the friction is negligible under dense vegetation. Since \\(c \\rightarrow 1\\) as \\(\\alpha \\rightarrow \\infty\\) , \\(\\breve{H}\\) approaches the submergence \\(H-H^\\alpha\\) , which is positive. When the submergence is very small (i.e. almost emergent vegetation), \\(\\breve{H} \\rightarrow 0\\) and the conditioning of the matrix would somewhat deteriorate but the model remains stable. Physically, this means that very strong shear will develop near the canopy. It\u2019s important to notice that the friction-modified depth is different between 2D and 3D cases, which has implications in shallow depths. We show more details of the evaluation of the integrals \\(I_i\\) below. The corresponding constant for 2D prisms is always positive (see below) and therefore the 2D mode is inherently more stable than 3D mode; consequently, judiciously leveraging SCHISM\u2019s polyphorphism enhances stability near the wetting and drying interface. The matrix can be efficiently solved using a pre-conditioned Conjugate Gradient method ( Casulli and Cattani 1994 ). This simple matrix solver is implemented in SCHISM; alternatively, the efficient parallel matrix solver PETSc can be used for large matrices. In the model, the decision on 2D/3D emergent/3D submerged scenarios is made at each side (where the velocity is defined) based on the total depths from the previous time step and the transition of regimes is handled in the model. Integral \\(I_3\\) \u00b6 This is a boundary integral that only need to be evaluated when the node \\(i\\) is located on an open boundary segment where Neuman-type B.C. is prescribed. Since the unknowns vary linearly along any side, we have (cf. Figure 1 ) - \\[\\begin{equation} \\label{eq39} I_3 = \\sum_j \\frac{L_{ij}}{2} \\sum_{k=kbs}^{N_z-1} \\Delta z_{j,k+1} \\frac{\\hat{u}_{j,k+1}^{n+1} + \\hat{u}_{j,k}^{n+1}}{2} \\end{equation}\\] where the outer sum is carried out along the 2 adjacent open side \\(j\\) , \\(L_{ij}\\) is the side length, \\(\\Delta z_{j,k+1}\\) is the layer thickness along side \\(j\\) , and \\(kbs\\) is the local bottom index. Boundary node i with adjacent sides. If a Flather-type radiation condition ( Flather 1987 ) needs to be applied, it can be done in the following fashion - \\[\\begin{equation} \\label{eq40} \\hat{U}_n^{n+1} - \\overline{U}_n = \\sqrt{\\frac{g}{H}} (\\eta^{n+1} - \\overline{\\eta}) \\end{equation}\\] where \\(\\overline{U}_n\\) and \\(\\overline{\\eta}\\) are specified mean incoming current and mean elevation. Then - \\[\\begin{equation} \\label{eq41} I_3 = \\sum_j \\frac{L_{ij}(\\overline{U}_n)_{ij}}{2} + \\frac{L_{ij}\\sqrt{gH_{ij}}}{6} \\left[ 2(\\eta_i^{n+1} - \\overline{\\eta}_i) + (\\eta_j^{n+1} - \\overline{\\eta}_j) \\right] \\end{equation}\\] In this case, the unknown \\(\\eta^{n+1}\\) need to be moved to the LHS, and the diagonal (associated with \\(\\eta_i^{n+1}\\) ) is enhanced as a result and matrix symmetry is preserved. Integral \\(I_5\\) \u00b6 Similar to \\(I_3\\) , we have - \\[\\begin{equation} \\label{eq42} I_5 = \\sum_j \\frac{L_{ij}}{2} \\sum_{k=kbs}^{N_z-1} \\Delta z_{j, k+1} \\frac{u_{j, k+1}^{n} + u_{j,k}^{n}}{2} \\end{equation}\\] Integral \\(I_1\\) \u00b6 This is the only implicit term. Referring to Figure 2 , we have - \\[\\begin{equation} \\label{eq43} I_1 = \\sum_{j=1}^{Nb(i)} \\sum_{l=1}^{i34(j)} \\eta_{j,l}^{n+1} \\int_{A_j} \\hat{\\phi_{i'}} \\hat{\\phi_l} dA_j + g\\theta^2 \\Delta t^2 \\sum_{j=1}^{Nb(i)} \\overline{\\check{H}_j} \\sum_{l=1}^{i34(j)} \\eta_{j,l}^{n+1} \\int_{A_j} \\nabla\\hat{\\phi_{i'}}\\cdot\\nabla\\hat{\\phi_l} dA_j \\end{equation}\\] Where \\(j\\) is a neighbouring element of \\(i\\) , \\(i'\\) is the local index of node \\(i\\) inside element \\(j\\) , overbar in \\(\\overline{\\check{H}}\\) denotes element averating, and \\(\\hat{\\phi}\\) is the local linear shape function. We discuss the case of a triangle and quad element. Node ball used in calculating integral I 1. Case I: triangle \u00b6 The 2 integrals can be evaluated analytically as - \\[\\begin{equation} \\label{eq44} \\int_{A_j} \\hat{\\phi_{i'}} \\hat{\\phi_l} dA_j = \\frac{1+\\delta_{i',l}}{12}A_j \\end{equation}\\] \\[\\begin{equation} \\label{eq45} \\int_{A_j} \\nabla\\hat{\\phi_{i'}} \\cdot \\nabla\\hat{\\phi_l} dA_j = \\frac{\\vec{i'}\\cdot\\vec{l}}{4A_j} \\end{equation}\\] where \\(\\vec{i'}\\) and \\(\\vec{l}\\) are two vectors along side \\(i'\\) and \\(l\\) respectively, and \\(\\delta_{i',l}\\) is the Kronecker delta - \\[\\begin{equation*} \\delta_{i',l} = \\begin{cases} 1, i' = l \\\\ 0, i' \\neq l \\end{cases} \\end{equation*}\\] Case II: Quad \u00b6 We can analytically evaluate integral Eq. \\(\\ref{eq44}\\) as - \\[\\begin{equation} \\label{eq46} \\int_{A_j} \\hat{\\phi_{i'}}\\hat{\\phi_l}dA_j = \\frac{A_j}{16}\\left(1+\\frac{1}{3}\\xi_{i'}\\xi_l\\right)\\left(1+\\frac{1}{3}\\varsigma_{i'}\\varsigma_l\\right) + \\frac{B_1}{96}\\left(1+\\frac{1}{3}\\varsigma_{i'}\\varsigma_l\\right)\\left(\\xi_{i'}+\\xi_l\\right) + \\frac{B_2}{96}\\left(1+\\frac{1}{3}\\xi_{i'}\\xi_l\\right)\\left(\\varsigma_{i'}+\\varsigma_l\\right) \\end{equation}\\] Where \\((\\xi, \\varsigma)\\) are local coordinates, and \\(B_1\\) and \\(B_2\\) are 2 geometric constants (Figure 3 ) - \\[\\begin{equation} \\label{eq47} \\begin{aligned} B_1 = \\left(\\vec{12}\\times\\vec{43}\\right)_k = \\left(x_2-x_1\\right)\\left(y_3-y_4\\right) - \\left(x_3-x_4\\right)\\left(y_2-y_1\\right)\\\\ B_2 = \\left(\\vec{23}\\times\\vec{14}\\right)_k \\end{aligned} \\end{equation}\\] Quad element and local transformation. The other integral Eq. \\(\\ref{eq45}\\) cannot be evaluated analytically and so we use the 4-point Gauss quadrature. Integral \\(I_4\\) \u00b6 This integral contains most of the explicit terms. Most terms are straightforward to evaluate, e.g., using element averaging or analytical integration (in the case of volume sources/sinks); the integrals involving the shape function or its derivative can be calculated using the similar method as in \\(I_1\\) . Therefore we will only discuss the a few terms below given their importance in SCHISM. Baroclinicity \u00b6 Since a FVM is used to solve the tracers (including T,S) at the prism center, we evaluate the density gradient at prism center via a reconstruction method. Referring to Figure 4 , given a prism center '0', we first project the gradient onto vectors connecting adjacent prism centers - \\[\\begin{equation} \\label{eq48} \\frac{\\partial\\rho}{\\partial x}\\left(x_1-x_0\\right) + \\frac{\\partial\\rho}{\\partial y}\\left(y_1-y_0\\right) = \\rho_1-\\rho_0 \\end{equation}\\] \\[\\begin{equation} \\label{eq49} \\frac{\\partial\\rho}{\\partial x}\\left(x_2-x_0\\right) + \\frac{\\partial\\rho}{\\partial y}\\left(y_2-y_0\\right) = \\rho_2-\\rho_0 \\end{equation}\\] \\[\\begin{equation} \\label{eq50} \\frac{\\partial\\rho}{\\partial x}\\left(x_3-x_0\\right) + \\frac{\\partial\\rho}{\\partial y}\\left(y_3-y_0\\right) = \\rho_3-\\rho_0 \\end{equation}\\] after a cubic spline interpolation has been performed to calculate the density at prism '1' at the same vertical location as \u20180\u2019 (i.e. ( \\(i\\) , \\(k\\) )). Note that if the element \\(i\\) is a quad, we will have 4 equations. We then solve pairs of equations to find for \\(\\nabla\\rho\\) , i.e., Eq. \\(\\ref{eq48}\\) with Eq. \\(\\ref{eq49}\\) , Eq. \\(\\ref{eq49}\\) with Eq. \\(\\ref{eq50}\\) , and Eq. \\(\\ref{eq50}\\) with Eq. \\(\\ref{eq48}\\) . If the 3 centers happen to be co-linear, the equations have no solution and are discarded; however, at least 1 pair has a valid solution. Reconstruction method. i is the element index and k is the vertical index. If a neighbor does not exist (boundary) or is dry, we replace the corresponding equation with the no-flux B.C.; e.g., if AB is such a side, then - \\[\\begin{equation} \\label{eq51} \\frac{\\partial\\rho}{\\partial y}\\left(x_A-x_B\\right) + \\frac{\\partial\\rho}{\\partial x}\\left(y_B-y_A\\right) = 0 \\end{equation}\\] After the density gradients are found at prism centers, a simple linear interpolation in the vertical is used to calculate the gradients at side centers (and half levels). Then the trapezoidal rule is used to compute the baroclinic term: \\(-\\frac{g}{\\rho_0}\\int_z^\\eta\\nabla\\rho dz\\) . This will also be utilized in the solution of the momentum equation. Horizontal viscosity \u00b6 Momentum stabilization is an important consideration in designing advection and viscosity schemes. Zhang et al. (2016) demonstrated that the standard Laplacian viscosity is equivalent to the 5-point Shapiro filter (see below) on uniform grids; however, on non-uniform grids, it may behave like an \u2018amplifier\u2019 and therefore the filter form should be used instead (Figure 5a,b ) - \\[\\begin{equation} \\label{eq52} \\nabla\\cdot\\left(\\mu\\nabla u\\right)\\Biggr|_0 = \\frac{\\mu_0}{\\sqrt{3}A_I}\\left(u_1+u_2+u_3+u_4-4u_0\\right) \\end{equation}\\] where all velocities have been interpolated onto a horizontal plane using linear interpolation in the vertical. Shapiro filters and viscosity stencil for (a) triangular and (b) quadrangular elements. 'I' and 'II' are 2 adjacent elements of side of interest ('0'). The extended stencil used in constructing bi-harmonic viscosity is shown in (c). The special case of a boundary side is shown in (d). The bi-harmonic viscosity is often superior to the Laplacian viscosity as it is more discriminating in removing sub-grid instabilities without adversely affecting the resolved scales of flow (Griffies and Hallberg 2000). The bi-harmonic viscosity can be implemented by applying the Laplacian operator twice. Referring to Figure 5c , we have - \\[\\begin{equation} \\label{eq53} \\begin{aligned} -\\lambda\\nabla^4u\\Biggr|_0 &= -\\lambda\\gamma_3\\left( \\nabla^2 u_1 + \\nabla^2 u_2 + \\nabla^2 u_3 + \\nabla^2 u_4 - 4\\nabla^2 u_0 \\right)\\\\ &= \\frac{\\gamma_2}{\\Delta t}\\left[ 7\\left( u_1 + u_2 + u_3 + u_4\\right) - u_{1a} - u_{1b} - u_{2a} - u_{2b} - u_{3a} - u_{3b} - u_{4a} - u_{4b} - 20u_0 \\right] \\end{aligned} \\end{equation}\\] where \\(\\lambda\\) is a hyper viscosity in \\(m^4/s\\) , \\(\\gamma_3 = \\frac{1}{\\sqrt{3}A_I}\\) and \\(\\gamma_2 = \\lambda\\gamma_3^2\\Delta t\\) is a diffusion-number-like dimensionless constant. We found that in practice \\(\\gamma_2 \\leq 0.025\\) is sufficient to suppress inertial spurious modes. References Casulli, V. and E. Cattani (1994) Stability, accuracy and efficiency of a semi-implicit method for 3D shallow water flow. Computers & Mathematics with Applications, 27, pp. 99-112. Flather, R.A. (1987) A tidal model of Northeast Pacific. Atmosphere-Ocean, 25, pp. 22-45. Zhang, Y. and Baptista, A.M. (2008) \"SELFE: A semi-implicit Eulerian-Lagrangian finite-element model for cross-scale ocean circulation\", Ocean Modelling, 21(3-4), 71-96 Zhang, Y., Ye, F., Stanev, E.V., Grashorn, S. (2016). Seamless cross-scale modeling with SCHISM, Ocean Modelling, 102, 64-81. doi:10.1016/j.ocemod.2016.05.002","title":"Barotropic solver"},{"location":"schism/barotropic-solver.html#general-formulation","text":"SCHISM solves the barotropic equations first ( Eqs 1-3 ) first, as the transport and turbulent closure equations lag one time step behind (in other words, the baroclinic pressure gradient term in the momentum equation is treated explicitly in SCHISM). The transport and turbulent closure equations will be discussed later. Due to the hydrostatic approximation, the vertical velocity \\(w\\) is solved from the 3D continuity equation after the horizontal velocity is found. To solve the coupled Eqs. 1 and 3 , we first discretize them and the vertical boundary conditions semi-implicitly in time as - \\[\\begin{equation} \\label{eq01} \\frac{\\eta^{n+1} - \\eta^{n}}{\\Delta t} + \\theta \\nabla \\cdot \\int_{-h}^{\\eta} \\pmb{u}^{n+1} dz + (1-\\theta) \\nabla \\cdot \\int_{-h}^{\\eta} \\pmb{u}^{n} dz = 0 \\end{equation}\\] \\[\\begin{equation} \\label{eq02} \\frac{\\pmb{u}^{n+1} - \\pmb{u}^*}{\\Delta t} = \\pmb{f} - g \\theta \\nabla \\eta^{n+1} - g(1-\\theta)\\nabla\\eta^n + \\pmb{m}_z^{n+1} - \\alpha\\left|\\pmb{u}\\right|\\pmb{u}^{n+1} L(x, y, z) \\end{equation}\\] \\[\\begin{equation} \\label{eq03} \\begin{aligned} \\text{for 3D cells: } \\begin{cases} \\nu^n \\frac{\\partial \\pmb{u}^{n+1}}{\\partial z} = \\pmb{\\tau}_{w}^{n+1}, \\text{ at } z=\\eta^n\\\\ \\nu^n \\frac{\\partial \\pmb{u}^{n+1}}{\\partial z} = \\chi^n \\pmb{u}_{b}^{n+1}, \\text{ at } z=-h \\end{cases} \\end{aligned} \\end{equation}\\] where superscripts denote the time step, \\(0 \\leq \\theta \\leq 1\\) is the implicitness factor, \\(\\pmb{u}^*(x, y, z, t^n)\\) is the back-tracked value calculated with Eulerian-Lagrangian Method (ELM; see here ), and \\(\\chi^n = C_D \\left| \\pmb{u}_{b}^{n} \\right|\\) . The elevations in the 2nd and 3rd terms of Eq. \\(\\ref{eq01}\\) are treated explicitly, which effectively amounts to a linearization procedure. A Galerkin weighted residual statement in the weak form for Eq. \\(\\ref{eq01}\\) reads: \\[\\begin{equation} \\label{eq04} \\int_\\Omega \\phi_i \\frac{\\eta^{n+1} - \\eta^{n}}{\\Delta t} d\\Omega + \\theta \\left[ -\\int_\\Omega \\nabla \\phi_i \\cdot \\pmb{U}^{n+1} d\\Omega + \\int_\\Gamma \\phi_i U_n^{n+1} d\\Gamma \\right] + (1-\\theta) \\left[ -\\int_\\Omega \\nabla \\phi_i \\cdot \\pmb{U}^{n} d\\Omega + \\int_\\Gamma \\phi_i U_n^n d\\Gamma \\right] = 0, (i = 1, ... , N_p) \\end{equation}\\] Where \\(N_p\\) is the total number of nodes, \\(\\Gamma \\equiv \\Gamma_\\nu + \\overline{\\Gamma}_\\nu\\) is the boundary of the entire domain \\(\\Omega\\) , with \\(\\Gamma_\\nu\\) corresponding to the boundary sagments where natural boundary conditions are specified, \\(\\pmb{U} = \\int_{-h}^{\\eta} \\pmb{u}dz\\) is the depth-integrated velocity, \\(U_n\\) is its normal component along the boundary, and \\(\\hat{U}_n\\) is the boundary condition. In SCHISM, linear shape functions are used (area coordinates for triangles and bi-linear function for quads); thus, \\(\\phi_i\\) are familier \"hat\" functions.","title":"General formulation"},{"location":"schism/barotropic-solver.html#locally-2d-case","text":"Since there is only one degree of freedom in the vertical dimention in this case, a straightforward integration of Eq. \\(\\ref{eq02}\\) gives - \\[\\begin{equation} \\label{eq05} \\pmb{U}^{n+1} = \\check{\\pmb{G}} - g\\theta\\Delta t \\frac{H^2}{\\tilde{H}} \\nabla \\eta^{n+1} \\end{equation}\\] Where \\(\\check{\\pmb{G}}\\) incorporates explicit term - \\[\\begin{equation} \\label{eq06} \\check{\\pmb{G}} = \\frac{H}{\\tilde{H}}\\left[ \\pmb{U}^* + \\Delta t \\left( \\pmb{F} + \\pmb{\\tau}_w - g(1-\\theta)H\\nabla\\eta^n \\right) \\right] \\end{equation}\\] and \\(\\pmb{F}\\) is the depth integrated term of \\(\\pmb{f}\\) , and \\(\\tilde{H}\\) is the depth enhanced by the bottom friction and form drag - \\[\\begin{equation} \\label{eq07} \\tilde{H} = H + \\left( \\chi + \\alpha \\left| \\pmb{u} \\right| H\\right)\\Delta t \\end{equation}\\] The net effect of the vegetation is therefore equivalent to increase in the bottom drag, since the 3D structure of the flow/vegetation is not accounted for. Substituting Eq. \\(\\ref{eq05}\\) into Eq. \\(\\ref{eq04}\\) results in an integral equation for the unknown \\(\\eta^{n+1}\\) alone.","title":"Locally 2D case"},{"location":"schism/barotropic-solver.html#locally-3d-case","text":"We first integrate Eq. \\(\\ref{eq02}\\) from bottom to surface - \\[\\begin{equation} \\label{eq08} \\frac{\\pmb{U}^{n+1}-\\pmb{U}^*}{\\Delta t} = \\pmb{F} - gH\\theta\\nabla\\eta^{n+1} - gH(1-\\theta)\\nabla\\eta^n + \\pmb{\\tau}_w - \\chi\\pmb{u}_b^{n+1} - \\alpha\\overline{\\left| \\pmb{u} \\right|} \\pmb{U}^{\\alpha} \\end{equation}\\] where we have performed linearization of the vegetation term - \\[\\begin{equation} \\label{eq09} \\int_{-h}^{z_v} \\left|\\pmb{u}\\right|\\pmb{u}dz \\approx \\overline{\\left| \\pmb{u} \\right|} \\equiv \\overline{\\left| \\pmb{u} \\right|} \\pmb{U}^{\\alpha} , (\\text{where, }\\pmb{U}^{\\alpha} = \\int_{-h}^{z_v}\\pmb{u}dz) \\end{equation}\\] \\[\\begin{equation} \\label{eq10} \\overline{\\left| \\pmb{u} \\right|} = \\frac{1}{H^\\alpha} \\int_{-h}{z_v} \\left| \\pmb{u}^n \\right| dz \\end{equation}\\] and \\(H^\\alpha = z_v +h\\) is the height of vegetation. Note that similar procedures have been used for other nonlinear terms (e.g. the quadratic bottom drag). To eliminate \\(\\pmb{u}_b^{n+1}\\) in Eq \\(\\ref{eq08}\\) , we invoke the discretized momentum equation at the bottom cell and utilize the fact that the Reynolds stress is constant within the boundary layer, as shown in Zhang and Baptista (2008) - \\[\\begin{equation} \\label{eq11} \\frac{\\pmb{u}_b^{n+1} - \\pmb{u}_b^*}{\\Delta t} = \\pmb{f}_b - g\\theta\\nabla\\eta^{n+1} - g(1-\\theta)\\nabla\\eta^n - \\alpha\\left|\\pmb{u}_b\\right|\\pmb{u}_b^{n+1} \\end{equation}\\] from which \\(\\pmb{u}_b^{n+1}\\) can be formally solved as - \\[\\begin{equation} \\label{eq12} \\pmb{u}_b^{n+1} = \\frac{1}{1+\\alpha\\left|\\pmb{u}_b\\right|\\Delta t} \\left[\\pmb{u}_b^* +\\pmb{f}_b\\Delta t - g(1-\\theta)\\Delta t \\nabla \\eta^n \\right] - \\frac{g\\theta\\Delta t}{1+\\alpha\\left|\\pmb{u}_b\\right|\\Delta t}\\nabla\\eta^{n+1} \\end{equation}\\] The subscript \\(b\\) denotes the top of the bottom cell. Note that the main difference from the original formulation of Zhang and Baptista (2008) is the appearance of the vegetation term. The remaining task is to find \\(\\pmb{U}^\\alpha\\) . We\u2019ll discuss two scenarios of submerged and emergent vegetation.","title":"Locally 3D case"},{"location":"schism/barotropic-solver.html#emergent-vegetation","text":"When the vegetation is locally emergent, i.e., \\(H^\\alpha \\geq H\\) , we have \\(\\pmb{U}^\\alpha = \\pmb{U}^{n+1}\\) , and therefore \\(\\pmb{U}^{n+1}\\) can be found from Eq. \\(\\ref{eq08}\\) and \\(\\ref{eq12}\\) as - \\[\\begin{equation} \\label{eq13} \\pmb{U}^{n+1} = \\pmb{G}_1 - \\frac{g\\theta\\hat{H}\\Delta t}{1+\\alpha\\overline{\\left| \\pmb{u} \\right|} \\Delta t} \\nabla\\eta^{n+1} \\end{equation}\\] where \\(\\pmb{G}_1\\) contains explicit terms - \\[\\begin{equation} \\label{eq14} \\pmb{G}_1 = \\frac{\\pmb{U}^* + (\\pmb{F}+\\pmb{\\tau}_w)\\Delta t - g(1-\\theta)\\hat{H}\\Delta t \\nabla\\eta^n-\\tilde{\\chi}\\Delta t (\\pmb{u}_b^*+\\pmb{f}_b\\Delta t)}{1+\\alpha\\overline{\\left| \\pmb{u} \\right|} \\Delta t} \\end{equation}\\] \\[\\begin{equation} \\label{eq15} \\tilde{\\chi} = \\frac{\\chi}{1+\\alpha \\left| \\pmb{u}_b \\right| \\Delta t} \\end{equation}\\] and \\(\\hat{H}\\) is a friction modified depth - \\[\\begin{equation} \\label{eq16} \\hat{H} = H - \\tilde{\\chi}\\Delta t \\end{equation}\\] Compared to the original formulation in Zhang and Baptista (2008) , the only change in this depth is the vegetation term in \\(\\tilde{\\chi}\\) .","title":"Emergent vegetation"},{"location":"schism/barotropic-solver.html#submerged-vegetation","text":"When the vegetation is submerged, i.e., \\(H^\\alpha < H\\) , strong shear and turbulence develop between the vegetation and the overlying flow above it ( ST94 ). Nepf and Vivoni (2000) demonstrated that there are two zones for submerged aquatic vegetation (SAV). In the upper canopy (called the \u2018vertical exchange zone\u2019), mean shear at the top of the canopy produces vertical turbulent exchange with the overlying water, which plays a significant role in the momentum balance. The lower canopy (\u2018longitudinal change zone\u2019 as in Nepf and Vivoni, 2000 ) communicates with surrounding water predominantly through longitudinal advection. The extent of the vertical exchange of momentum between the vegetation zone and overlying water is dependent on the submergence. We first integrate the momentum equation (Eq. \\(\\ref{eq02}\\) ) from the bottom to the top of canopy - \\[\\begin{equation} \\label{eq17} \\pmb{U}^\\alpha = \\pmb{U}^{*\\alpha} + \\pmb{F}^\\alpha\\Delta t - g\\theta H^\\alpha \\Delta t \\nabla\\eta^{n+1} - g(1-\\theta)H^\\alpha\\Delta t \\nabla \\eta^n - \\alpha \\Delta t \\overline{\\left| \\pmb{u} \\right|} \\pmb{U}^\\alpha + \\Delta t\\nu \\Bigr\\rvert_{-h}^{z_v} \\end{equation}\\] where \\[\\begin{equation} \\label{eq18} \\begin{aligned} \\pmb{U}^{*\\alpha} = \\int_{-h}^{z_v}\\pmb{u}^* dz\\\\ \\pmb{F}^\\alpha = \\int_{-h}^{z_v}\\pmb{f}dz \\end{aligned} \\end{equation}\\] The Reynolds stress at the top of canopy can be calculated from theory proposed by ST94. These authors found through lab experiments that the stress variation inside the vegetation layer approximately follows an exponential law \\[\\begin{equation} \\label{eq19} \\nu\\frac{\\partial\\pmb{u}}{\\partial z} \\equiv \\overline{u'w'} = \\pmb{R}_0 e^{\\beta_2 (z-z_v)} \\text{ for } z \\leq z_v \\end{equation}\\] where \\(\\pmb{R}_0\\) is the stress at \\(z=z_v\\) , and \\(\\beta_2\\) is determined by an empirical formula - \\[\\begin{equation} \\label{eq20} \\beta_2 = \\sqrt{\\frac{\\sqrt{N_v}}{H^\\alpha}} \\left[ -0.32 - 0.85 \\log_{10} \\left( \\frac{H - H^\\alpha}{H^\\alpha} I\\right) \\right] \\end{equation}\\] where \\(I\\) is an energy gradient - \\[\\begin{equation} \\label{eq21} I = \\frac{\\chi \\left| \\pmb{u}_b \\right|}{gH} \\end{equation}\\] which is estimated from the previous time step in the model. The stress term in Eq. \\(\\ref{eq19}\\) therefore becomes \\[\\begin{equation} \\label{eq22} \\nu\\frac{\\partial\\pmb{u}}{\\partial z}\\Bigr\\rvert_{-h}^{z_v} = \\beta \\chi \\pmb{u}_b^{n+1} \\end{equation}\\] where \\(\\beta = e^{\\beta_2(z_v - z_b)}-1\\) , and \\(z_b\\) is the location of the top of the bottom grid cell. Substituting Eq. \\(\\ref{eq22}\\) and Eq. \\(\\ref{eq12}\\) into Eq. \\(\\ref{eq17}\\) we can solve for \\(\\pmb{U}^\\alpha\\) as - \\[\\begin{equation} \\label{eq23} \\pmb{U}^\\alpha = \\pmb{G}_3 - \\frac{g\\theta\\hat{H}^\\alpha\\Delta t}{1+\\alpha\\overline{\\left| \\pmb{u}\\right|}\\Delta t}\\nabla \\eta^{n+1} \\end{equation}\\] \\[\\begin{equation} \\label{eq24} \\pmb{G}_3 = \\frac{\\pmb{U}^{*\\alpha}+\\pmb{F}^\\alpha\\Delta t + \\beta\\tilde{\\chi}\\Delta t(\\pmb{u}_b^* + \\pmb{f}_b\\Delta t) - g(1-\\theta)\\hat{H}^\\alpha\\Delta t \\nabla \\eta^n}{1+\\alpha\\overline{\\left| \\pmb{u} \\right|}\\Delta t} \\end{equation}\\] \\[\\begin{equation} \\label{eq25} \\hat{H}^\\alpha = H^\\alpha + \\beta\\tilde{\\chi}\\Delta t \\end{equation}\\] Finally, substituting Eq. \\(\\ref{eq23}\\) and Eq. \\(\\ref{eq12}\\) into Eq. \\(\\ref{eq08}\\) results in a relationship between \\(\\pmb{U}^{n+1}\\) and \\(\\eta^{n+1}\\) - \\[\\begin{equation} \\label{eq26} \\pmb{U}^{n+1} = \\pmb{G}_2 - g\\theta\\overline{\\overline{H}}\\Delta t \\nabla \\eta^{n+1} \\end{equation}\\] \\[\\begin{equation} \\label{eq27} \\overline{\\overline{H}} = H - \\tilde{\\chi}\\Delta t - c\\hat{H}^\\alpha \\end{equation}\\] \\[\\begin{equation} \\label{eq28} c = \\frac{\\alpha\\overline{\\left| \\pmb{u} \\right|}\\Delta t}{1 + \\alpha\\overline{\\left| \\pmb{u} \\right|}\\Delta t} \\end{equation}\\] \\[\\begin{equation} \\label{eq29} \\pmb{G}_2 = \\pmb{U}^* - c\\pmb{U}^{*\\alpha} + (\\pmb{F} + \\pmb{\\tau_w})\\Delta t - c\\pmb{F}^\\alpha\\Delta t - \\tilde{\\chi}\\Delta t(1+\\beta c)(\\pmb{u}_b^*+\\pmb{f}_b\\Delta t) - g(1-\\theta)\\overline{\\overline{H}}\\Delta t \\nabla\\eta^n \\end{equation}\\]","title":"Submerged vegetation"},{"location":"schism/barotropic-solver.html#general-case","text":"In summary, the depth-integrated velocity can be expressed in compact form as - \\[\\begin{equation} \\label{eq30} \\pmb{U}^{n+1} = \\pmb{E} - g\\theta\\breve{H}\\Delta t\\nabla\\eta^{n+1} \\end{equation}\\] where, \\[\\begin{equation} \\label{eq31} \\begin{aligned} \\breve{H} = \\begin{cases} \\frac{H^2}{\\breve{H}}, \\text{ 2D }\\\\ \\frac{\\hat{H}}{1+\\alpha\\overline{\\left| \\pmb{u} \\right|}\\Delta t}, \\text{ 3D emergent }\\\\ \\overline{\\overline{H}}, \\text{ 3D submerged } \\end{cases} \\end{aligned} \\end{equation}\\] \\[\\begin{equation} \\label{eq32} \\begin{aligned} \\pmb{E} = \\begin{cases} \\breve{\\pmb{G}}, \\text{ 2D }\\\\ \\pmb{G}_1, \\text{ 3D emergent }\\\\ \\pmb{G}_2, \\text{ 3D submerged } \\end{cases} \\end{aligned} \\end{equation}\\] Substituting Eq. \\(\\ref{eq30}\\) back into Eq. \\(\\ref{eq04}\\) gives an equation for the unknown elevations alone - \\[\\begin{equation} \\label{eq33} I_1 = I_4 - \\theta\\Delta t I_3 - (1-\\theta)\\Delta t I_5 - \\theta\\Delta t I_6 \\text{, for } i=1, \\cdots, N_p \\end{equation}\\] where, \\[\\begin{equation} \\label{eq34} I_1 = \\int_\\Omega \\left[ \\phi_i \\eta^{n+1} + g\\theta^2\\Delta t^2\\ \\check{H}\\nabla\\phi_i\\cdot\\nabla\\eta^{n+1}\\right]d\\Omega \\end{equation}\\] \\[\\begin{equation} \\label{eq35} I_4 = \\int_\\Omega \\left[ \\phi_i\\eta^n + \\theta\\Delta t \\nabla\\phi_i\\cdot\\pmb{E} + (1-\\theta)\\Delta t \\nabla\\phi_i \\cdot\\pmb{U}^n \\right]d\\Omega \\end{equation}\\] \\[\\begin{equation} \\label{eq36} I_3 = \\int_{\\Gamma_\\nu} \\phi_i\\hat{U}_n^{n+1}d\\Gamma_\\nu \\end{equation}\\] \\[\\begin{equation} \\label{eq37} I_5 = \\int_\\Gamma \\phi_i U_n^n d\\Gamma \\end{equation}\\] \\[\\begin{equation} \\label{eq38} I_6 = \\int_{\\overline{\\Gamma}_\\nu} \\phi_i U_n^{n+1} d\\overline{\\Gamma}_\\nu \\end{equation}\\] Following standard finite-element procedures, and using appropriate essential and natural boundary conditions, SCHISM solves Eq. \\(\\ref{eq33}\\) to determine the elevations at all nodes. Note that the RHS terms \\(I_{3-6}\\) are known; in the case of \\(I_6\\) , the integrals on \\(\\overline{\\Gamma}_\\nu\\) need not be evaluated since the essential boundary conditions are imposed by eliminating corresponding rows and columns of the matrix. The matrix resulting from Eq. \\(\\ref{eq33}\\) is sparse and symmetric. It is also positive-definite as long as the depth \\(\\breve{H}\\) is non-negative ( ihhat=1 ); numerical experiments indicated that even this restriction can be relaxed for many practical applications that include shallow areas. We show that the addition of vegetation does not introduce additional stability constraint. The effects of the vegetation on \\(\\breve{H}\\) are generally similar to the bottom friction. For the 2D case, \\(\\breve{H}\\) is always positive. For the 3D emergent case, the vegetation term in the denominator is positive and so does not change the sign. For the 3D submerged case, as \\(\\alpha \\rightarrow 0\\) , previous results of Zhang and Baptista (2008) are recovered. As \\(\\alpha \\rightarrow \\infty\\) (i.e., very dense vegetation), the friction term (the second term in Eq. \\(\\ref{eq27}\\) ) dwarfs in comparison with the vegetation term (the third term in Eq. \\(\\ref{eq27}\\) ), and therefore the friction is negligible under dense vegetation. Since \\(c \\rightarrow 1\\) as \\(\\alpha \\rightarrow \\infty\\) , \\(\\breve{H}\\) approaches the submergence \\(H-H^\\alpha\\) , which is positive. When the submergence is very small (i.e. almost emergent vegetation), \\(\\breve{H} \\rightarrow 0\\) and the conditioning of the matrix would somewhat deteriorate but the model remains stable. Physically, this means that very strong shear will develop near the canopy. It\u2019s important to notice that the friction-modified depth is different between 2D and 3D cases, which has implications in shallow depths. We show more details of the evaluation of the integrals \\(I_i\\) below. The corresponding constant for 2D prisms is always positive (see below) and therefore the 2D mode is inherently more stable than 3D mode; consequently, judiciously leveraging SCHISM\u2019s polyphorphism enhances stability near the wetting and drying interface. The matrix can be efficiently solved using a pre-conditioned Conjugate Gradient method ( Casulli and Cattani 1994 ). This simple matrix solver is implemented in SCHISM; alternatively, the efficient parallel matrix solver PETSc can be used for large matrices. In the model, the decision on 2D/3D emergent/3D submerged scenarios is made at each side (where the velocity is defined) based on the total depths from the previous time step and the transition of regimes is handled in the model.","title":"General case"},{"location":"schism/barotropic-solver.html#integral-i_3","text":"This is a boundary integral that only need to be evaluated when the node \\(i\\) is located on an open boundary segment where Neuman-type B.C. is prescribed. Since the unknowns vary linearly along any side, we have (cf. Figure 1 ) - \\[\\begin{equation} \\label{eq39} I_3 = \\sum_j \\frac{L_{ij}}{2} \\sum_{k=kbs}^{N_z-1} \\Delta z_{j,k+1} \\frac{\\hat{u}_{j,k+1}^{n+1} + \\hat{u}_{j,k}^{n+1}}{2} \\end{equation}\\] where the outer sum is carried out along the 2 adjacent open side \\(j\\) , \\(L_{ij}\\) is the side length, \\(\\Delta z_{j,k+1}\\) is the layer thickness along side \\(j\\) , and \\(kbs\\) is the local bottom index. Boundary node i with adjacent sides. If a Flather-type radiation condition ( Flather 1987 ) needs to be applied, it can be done in the following fashion - \\[\\begin{equation} \\label{eq40} \\hat{U}_n^{n+1} - \\overline{U}_n = \\sqrt{\\frac{g}{H}} (\\eta^{n+1} - \\overline{\\eta}) \\end{equation}\\] where \\(\\overline{U}_n\\) and \\(\\overline{\\eta}\\) are specified mean incoming current and mean elevation. Then - \\[\\begin{equation} \\label{eq41} I_3 = \\sum_j \\frac{L_{ij}(\\overline{U}_n)_{ij}}{2} + \\frac{L_{ij}\\sqrt{gH_{ij}}}{6} \\left[ 2(\\eta_i^{n+1} - \\overline{\\eta}_i) + (\\eta_j^{n+1} - \\overline{\\eta}_j) \\right] \\end{equation}\\] In this case, the unknown \\(\\eta^{n+1}\\) need to be moved to the LHS, and the diagonal (associated with \\(\\eta_i^{n+1}\\) ) is enhanced as a result and matrix symmetry is preserved.","title":"Integral \\(I_3\\)"},{"location":"schism/barotropic-solver.html#integral-i_5","text":"Similar to \\(I_3\\) , we have - \\[\\begin{equation} \\label{eq42} I_5 = \\sum_j \\frac{L_{ij}}{2} \\sum_{k=kbs}^{N_z-1} \\Delta z_{j, k+1} \\frac{u_{j, k+1}^{n} + u_{j,k}^{n}}{2} \\end{equation}\\]","title":"Integral \\(I_5\\)"},{"location":"schism/barotropic-solver.html#integral-i_1","text":"This is the only implicit term. Referring to Figure 2 , we have - \\[\\begin{equation} \\label{eq43} I_1 = \\sum_{j=1}^{Nb(i)} \\sum_{l=1}^{i34(j)} \\eta_{j,l}^{n+1} \\int_{A_j} \\hat{\\phi_{i'}} \\hat{\\phi_l} dA_j + g\\theta^2 \\Delta t^2 \\sum_{j=1}^{Nb(i)} \\overline{\\check{H}_j} \\sum_{l=1}^{i34(j)} \\eta_{j,l}^{n+1} \\int_{A_j} \\nabla\\hat{\\phi_{i'}}\\cdot\\nabla\\hat{\\phi_l} dA_j \\end{equation}\\] Where \\(j\\) is a neighbouring element of \\(i\\) , \\(i'\\) is the local index of node \\(i\\) inside element \\(j\\) , overbar in \\(\\overline{\\check{H}}\\) denotes element averating, and \\(\\hat{\\phi}\\) is the local linear shape function. We discuss the case of a triangle and quad element. Node ball used in calculating integral I 1.","title":"Integral \\(I_1\\)"},{"location":"schism/barotropic-solver.html#case-i-triangle","text":"The 2 integrals can be evaluated analytically as - \\[\\begin{equation} \\label{eq44} \\int_{A_j} \\hat{\\phi_{i'}} \\hat{\\phi_l} dA_j = \\frac{1+\\delta_{i',l}}{12}A_j \\end{equation}\\] \\[\\begin{equation} \\label{eq45} \\int_{A_j} \\nabla\\hat{\\phi_{i'}} \\cdot \\nabla\\hat{\\phi_l} dA_j = \\frac{\\vec{i'}\\cdot\\vec{l}}{4A_j} \\end{equation}\\] where \\(\\vec{i'}\\) and \\(\\vec{l}\\) are two vectors along side \\(i'\\) and \\(l\\) respectively, and \\(\\delta_{i',l}\\) is the Kronecker delta - \\[\\begin{equation*} \\delta_{i',l} = \\begin{cases} 1, i' = l \\\\ 0, i' \\neq l \\end{cases} \\end{equation*}\\]","title":"Case I: triangle"},{"location":"schism/barotropic-solver.html#case-ii-quad","text":"We can analytically evaluate integral Eq. \\(\\ref{eq44}\\) as - \\[\\begin{equation} \\label{eq46} \\int_{A_j} \\hat{\\phi_{i'}}\\hat{\\phi_l}dA_j = \\frac{A_j}{16}\\left(1+\\frac{1}{3}\\xi_{i'}\\xi_l\\right)\\left(1+\\frac{1}{3}\\varsigma_{i'}\\varsigma_l\\right) + \\frac{B_1}{96}\\left(1+\\frac{1}{3}\\varsigma_{i'}\\varsigma_l\\right)\\left(\\xi_{i'}+\\xi_l\\right) + \\frac{B_2}{96}\\left(1+\\frac{1}{3}\\xi_{i'}\\xi_l\\right)\\left(\\varsigma_{i'}+\\varsigma_l\\right) \\end{equation}\\] Where \\((\\xi, \\varsigma)\\) are local coordinates, and \\(B_1\\) and \\(B_2\\) are 2 geometric constants (Figure 3 ) - \\[\\begin{equation} \\label{eq47} \\begin{aligned} B_1 = \\left(\\vec{12}\\times\\vec{43}\\right)_k = \\left(x_2-x_1\\right)\\left(y_3-y_4\\right) - \\left(x_3-x_4\\right)\\left(y_2-y_1\\right)\\\\ B_2 = \\left(\\vec{23}\\times\\vec{14}\\right)_k \\end{aligned} \\end{equation}\\] Quad element and local transformation. The other integral Eq. \\(\\ref{eq45}\\) cannot be evaluated analytically and so we use the 4-point Gauss quadrature.","title":"Case II: Quad"},{"location":"schism/barotropic-solver.html#integral-i_4","text":"This integral contains most of the explicit terms. Most terms are straightforward to evaluate, e.g., using element averaging or analytical integration (in the case of volume sources/sinks); the integrals involving the shape function or its derivative can be calculated using the similar method as in \\(I_1\\) . Therefore we will only discuss the a few terms below given their importance in SCHISM.","title":"Integral \\(I_4\\)"},{"location":"schism/barotropic-solver.html#baroclinicity","text":"Since a FVM is used to solve the tracers (including T,S) at the prism center, we evaluate the density gradient at prism center via a reconstruction method. Referring to Figure 4 , given a prism center '0', we first project the gradient onto vectors connecting adjacent prism centers - \\[\\begin{equation} \\label{eq48} \\frac{\\partial\\rho}{\\partial x}\\left(x_1-x_0\\right) + \\frac{\\partial\\rho}{\\partial y}\\left(y_1-y_0\\right) = \\rho_1-\\rho_0 \\end{equation}\\] \\[\\begin{equation} \\label{eq49} \\frac{\\partial\\rho}{\\partial x}\\left(x_2-x_0\\right) + \\frac{\\partial\\rho}{\\partial y}\\left(y_2-y_0\\right) = \\rho_2-\\rho_0 \\end{equation}\\] \\[\\begin{equation} \\label{eq50} \\frac{\\partial\\rho}{\\partial x}\\left(x_3-x_0\\right) + \\frac{\\partial\\rho}{\\partial y}\\left(y_3-y_0\\right) = \\rho_3-\\rho_0 \\end{equation}\\] after a cubic spline interpolation has been performed to calculate the density at prism '1' at the same vertical location as \u20180\u2019 (i.e. ( \\(i\\) , \\(k\\) )). Note that if the element \\(i\\) is a quad, we will have 4 equations. We then solve pairs of equations to find for \\(\\nabla\\rho\\) , i.e., Eq. \\(\\ref{eq48}\\) with Eq. \\(\\ref{eq49}\\) , Eq. \\(\\ref{eq49}\\) with Eq. \\(\\ref{eq50}\\) , and Eq. \\(\\ref{eq50}\\) with Eq. \\(\\ref{eq48}\\) . If the 3 centers happen to be co-linear, the equations have no solution and are discarded; however, at least 1 pair has a valid solution. Reconstruction method. i is the element index and k is the vertical index. If a neighbor does not exist (boundary) or is dry, we replace the corresponding equation with the no-flux B.C.; e.g., if AB is such a side, then - \\[\\begin{equation} \\label{eq51} \\frac{\\partial\\rho}{\\partial y}\\left(x_A-x_B\\right) + \\frac{\\partial\\rho}{\\partial x}\\left(y_B-y_A\\right) = 0 \\end{equation}\\] After the density gradients are found at prism centers, a simple linear interpolation in the vertical is used to calculate the gradients at side centers (and half levels). Then the trapezoidal rule is used to compute the baroclinic term: \\(-\\frac{g}{\\rho_0}\\int_z^\\eta\\nabla\\rho dz\\) . This will also be utilized in the solution of the momentum equation.","title":"Baroclinicity"},{"location":"schism/barotropic-solver.html#horizontal-viscosity","text":"Momentum stabilization is an important consideration in designing advection and viscosity schemes. Zhang et al. (2016) demonstrated that the standard Laplacian viscosity is equivalent to the 5-point Shapiro filter (see below) on uniform grids; however, on non-uniform grids, it may behave like an \u2018amplifier\u2019 and therefore the filter form should be used instead (Figure 5a,b ) - \\[\\begin{equation} \\label{eq52} \\nabla\\cdot\\left(\\mu\\nabla u\\right)\\Biggr|_0 = \\frac{\\mu_0}{\\sqrt{3}A_I}\\left(u_1+u_2+u_3+u_4-4u_0\\right) \\end{equation}\\] where all velocities have been interpolated onto a horizontal plane using linear interpolation in the vertical. Shapiro filters and viscosity stencil for (a) triangular and (b) quadrangular elements. 'I' and 'II' are 2 adjacent elements of side of interest ('0'). The extended stencil used in constructing bi-harmonic viscosity is shown in (c). The special case of a boundary side is shown in (d). The bi-harmonic viscosity is often superior to the Laplacian viscosity as it is more discriminating in removing sub-grid instabilities without adversely affecting the resolved scales of flow (Griffies and Hallberg 2000). The bi-harmonic viscosity can be implemented by applying the Laplacian operator twice. Referring to Figure 5c , we have - \\[\\begin{equation} \\label{eq53} \\begin{aligned} -\\lambda\\nabla^4u\\Biggr|_0 &= -\\lambda\\gamma_3\\left( \\nabla^2 u_1 + \\nabla^2 u_2 + \\nabla^2 u_3 + \\nabla^2 u_4 - 4\\nabla^2 u_0 \\right)\\\\ &= \\frac{\\gamma_2}{\\Delta t}\\left[ 7\\left( u_1 + u_2 + u_3 + u_4\\right) - u_{1a} - u_{1b} - u_{2a} - u_{2b} - u_{3a} - u_{3b} - u_{4a} - u_{4b} - 20u_0 \\right] \\end{aligned} \\end{equation}\\] where \\(\\lambda\\) is a hyper viscosity in \\(m^4/s\\) , \\(\\gamma_3 = \\frac{1}{\\sqrt{3}A_I}\\) and \\(\\gamma_2 = \\lambda\\gamma_3^2\\Delta t\\) is a diffusion-number-like dimensionless constant. We found that in practice \\(\\gamma_2 \\leq 0.025\\) is sufficient to suppress inertial spurious modes. References Casulli, V. and E. Cattani (1994) Stability, accuracy and efficiency of a semi-implicit method for 3D shallow water flow. Computers & Mathematics with Applications, 27, pp. 99-112. Flather, R.A. (1987) A tidal model of Northeast Pacific. Atmosphere-Ocean, 25, pp. 22-45. Zhang, Y. and Baptista, A.M. (2008) \"SELFE: A semi-implicit Eulerian-Lagrangian finite-element model for cross-scale ocean circulation\", Ocean Modelling, 21(3-4), 71-96 Zhang, Y., Ye, F., Stanev, E.V., Grashorn, S. (2016). Seamless cross-scale modeling with SCHISM, Ocean Modelling, 102, 64-81. doi:10.1016/j.ocemod.2016.05.002","title":"Horizontal viscosity"},{"location":"schism/eulerian-lagrangian-method.html","text":"The default option for the momentum advection in SCHISM is ELM, which is one of few explicit methods that are unconditionally stable. Under this method, the momentum advection is approximated as - \\[\\begin{equation} \\label{eq01} \\frac{D\\pmb{u}}{Dt}\\cong\\frac{\\pmb{u}(\\pmb{x}, t^{n+1}) - \\pmb{u}(\\pmb{x}^*, t^n)}{\\Delta t} \\end{equation}\\] where \\(\\pmb{x}\\) is a shorthand for \\((x, y, z)\\) , and \\(\\pmb{x}^*\\) is the location of the foot of characteristic line (FOCL), calculated from the characteristic equation - \\[\\begin{equation} \\label{eq02} \\frac{D\\pmb{x}}{Dt} = \\pmb{u} \\end{equation}\\] The location \\(\\pmb{x}^*\\) is found via a backtracking step, standard in an ELM, via backward integration of Eq. \\(\\ref{eq02}\\) starting from a given location ( \\(\\pmb{x}\\) ), which is in our case a side center at whole level where the horizontal velocity \\(\\pmb{u}\\) is defined. The fixed starting location (Eulerian framework) followed by a Lagrangian tracking step gives the name Eulerian-Lagrangian method. Therefore the ELM consists of two major steps: a backtracking step (Figure 1 a) and an interpolation step at FOCL (Figure 1 b). We further sub-divide the tracking step into smaller intervals (based on local flow gradients), and use a 2nd-order Runge-Kutta method (mid-point method) within each interval, in order to accurately track the trajectory. Although exact integration methods have been proposed ( Ham et al. 2006 ), their implementation is complicated for a 3D (triangular and quadrangular) prism and in the exceptional cases of wetting and drying interfaces. The interpolation step serves as an important control for numerical diffusion/dispersion in the ELM, and we therefore experimented with several options as shown below. However, before we get to this, we first explain how SCHISM converts the velocities at sides to the velocities at nodes, as the latter are required in the interpolation of the velocities along the characteristic line and at the FOCL (Figure 1 ). Two steps in Eulerian\u2013Lagrangian method. (a) The characteristic equation is integrated backward in space and time, starting from a side center (the green dot). The characteristic line is further subdivided into smaller intervals (bounded by the red dots), based on local flow gradients, and a 2nd-order Runge\u2013Kutta method is used within each interval. The foot of characteristic line is marked as a yellow dot. Note that the vertical position of the trajectory is also changing and so the tracking is in 3D space. (b) Interpolation is carried out at FOCL (yellow dot), based on either the nodes of the containing elements (blue dots), or the 2-tier neighborhood (blue plus red dots; the latter are the neighbors of the blue dots) using a dual kriging method. Proper linear vertical interpolation has been carried out first to bring the values at each node onto a horizontal plane before the horizontal interpolation is done. As explained by Danilov (2013) , the conversion method used bears important ramifications: judicious averaging (e.g., from side to elements or to node etc.) may greatly reduce the need later on for filters to remove the inertial spurious modes while still keeping the inherent numerical dissipation low. In fact, one could have used the discontinuous velocity calculated within each element to carry out the backtracking, but this would introduce insufficient amount of dissipation to suppress the inertial modes. In the first approach (\u2018MA\u2019 hereafter; indvel=1 ), we use inverse distance weights to interpolate from velocities at surrounding sides onto a node (Figure 2a ). This introduces diffusion which may be excessive in our experience, and therefore no further stabilization (via filters or viscosity) is required for this approach (see the discussion of stabilization in Danilov 2013 ). This approach works well in shallow waters especially for the inundation process, as numerical stability often trumps the order of accuracy there. Two methods of converting side velocities to a node velocity. (a) Inverse distance interpolation from sides (blue dots) to node (yellow dot); (b) use of FEM shape function to find the node velocity within each element first (the red arrow), i.e. u1 = uII + uIII \u2013uI , followed by a simple averaging method to calculate the final value from all of its surrounding elements (dashed arrows) The 2nd approach (\u2018MB\u2019 hereafter; indvel=0 ) is more elegant and utilizes the (linear) shape function in FEM within each element to calculate the node velocities. This is equivalent to using the \\(P^{NC}\\) non-conformal shape function ( Le Roux et al. 2005 ) as one essentially interpolates based on information at sides (Figure 2b ). Because each element produces a velocity vector at each of its nodes, the final node velocity is the simple average of the values calculated from all of the surrounding elements (Figure 2a ). This approach introduces much less dissipation, but does exhibit inertial spurious modes. As a result, further stabilization is required. To this end, SCHISM uses a 5-point Shapiro filter ( Shapiro 1970 ) as illustrated in Figure 5ab ; the velocity at a side \u20180\u2019 is filtered as - \\[\\begin{equation} \\label{eq03} \\tilde{\\pmb{u}_0} = \\pmb{u}_0 + \\frac{\\gamma}{4}\\left( \\pmb{u}_1 + \\pmb{u}_2 + \\pmb{u}_3 + \\pmb{u}_4 -4\\pmb{u}_0 \\right) \\end{equation}\\] with the strength usually set as \\(\\gamma = 0.5\\) . It\u2019s obvious that the filter is analogous to the Laplacian viscosity implementation in the previous section. It proves to be very effective in removing the sub-grid scale inertial spurious modes; however, it tends introduces too much dissipation in the eddying regime, and therefore should be used only in the non-eddying regime, i.e. shallow waters. Since it\u2019s equivalent to the Laplacian viscosity, we may remove this filter in the future options and ask users to use ihorcon=1 instead. Once the node velocities are found via MA or MB, the interpolation at the FOCL is carried out in 3D space. A simple linear interpolation is used in the vertical dimension as the results from the cubic-spline interpolation turned out to be similar, due to more confined spatial scales and smaller grid sizes in the vertical. The horizontal interpolation can be done using either a simple linear shape function based on all of the nodes of the containing element (\u2018LI\u2019 hereafter), or a higher-order dual kriging method (\u2018KR\u2019 hereafter) suggested by Le Roux et al. (1997) Figure 5b The latter requires larger stencil around the FOCL, and for best parallel efficiency we use a 2-tier neighborhood as shown in Figure 5b . Given a total of N nodes available in the 2-tier neighborhood, the interpolation function is constructed as ( Le Roux 1997 ) - \\[\\begin{equation} \\label{eq04} f^h(x,y) = (\\alpha_1 + \\alpha_2 x + \\alpha_3 y) + \\sum_{i=1}^N \\beta_i K(r_i) \\end{equation}\\] where the first 3 RHS terms inside the parentheses represent a mean drift (modeled as a linear function), and the 2nd term is the fluctuation part, \\(\\alpha_j\\) , \\(\\beta_i\\) are unknown coefficients, and \\(r_i\\) is the distance between ( \\(x\\) , \\(y\\) ) and ( \\(x_i\\) , \\(y_i\\) ), with \\(i\\) being a node. The following forms of the generalized covariance function are commonly used ( Le Roux et al. 1997 ) - \\[\\begin{equation} \\label{eq05} K(r) = -r, r^2\\log(r), r^3, -r^5, r^7 \\end{equation}\\] with increasing dispersion for the higher-degree functions; therefore in practice, the last two functions are seldom used. In the following we will refer to the first 3 functions as \u2018KR1\u2019, \u2018KR2\u2019 and \u2018KR3\u2019 respectively. The equations to solve for the unknown coefficients are - \\[\\begin{equation} \\label{eq06} \\begin{aligned} f^h(x_i, y_i) = d_i, 1 \\leq i \\leq N\\\\ \\sum_{i=1}^{N} \\beta_i = 0\\\\ \\sum_{i=1}^{N} x_i\\beta_i = 0\\\\ \\sum_{i=1}^{N} y_i\\beta_i = 0 \\end{aligned} \\end{equation}\\] where \\(d_i\\) are given data at each node. The 1st equation in Eqs. \\(\\ref{eq06}\\) indicates that the dual kriging is an exact interpolator, and the other 3 equations are derived from minimization of the variance of estimation error ( Le Roux et al. 1997 ). Note that the matrix of Eqs. \\(\\ref{eq06}\\) is dependent only on geometry and therefore can be inverted and stored before the time stepping loop to achieve greater efficiency. After the coefficients are found, the interpolation at FOCL is done via Eqs. \\(\\ref{eq04}\\) . The smaller stencil used here compared to that used by Le Roux et al. (1997) leads to larger numerical dispersion. Therefore an effective method must be found to control the dispersion, and we use the ELAD scheme of Shchepetkin and McWilliams (1998) for this purpose. The essence of ELAD is to iteratively diffuse the excess field, instead of the original signal, using a diffusion operator/smoother. The viscosity scheme presented in the previous sub-section is used as the diffusion operator. The procedure is summarized as follows - Find the local max/min at FOCL. Assuming that the prism at FOCL starting from a side \\(j\\) and level \\(k\\) is ( \\(kf\\) , \\(nf\\) ), where \\(nf\\) is the element index and \\(kf\\) is the vertical index, the max/min are found in the prism ( \\(kf\\) , \\(nf\\) ) as - \\[\\begin{equation} \\label{eq07} \\begin{aligned} u_{k, j}^{max} = \\max_{l=1:i34, k=-1,0} u_{kf+k, im(l, nf)}\\\\ u_{k, j}^{min} = \\min_{l=1:i34, k=-1,0} u_{kf+k, im(l, nf)} \\end{aligned} \\end{equation}\\] where \\(im()\\) enumerates all nodes of an element. The excess field associated with (k,j) is - \\[\\begin{equation} \\label{eq08} \\varepsilon_{k, j}^{(1)} = \\max\\left[ 0, u_{k,j}^{n+1, 1} - u_{k,j}^{\\max} \\right] + \\min\\left[ 0, u_{k,j}^{n+1, 1} - u_{k,j}^{\\min} \\right] \\end{equation}\\] where \\(u_{k,j}^{n+1, 1}\\) is the interpolated value at FOCL. Apply a global diffusion operator to \\(\\varepsilon\\) to obtain estimated velocity at the next iteration - \\[\\begin{equation} \\label{eq09} u_{k,j}^{n+1, 2} = u_{k, j}^{n+1, 1} + \\mu'\\Delta t \\nabla^2 \\varepsilon_{k, j}^{(1)}, \\forall j, k \\end{equation}\\] and we use 5-point filter with maximum strength - \\[\\begin{equation} \\label{eq10} u_{k,j}^{n+1, 2} = u_{k, j}^{n+1, 1} + \\frac{1}{8} \\left[ \\varepsilon_{k, 1}^{(1)} + \\varepsilon_{k, 2}^{(1)} + \\varepsilon_{k, 3}^{(1)} + \\varepsilon_{k, 4}^{(1)} - 4 \\varepsilon_{k, j}^{(1)} \\right] \\end{equation}\\] where subscripts 1-4 are the 4 adjacent sides of \\(j\\) (Figure 5ab ); Calculate the new excess field using \\(u_{k, j}^{n+1, 2}\\) in (2) and apply the filter (3) again to find the velocity at the next iteration \\(u_{k,j}^{n+1, 3}\\) . Iterate until the excess field falls below a prescribed threshold. In practice, 10 iterations are usually sufficient to bring the excess field below an acceptable level ( \\(10^{-4} m/s\\) ); the remaining excess field is then further smoothed with the viscosity. The filter in Eqs. \\(\\ref{eq10}\\) is conservative in the sense that it only redistributes excess mass and does not introduce any additional mass. This is similar in spirit to the conservative scheme of Gravel and Staniforth (1994) but appears simpler in implementation. At a boundary side \\(j\\) , Eqs. \\(\\ref{eq10}\\) is modified in order to maintain the conservation - \\[\\begin{equation} \\label{eq11} u_{k,j}^{n+1, 2} = u_{k, j}^{n+1, 1} + \\frac{1}{8} \\left[ \\varepsilon_{k, 1}^{(1)} + \\varepsilon_{k, 2}^{(1)} - 2 \\varepsilon_{k, j}^{(1)} \\right] \\end{equation}\\] where subscripts '1' and '2' are the 2 adjacent sides of \\(j\\) (Figure 5d ). Note that since the linear interpolation scheme (LI) does not introduce local extrema, ELAD is not applied there. The various schemes presented above can be freely combined, resulting in schemes like \u2018MA-LI\u2019, \u2018MB-KR2\u2019 etc. Experiments indicate that overall the best scheme is MB-LI for both eddying and non-eddying regimes ( Zhang et al. 2016 ). References Danilov, D. (2013) Ocean modeling on unstructured meshes, Ocean Mod., 69, 195-210. Gravel, S. and A. Staniforth (1994), A mass-conserving semi-Lagrangian scheme for the shallow-water equations, Mon. Wea. Rev., 122, 243-248. Ham, D.A., Pietrzak, J., and G.S. Stelling (2006), A streamline tracking algorithm for semi-Lagrangian advection schemes based on the analytic integration of the velocity field, Journal of Computational and Applied Mathematics 192, 168\u2013174. Le Roux, D.Y., Lin, C.A., Staniforth, A. (1997), An accurate interpolating scheme for semi-Lagrangian advection on an unstructured mesh for ocean modelling, Tellus, 49A, 119\u2013138. Le Roux, D.Y., S\u00e8ne, A., Rostand, V., and E. Hanert (2005), On some spurious mode issues in shallow-water models using a linear algebra approach. Ocean Modelling 10, 83\u201394. Shapiro, R. (1970), Smoothing, filtering and boundary effects, Rev. Geophys. Space Phys. 8 (2), 359\u2013387. Shchepetkin, A.F. and J.C. Mcwilliams (1998), Quasi-Monotone Advection Schemes Based on Explicit Locally Adaptive Dissipation , Monthly Weather Review, 126, 1541-80. Zhang, Y., Ye, F., Stanev, E.V., Grashorn, S. (2016). Seamless cross-scale modeling with SCHISM, Ocean Modelling, 102, 64-81. doi:10.1016/j.ocemod.2016.05.002","title":"Eulerian-Lagrangian Method"},{"location":"schism/geometry-discretization.html","text":"As a FE model, SCHISM uses flexible UG in the horizontal and flexible vertical coordinate systems in the vertical dimension. Horizontal grid \u00b6 Hybrid triangular-quad elements are used in the horizontal, to take advantage of the superior boundary-fitting capability of triangles and efficiency/accuracy of quads in representing certain features like channels. Figure 1 shows an example of horizontal grid. Example horizontal grid (hgrid.gr3) of SCHISM. Figure 2 shows our convention of numbering local nodes/sides etc. Horizontal element convention. Local indices of nodes/sides for (a) triangular element, and (b) quad element. (c) Adjacent elements of an element (following side convention). (d,e): Local ball info (surrounding elements/nodes of node i) for (d) internal and (e) boundary node i. (f) shows a local side center-based frame used to calculate the normal fluxes; the (global) element number of \u201c1\u201d is smaller than \u201c2\u201d, and xs axis always points out of \u201c1\u201d. We follow counter-clockwise convention/right-hand rule. Vertical grid \u00b6 Hybrid SZ grid \u00b6 The 1st type uses a hybrid S (terrain-following generalized s-coordinates; Song and Haidvogel 1994) and shaved z coordinates, with the latter always being placed underneath the former at a prescribed demarcation depth \\(h_s\\) . Note that the use of shaved z layers is optional and the users can use a pure \\(S\\) grid with a choice of \\(h_s\\) greater than the maximum depths in the grid. Figure 3 shows a \\(SZ\\) grid. Example of SZ grid. (a) Vertical coordinate systems (thick line is the bottom); (b) side view of a vertical transect resulted from SZ grid; the red cells are irregular/shaved cells. The transformation from \\(S\\) to \\(Z\\) is given by - \\[\\begin{equation} \\begin{aligned} z=\\eta(1+\\sigma) + h_x \\sigma + (\\tilde{h} - h_c)C(\\sigma), \\text{where} (-1 \\leq \\sigma \\leq 0)\\\\ \\\\ C(\\sigma) = (1-\\theta_b) \\frac{sinh(\\theta_f \\sigma)}{sinh \\theta_f} + \\theta_b \\frac{tanh \\left[ \\theta_f (\\sigma + 1/2) \\right] - tanh(\\theta_f/2)}{2 tanh (\\theta_f /2)}, \\text{given} ( 0 \\leq \\theta_b \\leq 1; 0 \\lt \\theta_f \\leq 20) \\end{aligned} \\end{equation}\\] where \\(\\tilde{h} = min(h, h_s)\\) is a \u201crestricted\u201d depth, \\(h_c\\) is a positive constant dictating the thickness of the bottom or surface layer that needs to be resolved, and \\(\\theta_b\\) and \\(\\theta_f\\) are constants that control the vertical resolution near the bottom and surface. As \\(\\theta_f \\rightarrow 0\\) , the \\(S\\) coordinates reduce to the traditional \\(\\sigma\\) -coordinates: \\[\\begin{equation} z=\\tilde{H} \\sigma + \\eta \\end{equation}\\] Where \\(\\tilde{H} = \\tilde{h} + \\eta\\) is the restricted total water depth. For \\(\\theta_f \\gg 1\\) , more resolution is skewed towards the boundaries, and the transformation becomes more nonlinear. If \\(\\theta_b \\rightarrow 0\\) , only the surface is resolved, not the bottom, while if \\(\\theta_b \\rightarrow 1\\) , both are resolved (Figure 4 ). Examples of S transformation. For typical coastal applications, we suggest \\(\\theta_b = 0\\) . Unfortunately, the \\(S\\) coordinate becomes invalid in shallow depth \\(\\tilde{h} \\lt h_c\\) ; under such circumstance, the traditional \\(\\sigma\\) coordinates (Equation 2) are used. \\(LSC^2\\) grid \u00b6 The 2nd type of vertical coordinate uses localized \\(\\sigma\\) Each grid node has its own vertical grid with a set of \\(\\sigma\\) coordinates for maximum flexibility; the mismatch of # of vertical levels between adjacent nodes is treated with shaved cells near the bottom, thus the name Localized Sigma Coordinates with Shaved Cells ( \\(LSC^2\\) ). Although there are many ways of generating a \\(LSC^2\\) grid, a convenient start is the Vanishing Quasi Sigma (VQS) suggested by Dukhovskoy et al. (2009). The essence of VQS is to first design a master (vertical) grid at selected reference depths, and then use this master grid to interpolate the local z coordinates at a grid node based on the local depth and 2 references depths that contains the depth (Figure 5 ). The original VQS also requires masking of thin layers near the bottom, and is not free of Z-like staircases near the bottom (Figure 5d ). Since SCHISM is an implicit model, we do not need such special treatment, and furthermore, \u2018fill in\u2019 unmatched levels with shaved cells to get \\(LSC^2\\) . As can be seen from Figure 5 , a major advantage of \\(LSC^2\\) , besides being very economical (as fewer/more # of levels are used in shallow/deep), is that it resembles a Z grid near the surface and interior of the water column while behaving like terrain-following grid near the bottom. As demonstrated in Zhang et al. (2015, 2016ab), \\(LSC^2\\) is instrumental in reducing unphysical diapycnal mixing and pressure-gradient errors (PGE). A well-designed \\(LSC^2\\) grid completely removes the need for bathymetry manipulation (e.g. smoothing/clipping), thus enabling a faithful representation of the bathymetry/topography, as demonstrated in those papers. However, some experience is required in designing a good \\(LSC^2\\) grid, and so beginners may want to start with the \\(SZ\\) grid. $LSC^2$ grid. (a) Horizontal grid showing the location of the transect (yellow line); (b) master grid at 19 reference depths; (c) corresponding vertical grid of the transect in (a), with degenerate prisms/shaved cells located near the bottom. (d) shows a typical VQS grid that contains staircases near the bottom. Prisms \u00b6 Regardless which type of vgrid is chosen, the basic 3D computational unit in SCHISM is a triangular or quad prism, with 3 or 4 vertical faces and uneven top and bottom faces (Figure 6 ). SCHISM solves all equations in the original Z space for consistency; even with spherical coordinates (lon/lat), the equations are not transformed but instead multiple coordinate frames are used (see below). A staggering scheme a la Arakawa-CD grid is used to define variables. The surface elevations are defined at the nodes. The horizontal velocities are defined at the side centers and whole levels. The vertical velocities are defined at the element centers and whole levels, and the tracer concentration is defined at prism center, as they are solved with a finite-volume method. The linear shape functions are used for elevations and velocities (the latter has a vertical linear shape function as well). For quad elements, the bi-linear shape function is used. Basic 3D computational unit in SCHISM where variables are staggered. At the end of each time step, the vertical levels are updated to account for free-surface movement. Although method like Arbitrary Lagrangian Eulerian (ALE) can be used to march the vertical levels in time, this is not done at the moment. Therefore, the state variables are simply moved to the new vertical location without re-interpolation. In the model sometimes vertical interpolation is required (e.g., calculation of baroclinc force). We use cubic spline interpolation in the vertical to minimize diffusion. Polymorphism \u00b6 The combination of \\(LSC^2\\) vertical grid ( Zhang et al. 2015 ) and horizontal mixed-element grids results in an extremely flexible grid system that has great practical applications. We demonstrate this with a toy problem for coastal ocean-estuary-river system depicted in Figure 7 . Since the tracer concentrations are defined at the prism centers, a row of quads and 1 vertical layer resembles a 1D model (Figure 7c ). Similarly, a row of quads with multiple vertical layers leads to 2DV configuration (Figure 7c ). Some parts of the shoals that are sufficiently shallow are discretized using 1 vertical layer (Figure 7b ), which is a 2DH configuration. The deeper part of the domain is discretized using full 3D prisms, but with a larger number of layers in the deeper depths than in the shallow depths, in a typical \\(LSC^2\\) fashion (Figure 7a ; Zhang et al. 2015 ). Different types of grids are seamlessly welded into a single SCHISM grid, resulting in greatest efficiency. With some care taken of the consistent bottom friction formulations across 1D, 2D and 3D, the model results show no discontinuity across different types of grids. The use of 1D or 2D cells in shallow areas also enhances numerical stability, as they are well suited and more stable for inundation process than 3D cells; e.g., the crowding of multiple 3D layers in the shallow depths is not conducive to stability. Model polymorphism illustrated with a toy problem. The mixed triangular-quadrangular grid and the bathymetry are shown in the foreground. The vertical transect grid along the redline going from deep ocean into estuary (\u2018shipping channel\u2019) is shown in insert (a). The 3D view of the grid near the head of estuary is shown in insert (b), with few layers on the shallow shoals. The grid near the upstream river is shown in insert (c), where transition from 2DV to 1D grid can be seen. In the test, a M2 tide is applied at the ocean boundary, and fresh water discharges are imposed at the heads of the river and estuary. References Zhang, Y., Ateljevich, E., Yu, H-C., Wu, C-H., and Yu, J.C.S. (2015) A new vertical coordinate system for a 3D unstructured-grid model, Ocean Modelling, 85, 16-31.","title":"Geometry and discretization"},{"location":"schism/geometry-discretization.html#horizontal-grid","text":"Hybrid triangular-quad elements are used in the horizontal, to take advantage of the superior boundary-fitting capability of triangles and efficiency/accuracy of quads in representing certain features like channels. Figure 1 shows an example of horizontal grid. Example horizontal grid (hgrid.gr3) of SCHISM. Figure 2 shows our convention of numbering local nodes/sides etc. Horizontal element convention. Local indices of nodes/sides for (a) triangular element, and (b) quad element. (c) Adjacent elements of an element (following side convention). (d,e): Local ball info (surrounding elements/nodes of node i) for (d) internal and (e) boundary node i. (f) shows a local side center-based frame used to calculate the normal fluxes; the (global) element number of \u201c1\u201d is smaller than \u201c2\u201d, and xs axis always points out of \u201c1\u201d. We follow counter-clockwise convention/right-hand rule.","title":"Horizontal grid"},{"location":"schism/geometry-discretization.html#vertical-grid","text":"","title":"Vertical grid"},{"location":"schism/geometry-discretization.html#hybrid-sz-grid","text":"The 1st type uses a hybrid S (terrain-following generalized s-coordinates; Song and Haidvogel 1994) and shaved z coordinates, with the latter always being placed underneath the former at a prescribed demarcation depth \\(h_s\\) . Note that the use of shaved z layers is optional and the users can use a pure \\(S\\) grid with a choice of \\(h_s\\) greater than the maximum depths in the grid. Figure 3 shows a \\(SZ\\) grid. Example of SZ grid. (a) Vertical coordinate systems (thick line is the bottom); (b) side view of a vertical transect resulted from SZ grid; the red cells are irregular/shaved cells. The transformation from \\(S\\) to \\(Z\\) is given by - \\[\\begin{equation} \\begin{aligned} z=\\eta(1+\\sigma) + h_x \\sigma + (\\tilde{h} - h_c)C(\\sigma), \\text{where} (-1 \\leq \\sigma \\leq 0)\\\\ \\\\ C(\\sigma) = (1-\\theta_b) \\frac{sinh(\\theta_f \\sigma)}{sinh \\theta_f} + \\theta_b \\frac{tanh \\left[ \\theta_f (\\sigma + 1/2) \\right] - tanh(\\theta_f/2)}{2 tanh (\\theta_f /2)}, \\text{given} ( 0 \\leq \\theta_b \\leq 1; 0 \\lt \\theta_f \\leq 20) \\end{aligned} \\end{equation}\\] where \\(\\tilde{h} = min(h, h_s)\\) is a \u201crestricted\u201d depth, \\(h_c\\) is a positive constant dictating the thickness of the bottom or surface layer that needs to be resolved, and \\(\\theta_b\\) and \\(\\theta_f\\) are constants that control the vertical resolution near the bottom and surface. As \\(\\theta_f \\rightarrow 0\\) , the \\(S\\) coordinates reduce to the traditional \\(\\sigma\\) -coordinates: \\[\\begin{equation} z=\\tilde{H} \\sigma + \\eta \\end{equation}\\] Where \\(\\tilde{H} = \\tilde{h} + \\eta\\) is the restricted total water depth. For \\(\\theta_f \\gg 1\\) , more resolution is skewed towards the boundaries, and the transformation becomes more nonlinear. If \\(\\theta_b \\rightarrow 0\\) , only the surface is resolved, not the bottom, while if \\(\\theta_b \\rightarrow 1\\) , both are resolved (Figure 4 ). Examples of S transformation. For typical coastal applications, we suggest \\(\\theta_b = 0\\) . Unfortunately, the \\(S\\) coordinate becomes invalid in shallow depth \\(\\tilde{h} \\lt h_c\\) ; under such circumstance, the traditional \\(\\sigma\\) coordinates (Equation 2) are used.","title":"Hybrid SZ grid"},{"location":"schism/geometry-discretization.html#lsc2-grid","text":"The 2nd type of vertical coordinate uses localized \\(\\sigma\\) Each grid node has its own vertical grid with a set of \\(\\sigma\\) coordinates for maximum flexibility; the mismatch of # of vertical levels between adjacent nodes is treated with shaved cells near the bottom, thus the name Localized Sigma Coordinates with Shaved Cells ( \\(LSC^2\\) ). Although there are many ways of generating a \\(LSC^2\\) grid, a convenient start is the Vanishing Quasi Sigma (VQS) suggested by Dukhovskoy et al. (2009). The essence of VQS is to first design a master (vertical) grid at selected reference depths, and then use this master grid to interpolate the local z coordinates at a grid node based on the local depth and 2 references depths that contains the depth (Figure 5 ). The original VQS also requires masking of thin layers near the bottom, and is not free of Z-like staircases near the bottom (Figure 5d ). Since SCHISM is an implicit model, we do not need such special treatment, and furthermore, \u2018fill in\u2019 unmatched levels with shaved cells to get \\(LSC^2\\) . As can be seen from Figure 5 , a major advantage of \\(LSC^2\\) , besides being very economical (as fewer/more # of levels are used in shallow/deep), is that it resembles a Z grid near the surface and interior of the water column while behaving like terrain-following grid near the bottom. As demonstrated in Zhang et al. (2015, 2016ab), \\(LSC^2\\) is instrumental in reducing unphysical diapycnal mixing and pressure-gradient errors (PGE). A well-designed \\(LSC^2\\) grid completely removes the need for bathymetry manipulation (e.g. smoothing/clipping), thus enabling a faithful representation of the bathymetry/topography, as demonstrated in those papers. However, some experience is required in designing a good \\(LSC^2\\) grid, and so beginners may want to start with the \\(SZ\\) grid. $LSC^2$ grid. (a) Horizontal grid showing the location of the transect (yellow line); (b) master grid at 19 reference depths; (c) corresponding vertical grid of the transect in (a), with degenerate prisms/shaved cells located near the bottom. (d) shows a typical VQS grid that contains staircases near the bottom.","title":"\\(LSC^2\\) grid"},{"location":"schism/geometry-discretization.html#prisms","text":"Regardless which type of vgrid is chosen, the basic 3D computational unit in SCHISM is a triangular or quad prism, with 3 or 4 vertical faces and uneven top and bottom faces (Figure 6 ). SCHISM solves all equations in the original Z space for consistency; even with spherical coordinates (lon/lat), the equations are not transformed but instead multiple coordinate frames are used (see below). A staggering scheme a la Arakawa-CD grid is used to define variables. The surface elevations are defined at the nodes. The horizontal velocities are defined at the side centers and whole levels. The vertical velocities are defined at the element centers and whole levels, and the tracer concentration is defined at prism center, as they are solved with a finite-volume method. The linear shape functions are used for elevations and velocities (the latter has a vertical linear shape function as well). For quad elements, the bi-linear shape function is used. Basic 3D computational unit in SCHISM where variables are staggered. At the end of each time step, the vertical levels are updated to account for free-surface movement. Although method like Arbitrary Lagrangian Eulerian (ALE) can be used to march the vertical levels in time, this is not done at the moment. Therefore, the state variables are simply moved to the new vertical location without re-interpolation. In the model sometimes vertical interpolation is required (e.g., calculation of baroclinc force). We use cubic spline interpolation in the vertical to minimize diffusion.","title":"Prisms"},{"location":"schism/geometry-discretization.html#polymorphism","text":"The combination of \\(LSC^2\\) vertical grid ( Zhang et al. 2015 ) and horizontal mixed-element grids results in an extremely flexible grid system that has great practical applications. We demonstrate this with a toy problem for coastal ocean-estuary-river system depicted in Figure 7 . Since the tracer concentrations are defined at the prism centers, a row of quads and 1 vertical layer resembles a 1D model (Figure 7c ). Similarly, a row of quads with multiple vertical layers leads to 2DV configuration (Figure 7c ). Some parts of the shoals that are sufficiently shallow are discretized using 1 vertical layer (Figure 7b ), which is a 2DH configuration. The deeper part of the domain is discretized using full 3D prisms, but with a larger number of layers in the deeper depths than in the shallow depths, in a typical \\(LSC^2\\) fashion (Figure 7a ; Zhang et al. 2015 ). Different types of grids are seamlessly welded into a single SCHISM grid, resulting in greatest efficiency. With some care taken of the consistent bottom friction formulations across 1D, 2D and 3D, the model results show no discontinuity across different types of grids. The use of 1D or 2D cells in shallow areas also enhances numerical stability, as they are well suited and more stable for inundation process than 3D cells; e.g., the crowding of multiple 3D layers in the shallow depths is not conducive to stability. Model polymorphism illustrated with a toy problem. The mixed triangular-quadrangular grid and the bathymetry are shown in the foreground. The vertical transect grid along the redline going from deep ocean into estuary (\u2018shipping channel\u2019) is shown in insert (a). The 3D view of the grid near the head of estuary is shown in insert (b), with few layers on the shallow shoals. The grid near the upstream river is shown in insert (c), where transition from 2DV to 1D grid can be seen. In the test, a M2 tide is applied at the ocean boundary, and fresh water discharges are imposed at the heads of the river and estuary. References Zhang, Y., Ateljevich, E., Yu, H-C., Wu, C-H., and Yu, J.C.S. (2015) A new vertical coordinate system for a 3D unstructured-grid model, Ocean Modelling, 85, 16-31.","title":"Polymorphism"},{"location":"schism/momentum-equation.html","text":"After the elevations are found, SCHISM solves the momentum Eqs. 1 along each vertical column at side centers. A semi-implicit Galerkin finite-element method is used, with the barotropic pressure gradient and the vertical viscosity terms being treated implicitly, and other terms treated explicitly. For 3D cells, we have - \\[\\begin{equation} \\label{eq01} \\int_{\\delta_b-h}^{\\eta} \\psi_l \\left[ \\pmb{u}^{n+1} - \\Delta t \\frac{\\partial}{\\partial z} \\left( \\nu \\frac{\\partial \\pmb{u}^{n+1}}{\\partial z} \\right) \\right] dz = \\int_{\\delta_b - h}^{\\eta} \\pmb{g} \\psi_l dz , (l = kbs + 1, \\cdots, N_z) \\end{equation}\\] where \\(\\psi\\) is the hat function in the vertical dimension, \\(\\delta_b\\) is the bottom cell thickness, and \\[\\begin{equation} \\label{eq02} \\pmb{g} = \\pmb{u}^* + \\Delta t \\left[ \\pmb{f} - g\\theta\\nabla\\eta^{n+1} - g(1-\\theta)\\nabla\\eta^n \\right] \\end{equation}\\] The two terms that are treated implicitly would have imposed the most severe stability constraints if treated explicitly. The explicit treatment of the baroclinic pressure gradient and the horizontal viscosity terms, however, does impose mild stability constraints. The final FEM equations are - \\[\\begin{equation} \\label{eq03} \\begin{aligned} \\frac{\\Delta z_{l+1}}{6} \\left( 2 \\pmb{u}_{l}^{n+1} + \\pmb{u}_{l+1}^{n+1} \\right) + \\frac{\\Delta z_l}{6} \\left( 2 \\pmb{u}_l^{n+1} + \\pmb{u}_{l-1}^{n+1} \\right) - \\nu_{l+1/2} \\Delta t \\frac{\\pmb{u}_{l+1}^{n+1} - \\pmb{u}_l^{n+1}}{\\Delta z_{l+1}} + \\nu_{l-1/2} \\Delta t \\frac{\\pmb{u}_l^{n+1} - \\pmb{u}_{l-1}^{n+1}}{\\Delta z_l} &= \\frac{\\Delta z_{l+1}}{6} \\left( 2 \\pmb{g}_l + \\pmb{g}_{l+1} \\right) + \\frac{\\Delta z_l}{6} \\left( 2\\pmb{g}_l + \\pmb{g}_{l-1} \\right), (l = kbs + 2, \\cdots, N_z - 1)\\\\ \\frac{\\Delta z_{l+1}}{6} \\left( 2\\pmb{u}_{l}^{n+1} + \\pmb{u}_{l+1}^{n+1} \\right) - \\nu_{l+1/2} \\Delta t \\frac{\\pmb{u}_{l+1}^{n+1} - \\pmb{u}_{l}^{n+1}}{\\Delta z_{l+1}} \\chi\\Delta t \\pmb{u}_{kbs+1}^{n+1} &= \\frac{\\Delta z_{l+1}}{6} \\left( 2\\pmb{g}_l + \\pmb{g}_{l+1} \\right), (l = kbs + 1)\\\\ \\frac{\\Delta z_l}{6} \\left( 2\\pmb{u}_l^{n+1} + \\pmb{u}_{l-1}^{n+1} \\right) + \\nu_{l-1/2} \\Delta t \\frac{\\pmb{u}_l^{n+1} - \\pmb{u}_{l-1}^{n+1}}{\\Delta z_l} &= \\pmb{\\tau}_{w}^{n+1} \\Delta t + \\frac{\\Delta z_l}{6} \\left( 2\\pmb{g}_l + \\pmb{g}_{l-1} \\right), (l=N_z) \\end{aligned} \\end{equation}\\] The bottom velocity is - \\[\\begin{equation} \\label{eq04} \\begin{aligned} \\pmb{u}_{kbs}^{n+1} &= 0, \\text{ if } \\chi \\neq 0\\\\ \\pmb{u}_{kbs}^{n+1} &= \\pmb{u}_{kbs + 1}^{n+1}, \\text{ if } \\chi = 0 \\end{aligned} \\end{equation}\\] which is consistent with the bottom BL formulation we used. After the velocities at all sides are found, the velocity at a node, which is needed in ELM, is evaluated using scheme MA or MB as discussed above. If a cell is 2D locally, the velocity is simply solved as - \\[\\begin{equation} \\label{eq05} \\pmb{u}^{n+1} = \\frac{\\breve{H}}{H} \\left[ \\pmb{u}^* + \\left( \\pmb{f} + \\pmb{\\tau}_w/H \\right) \\Delta t - g\\theta\\nabla\\eta^{n+1} - g(1-\\theta)\\nabla\\eta^n \\right] \\end{equation}\\]","title":"Momentum equation"},{"location":"schism/overview.html","text":"How to read this manual \u00b6 This manual contains detailed information on physical and numerical formulations, as well as usage for SCHISM. For beginners, we suggest you familiarize yourself with the basic notations in Physical formulation and Numerical formulation but skip some details in those two chapters; there is also a \u2018cheat sheet\u2019 in 'Typical workflow' below. This chapter describes how to set up the model, including mesh generation, and so should be read carefully, in consultation with appropriate sections in the 2 chapters and detailed descriptions on inputs/outputs . Since SCHISM is quite a sophisticated package, we strongly recommend you start from the simple test cases and gradually progress toward more complex 3D baroclinic or coupled applications. Notation used in this manual \u00b6 We will use bold characters to denote vectors and matrices, and unbold characters to denote scalars in mathematical equations. In addition, superscripts usually denote time step and subscripts denote spatial locations. E.g., \\(T_{i,k}^{n+1}\\) may mean the temperature at step \\(n+1\\) (i.e., new time step) and prism \\((i,k)\\) , where \\(i\\) is the element number and \\(k\\) is the (whole) vertical index. We will use inline code blocks to denote input file names (e.g. param.nml ) or code/pseudo-code fragments. Below are some notations used in this manual: \\(N_p\\) : number of nodes \\(N_s\\) : number of sides \\(N_e\\) : number of elements \\(N_z\\) : maximum number of vertical levels \\(i34(j)\\) : type of an element \\(j\\) (3: triangle; 4: quad) \\(Nb(i)\\) : number of surrounding elements of a node \\(i\\) ; \\(kbp(i)\\) : bottom index as seen by a node \\(i\\) \\(kbs(i)\\) : bottom index as seen by a side \\(i\\) \\(kbe(i)\\) : bottom index as seen by an element \\(i\\) \\(A\\) : area of an element \\(\\Delta z\\) : layer thickness (at a node, side or elem.) \\(\\delta_{ij}\\) : Kronecker Delta function ( \\(=1\\) when \\(i=j\\) ; \\(0\\) otherwise) Other resources for beginners \u00b6 Over the years various user groups have come up with their own documentations to help SCHISM beginners, and you may find them helpful. For example, CA Dept of Water Resources group maintained a ( Hello SCHISM site ).","title":"Overview"},{"location":"schism/overview.html#how-to-read-this-manual","text":"This manual contains detailed information on physical and numerical formulations, as well as usage for SCHISM. For beginners, we suggest you familiarize yourself with the basic notations in Physical formulation and Numerical formulation but skip some details in those two chapters; there is also a \u2018cheat sheet\u2019 in 'Typical workflow' below. This chapter describes how to set up the model, including mesh generation, and so should be read carefully, in consultation with appropriate sections in the 2 chapters and detailed descriptions on inputs/outputs . Since SCHISM is quite a sophisticated package, we strongly recommend you start from the simple test cases and gradually progress toward more complex 3D baroclinic or coupled applications.","title":"How to read this manual"},{"location":"schism/overview.html#notation-used-in-this-manual","text":"We will use bold characters to denote vectors and matrices, and unbold characters to denote scalars in mathematical equations. In addition, superscripts usually denote time step and subscripts denote spatial locations. E.g., \\(T_{i,k}^{n+1}\\) may mean the temperature at step \\(n+1\\) (i.e., new time step) and prism \\((i,k)\\) , where \\(i\\) is the element number and \\(k\\) is the (whole) vertical index. We will use inline code blocks to denote input file names (e.g. param.nml ) or code/pseudo-code fragments. Below are some notations used in this manual: \\(N_p\\) : number of nodes \\(N_s\\) : number of sides \\(N_e\\) : number of elements \\(N_z\\) : maximum number of vertical levels \\(i34(j)\\) : type of an element \\(j\\) (3: triangle; 4: quad) \\(Nb(i)\\) : number of surrounding elements of a node \\(i\\) ; \\(kbp(i)\\) : bottom index as seen by a node \\(i\\) \\(kbs(i)\\) : bottom index as seen by a side \\(i\\) \\(kbe(i)\\) : bottom index as seen by an element \\(i\\) \\(A\\) : area of an element \\(\\Delta z\\) : layer thickness (at a node, side or elem.) \\(\\delta_{ij}\\) : Kronecker Delta function ( \\(=1\\) when \\(i=j\\) ; \\(0\\) otherwise)","title":"Notation used in this manual"},{"location":"schism/overview.html#other-resources-for-beginners","text":"Over the years various user groups have come up with their own documentations to help SCHISM beginners, and you may find them helpful. For example, CA Dept of Water Resources group maintained a ( Hello SCHISM site ).","title":"Other resources for beginners"},{"location":"schism/physical-formulation.html","text":"Governing equations \u00b6 We will focus only on the hydrostatic solver in side SCHISM. Under this mode, we solve the standard Navier-Stokes equations with hydrostatic and Boussinesq approximations, including the effects of vegetation. Momentum equation: \\[\\begin{equation} \\begin{aligned} \\frac{Du}{dt} = \\pmb{f} - g \\nabla \\eta + \\pmb{m}_z - \\alpha \\left| \\pmb{u} \\right| \\pmb{u} L(x, y, z)\\\\ \\pmb{f} = f(v, -u) - \\frac{g}{\\rho_0} \\int_z^{\\eta} \\nabla \\rho d\\zeta - \\frac{\\nabla p_A}{\\rho_0} + a g \\nabla \\Psi + \\pmb{F}_m + other \\end{aligned} \\label{eq:momentum} \\end{equation}\\] Continuity equation in 3D and 2D depth-integrated forms: \\[\\begin{align} \\nabla \\cdot \\pmb{u} + \\frac{\\partial w}{\\partial z} = 0\\\\ \\frac{\\partial \\eta}{\\partial t} + \\nabla \\cdot \\int_{-h}^{\\eta} \\pmb{u} dz = 0 \\end{align}\\] Transport equations: \\[\\begin{equation} \\frac{\\partial C}{\\partial t} + \\nabla \\cdot (\\pmb{u}C) = \\frac{\\partial}{\\partial z} \\left( \\kappa \\frac{\\partial C}{\\partial z} \\right) + F_h \\end{equation}\\] Equation of state: \\[\\begin{equation*} \\rho = \\rho(S, T, p) \\end{equation*}\\] Where, \\(\\nabla\\) : \\(\\left( \\frac{\\partial}{\\partial x}, \\frac{\\partial}{\\partial y} \\right)\\) \\(\\frac{D}{Dt}\\) : material derivative \\((x, y)\\) : horizontal Cartesian coordinates \\(z\\) : vertical coordinate, positive upward \\(t\\) : time \\(\\eta(x, y, t)\\) : free-surface elevation in meters [ \\(m\\) ] \\(h(x, y)\\) : bathymetric depth (measured from a fixed datum) [ \\(m\\) ] \\(\\pmb{u}(x, y, z, t)\\) : horizontal velocity, with Cartesian components \\((u, v)\\) [ \\(m/s\\) ] \\(w(x, y, z, t)\\) : vertical velocity [ \\(m/s\\) ] \\(p\\) : hydrostatic pressure [ \\(Pa\\) ] \\(p_A\\) : atmospheric pressure reduced to mean sea level (MSL) [ \\(Pa\\) ] \\(\\rho, \\rho_0\\) : water density and reference water density [ \\(kg/m^3\\) ] \\(\\pmb{f}\\) : other forcing terms in momentum (baroclinic gradient, horizontal viscosity, Coriolis, earth tidal potential, atmospheric pressure, radiation stress). These are usually treated explicitly in the numerical formulation \\(g\\) : acceleration of gravity, in [ \\(m/s^2\\) ] \\(C\\) : tracer concentration (e.g., salinity, temperature, sediment etc) \\(\\nu\\) : vertical eddy viscosity, in [ \\(m^2/s\\) ] \\(\\kappa\\) : vertical eddy diffusivity, for tracers, in [ \\(m^2/s\\) ] \\(\\pmb{F}_m\\) : horizontal viscosity [ \\(m^2/s\\) ] \\(F_h\\) : horizontal diffusion and mass sources/sinks [ \\(m^2/s\\) ] Vegetation effects have been accounted for in Eq. 1. The main vegetation parameter is \\(\\alpha(x, y) = D_v N_v C_{Dv}/2\\) is a vegetation related density variable in [ \\(m^{-1}]\\) , where \\(D_v\\) is the stem diameter, \\(N_v\\) is the vegetation density (number of stems per \\(m^2\\) ), and \\(C_{Dv}\\) is the bulk form drag coefficient. Selection of \\(C_{Dv}\\) is the topic of other studies with values between 0 and 3 ( Nepf and Vivoni 2000 ; Tanino and Nepf 2008 ), and is validated against reported lab study values. The underlying assumption used here is to treat the vegetation as arrays of solid cylinders, which is only a first-order approximation of the problem. Flexibility of the vegetation, sheltering effects within a cluster of vegetation can lead to one to two orders of reduction in the drag forces, and Gaylord et al. (2008) showed that the drag formulation is also species dependent. These additional complexities are outside the scope of the current study. In this paper, we assume \\(C_{Dv}\\) is a constant, but a vertically varying \\(C_{Dv}\\) (as suggested by Nepf and Vivoni 2000 and others) can be easily added as well; the latter can be used to approximate flexible stems ( Nepf and Vivoni 2000 ; Luhar and Nepf 2011). Since SCHISM allows \u2018polymorphism\u2019 with mixed 2D and 3D cells in a single grid ( Zhang et al. 2016 ), we have different forms for the vertical eddy viscosity term \\(\\pmb{m}_z\\) and vegetation term \\(L(x, y, z)\\) . \\[\\begin{equation} \\begin{aligned} \\pmb{m}_z= \\begin{cases} \\frac{\\partial}{\\partial z}\\left( \\nu \\frac{\\partial \\pmb{u}}{\\partial z} \\right),& \\text{3D cells}\\\\ \\frac{\\pmb{\\tau}_w - \\chi \\pmb{u}}{H}, & \\text{2D cells} \\end{cases}\\\\ L(x, y, z)= \\begin{cases} \\mathcal{H}(z_v - z),& \\text{3D}\\\\ 1, & \\text{2D} \\end{cases} \\end{aligned} \\end{equation}\\] where, \\(\\nu\\) is the eddy viscosity, \\(\\pmb{\\tau}_w\\) is the surface wind stress, \\(H=h+\\eta\\) is the total water depth (with \\(h\\) being the depth measured from a fixed datum), \\(\\chi = C_d \\left| \\pmb{u} \\right|\\) , \\(C_D\\) is the bottom drag coefficient, \\(z_v\\) is the z-coordinate of the canopy, and \\(\\mathcal{H}()\\) is the Heaviside step function - \\[\\begin{equation*} \\mathcal{H} = \\begin{cases} 1, & x \\geq 0\\\\ 0, & x \\lt 0 \\end{cases} \\end{equation*}\\] Note that \\(\\pmb{u}\\) denotes the depth-averaged velocity in a 2D region. Boundary conditions (B.C.) \u00b6 The differential equations above need initial condition (I.C.) and B.C. In general, all state variables ( \\(\\eta\\) , \\(\\pmb{u}\\) , \\(C\\) ) are specified at \\(t=0\\) as I.C. and these are also specified at all open lateral boundary segments (open ocean, rivers etc). However, not all variables need to be specified at all boundary segments and we\u2019ll revisit this in the input-output section, i.e., bctides . The vertical B.C. for (Eq 1-4) are described in detail below as these impact the numerical scheme. Note that these only apply to 3D cells; for 2D cells, Eq. 1a has taken into account the B.C. At the sea surface, SCHISM enforces the balance between the internal Reynolds stress and the applied shear stress. \\[\\begin{equation} \\nu \\frac{\\partial \\pmb{u}}{\\partial z} = \\pmb{\\tau}_w, \\text{ at } z = \\eta \\end{equation}\\] where the stress \\(\\pmb{\\tau}_z\\) can be parameterized using the approach of Zeng et al. (1998) or the simpler approach of Pond and Pickard (1998) . If the Wind Wave Model is invoked, it can also be calculated from the wave model. Because the bottom boundary layer is usually not well resolved in ocean models, the no-slip condition at the sea or river bottom ( \\(\\pmb{u} = w = 0\\) ) is replaced by a balance between the internal Reynolds stress and the bottom frictional stress. \\[\\begin{equation} \\nu \\frac{\\partial \\pmb{u}}{\\partial z} = \\pmb{\\tau}_b, \\text{ at } z=-h \\end{equation}\\] The specific form of the bottom stress \\(\\pmb{\\tau}_b\\) depends on the type of boundary layer used and here we will only discuss the turbulent boundary layer below (Blumberg and Mellor 1987), given its prevalent usage in ocean modeling. The bottom stress is then - \\[\\begin{equation} \\pmb{\\tau}_b = C_D \\left| \\pmb{u}_b \\right| \\pmb{u}_b \\equiv \\chi \\pmb{u}_b \\end{equation}\\] The velocity profile in the interior of the bottom boundary layer obeys the logarithmic law, which is smoothly matched to the exterior flow at the top of the boundary layer. \\[\\begin{equation} \\pmb{u} = \\frac{ln[(z+h)/z_0]}{ln(\\delta_b/z_0)}\\pmb{u}_b, z_0-h \\leq z \\leq \\delta_b -h \\end{equation}\\] Here, \\(\\delta_b\\) is the thickness of the bottom computational cell (assuming that the bottom is sufficiently resolved in SCHISM that the bottom cell is inside the boundary layer), \\(z_0\\) is the bottom roughness, and \\(\\pmb{u}_b\\) is the velocity measured at the top of the bottom computational cell. Therefore the Reynolds stress inside the boundary layer is derived as - \\[\\begin{equation} \\nu \\frac{\\partial \\pmb{u}}{\\partial z} = \\frac{\\nu}{(z+h)ln(\\delta_b/z_0)} \\pmb{u}_b \\end{equation}\\] Utilizing the turbulence closure theory discussed below, we can show that the Reynolds stress is constant inside the boundary layer - \\[\\begin{equation} \\nu \\frac{\\partial \\pmb{u}}{\\partial z} = \\frac{\\kappa_0}{ln(\\delta_b/z_0)} C_D^{1/2} \\left| \\pmb{u}_b \\right| \\pmb{u}_b, z_0-h \\leq z \\leq \\delta_b -h \\end{equation}\\] and the drag coefficient is calculated from Eq. 7, 8, and 11 as - \\[\\begin{equation} C_D = \\left( \\frac{1}{\\kappa_0} ln(\\delta_b/z_0) \\right) ^{-2} \\end{equation}\\] which is the drag formula as discussed in Blumberg and Mellor (1987) . Eq. 11 also shows that the vertical viscosity term in the momentum equation vanishes inside the boundary layer. This fact will be utilized in the numerical formulation. Turbulence closure \u00b6 Eq 1-4 are not closed and must be supplemented by turbulence closure equations for the viscosity/diffusivity. We use the Generic Length-scale (GLS) model of Umlauf and Burchard (2003) , which has the advantage of encompassing most of the Eq 6 closure models \\(k-\\varepsilon\\) ( Rodi 1984 ); \\(k-\\omega\\) ( Wilcox 1998 ; Mellor and Yamada, 1982 ). In this framework, the transport, production, and dissipation of the turbulent kinetic energy ( \\(K\\) ) and of a generic length-scale variable ( \\(\\psi\\) ) are governed by - \\[\\begin{equation} \\frac{Dk}{Dt} = \\frac{\\partial}{\\partial z} \\left( \\nu_k^{\\psi} \\frac{\\partial k}{\\partial z} \\right) + \\nu M^2 + \\kappa N^2 - \\varepsilon + c_{fk} \\alpha \\left| \\pmb{u} \\right|^3 \\mathcal{H} (z_v - z) \\end{equation}\\] \\[\\begin{equation} \\frac{D \\psi}{Dt} = \\frac{\\partial}{\\partial z} \\left( \\nu_{\\psi} \\frac{\\partial \\psi}{\\partial z} \\right) + \\frac{\\psi}{k}\\left[ c_{\\psi 1} \\nu M^2 + c_{\\psi 3} \\kappa N^2 - c_{\\psi 2}\\varepsilon F_{wall} + c_{f\\psi} \\alpha \\left| \\pmb{u} \\right|^3 \\mathcal{H}(z_v-z) \\right] \\end{equation}\\] where \\(\\nu_k^{\\psi}\\) and \\(\\nu_{\\psi}\\) are vertical turbulent diffusivities, \\(c_{\\psi 1}\\) , \\(c_{\\psi 2}\\) , and \\(c_{\\psi 3}\\) are model-specific constants ( Umlauf and Burchard 2003 ), \\(F_{wall}\\) is a wall proximity function, \\(M\\) and \\(N\\) are shear and buoyancy frequencies, and \\(\\varepsilon\\) is a dissipation rate. The generic length-scale is defined as - \\[\\begin{equation} \\psi = (c_{\\mu}^0)^p K^m \\ell^n \\end{equation}\\] where \\(c_{\\mu}^0 = 0.3^{1/2}\\) and \\(\\ell\\) is the turbulence mixing length. The specific choices of the constants \\(p\\) , \\(m\\) , and \\(n\\) lead to the different closure models mentioned above. Finally, vertical viscosities and diffusivities as appeared in Eq 1-4 are related to \\(K\\) , \\(ell\\) , and stability functions - \\[\\begin{equation} \\begin{aligned} \\nu = \\sqrt{2} s_m K^{1/2} \\ell \\\\ \\kappa = \\sqrt{2} s_h K^{1/2} \\ell \\\\ \\nu_k^{\\psi} = \\frac{\\nu}{\\sigma_k^{\\psi}} \\\\ \\nu_{\\psi} = \\frac{\\nu}{\\sigma_{\\psi}} \\end{aligned} \\end{equation}\\] where the Schmidt numbers \\(\\sigma_k^{\\psi}\\) and \\(\\sigma_{\\psi}\\) are model-specific constants. The stability functions ( \\(s_m\\) and \\(s_h\\) ) are given by an Algebraic Stress Model (e.g.: Kantha and Clayson 1994 , Canuto et al. 2001 , or Galperin et al. 1988 ). Following Shimizu and Tsujimoto (1994; ST94 hereafter) , we set \\(c_{fk} = 0.07\\) and \\(c_{f\\psi} = 0.16\\) . At the free surface and at the bottom of rivers and oceans, the turbulent kinetic energy and the mixing length are specified as Direchlet boundary conditions - \\[\\begin{equation} K = \\frac{1}{2} B_1^{2/3} \\left| \\pmb{\\tau_b} \\right|, \\text{ or } \\frac{1}{2} B_1^{2/3} \\left| \\pmb{\\tau_w} \\right| \\end{equation}\\] \\[\\begin{equation} \\ell = \\kappa_o d_b \\text{ or } \\kappa_0 d_s \\end{equation}\\] where \\(\\pmb{\\tau_b}\\) is a bottom frictional stress, \\(\\kappa_0 = 0.4\\) is the von Karman\u2019s constant, \\(B_1\\) is a constant, and \\(d_b\\) and \\(d_s\\) are the distances to the bottom and the free surface, respectively. Air-sea exchange \u00b6 We use the bulk aerodynamic module of Zeng et al. (1998) , which can be viewed here . References Blumberg, A.F. and G.L. Mellor (1987) A description of a three-dimensional coastal ocean circulation model. In: Three-Dimensional Coastal Ocean Models, vol. 4, Coastal and Estuarine Studies, N. Heaps, editor, Washington, D.C.: AGU, pp. 1-16. Canuto, V.M., A. Howard, Y. Cheng and M.S. Dubovikov (2001) Ocean turbulence I: one-point closure model. Momentum and heat vertical diffusivities. J. Phys. Oceano., 31, pp. 1413-1426. Galperin, B., L. H. Kantha, S. Hassid and A. Rosati (1988) A quasi-equilibrium turbulent energy model for geophysical flows. J. Atmos. Sci., 45, pp. 55-62. Kantha, L.H. and C.A. Clayson (1994) An improved mixed layer model for geophysical applications. J. Geophy. Res, 99(25), pp. 235-266. Mellor, G.L. and T. Yamada (1982) Development of a turbulence closure model for geophysical fluid problems. Rev. Geophys., 20, pp. 851-875. Pond, S. and G.L. Pickard (1998) Introductory Dynamical Oceanography, Butterworth-Heinmann. Rodi, W. (1984) Turbulence models and their applications in hydraulics: a state of the art review. Delft, The Netherlands, International Association for Hydraulics Research. Umlauf, L. and H. Burchard (2003) A generic length-scale equation for geophysical turbulence models. J. Mar. Res., 6, pp. 235-265. Wilcox, D.C. (1998) Reassessment of scale determining equation for advance turbulence models. AIAA J., 26, pp. 1299-1310. Zeng, X., M. Zhao and R.E. Dickinson (1998) Intercomparison of bulk aerodynamic algorithms for the computation of sea surface fluxes using TOGA COARE and TAO data. J. Clim., 11, pp. 2628-2644. Zhang, Y., Ye, F., Stanev, E.V., Grashorn, S. (2016). Seamless cross-scale modeling with SCHISM, Ocean Modelling, 102, 64-81. doi:10.1016/j.ocemod.2016.05.002","title":"Physical formulation"},{"location":"schism/physical-formulation.html#governing-equations","text":"We will focus only on the hydrostatic solver in side SCHISM. Under this mode, we solve the standard Navier-Stokes equations with hydrostatic and Boussinesq approximations, including the effects of vegetation. Momentum equation: \\[\\begin{equation} \\begin{aligned} \\frac{Du}{dt} = \\pmb{f} - g \\nabla \\eta + \\pmb{m}_z - \\alpha \\left| \\pmb{u} \\right| \\pmb{u} L(x, y, z)\\\\ \\pmb{f} = f(v, -u) - \\frac{g}{\\rho_0} \\int_z^{\\eta} \\nabla \\rho d\\zeta - \\frac{\\nabla p_A}{\\rho_0} + a g \\nabla \\Psi + \\pmb{F}_m + other \\end{aligned} \\label{eq:momentum} \\end{equation}\\] Continuity equation in 3D and 2D depth-integrated forms: \\[\\begin{align} \\nabla \\cdot \\pmb{u} + \\frac{\\partial w}{\\partial z} = 0\\\\ \\frac{\\partial \\eta}{\\partial t} + \\nabla \\cdot \\int_{-h}^{\\eta} \\pmb{u} dz = 0 \\end{align}\\] Transport equations: \\[\\begin{equation} \\frac{\\partial C}{\\partial t} + \\nabla \\cdot (\\pmb{u}C) = \\frac{\\partial}{\\partial z} \\left( \\kappa \\frac{\\partial C}{\\partial z} \\right) + F_h \\end{equation}\\] Equation of state: \\[\\begin{equation*} \\rho = \\rho(S, T, p) \\end{equation*}\\] Where, \\(\\nabla\\) : \\(\\left( \\frac{\\partial}{\\partial x}, \\frac{\\partial}{\\partial y} \\right)\\) \\(\\frac{D}{Dt}\\) : material derivative \\((x, y)\\) : horizontal Cartesian coordinates \\(z\\) : vertical coordinate, positive upward \\(t\\) : time \\(\\eta(x, y, t)\\) : free-surface elevation in meters [ \\(m\\) ] \\(h(x, y)\\) : bathymetric depth (measured from a fixed datum) [ \\(m\\) ] \\(\\pmb{u}(x, y, z, t)\\) : horizontal velocity, with Cartesian components \\((u, v)\\) [ \\(m/s\\) ] \\(w(x, y, z, t)\\) : vertical velocity [ \\(m/s\\) ] \\(p\\) : hydrostatic pressure [ \\(Pa\\) ] \\(p_A\\) : atmospheric pressure reduced to mean sea level (MSL) [ \\(Pa\\) ] \\(\\rho, \\rho_0\\) : water density and reference water density [ \\(kg/m^3\\) ] \\(\\pmb{f}\\) : other forcing terms in momentum (baroclinic gradient, horizontal viscosity, Coriolis, earth tidal potential, atmospheric pressure, radiation stress). These are usually treated explicitly in the numerical formulation \\(g\\) : acceleration of gravity, in [ \\(m/s^2\\) ] \\(C\\) : tracer concentration (e.g., salinity, temperature, sediment etc) \\(\\nu\\) : vertical eddy viscosity, in [ \\(m^2/s\\) ] \\(\\kappa\\) : vertical eddy diffusivity, for tracers, in [ \\(m^2/s\\) ] \\(\\pmb{F}_m\\) : horizontal viscosity [ \\(m^2/s\\) ] \\(F_h\\) : horizontal diffusion and mass sources/sinks [ \\(m^2/s\\) ] Vegetation effects have been accounted for in Eq. 1. The main vegetation parameter is \\(\\alpha(x, y) = D_v N_v C_{Dv}/2\\) is a vegetation related density variable in [ \\(m^{-1}]\\) , where \\(D_v\\) is the stem diameter, \\(N_v\\) is the vegetation density (number of stems per \\(m^2\\) ), and \\(C_{Dv}\\) is the bulk form drag coefficient. Selection of \\(C_{Dv}\\) is the topic of other studies with values between 0 and 3 ( Nepf and Vivoni 2000 ; Tanino and Nepf 2008 ), and is validated against reported lab study values. The underlying assumption used here is to treat the vegetation as arrays of solid cylinders, which is only a first-order approximation of the problem. Flexibility of the vegetation, sheltering effects within a cluster of vegetation can lead to one to two orders of reduction in the drag forces, and Gaylord et al. (2008) showed that the drag formulation is also species dependent. These additional complexities are outside the scope of the current study. In this paper, we assume \\(C_{Dv}\\) is a constant, but a vertically varying \\(C_{Dv}\\) (as suggested by Nepf and Vivoni 2000 and others) can be easily added as well; the latter can be used to approximate flexible stems ( Nepf and Vivoni 2000 ; Luhar and Nepf 2011). Since SCHISM allows \u2018polymorphism\u2019 with mixed 2D and 3D cells in a single grid ( Zhang et al. 2016 ), we have different forms for the vertical eddy viscosity term \\(\\pmb{m}_z\\) and vegetation term \\(L(x, y, z)\\) . \\[\\begin{equation} \\begin{aligned} \\pmb{m}_z= \\begin{cases} \\frac{\\partial}{\\partial z}\\left( \\nu \\frac{\\partial \\pmb{u}}{\\partial z} \\right),& \\text{3D cells}\\\\ \\frac{\\pmb{\\tau}_w - \\chi \\pmb{u}}{H}, & \\text{2D cells} \\end{cases}\\\\ L(x, y, z)= \\begin{cases} \\mathcal{H}(z_v - z),& \\text{3D}\\\\ 1, & \\text{2D} \\end{cases} \\end{aligned} \\end{equation}\\] where, \\(\\nu\\) is the eddy viscosity, \\(\\pmb{\\tau}_w\\) is the surface wind stress, \\(H=h+\\eta\\) is the total water depth (with \\(h\\) being the depth measured from a fixed datum), \\(\\chi = C_d \\left| \\pmb{u} \\right|\\) , \\(C_D\\) is the bottom drag coefficient, \\(z_v\\) is the z-coordinate of the canopy, and \\(\\mathcal{H}()\\) is the Heaviside step function - \\[\\begin{equation*} \\mathcal{H} = \\begin{cases} 1, & x \\geq 0\\\\ 0, & x \\lt 0 \\end{cases} \\end{equation*}\\] Note that \\(\\pmb{u}\\) denotes the depth-averaged velocity in a 2D region.","title":"Governing equations"},{"location":"schism/physical-formulation.html#boundary-conditions-bc","text":"The differential equations above need initial condition (I.C.) and B.C. In general, all state variables ( \\(\\eta\\) , \\(\\pmb{u}\\) , \\(C\\) ) are specified at \\(t=0\\) as I.C. and these are also specified at all open lateral boundary segments (open ocean, rivers etc). However, not all variables need to be specified at all boundary segments and we\u2019ll revisit this in the input-output section, i.e., bctides . The vertical B.C. for (Eq 1-4) are described in detail below as these impact the numerical scheme. Note that these only apply to 3D cells; for 2D cells, Eq. 1a has taken into account the B.C. At the sea surface, SCHISM enforces the balance between the internal Reynolds stress and the applied shear stress. \\[\\begin{equation} \\nu \\frac{\\partial \\pmb{u}}{\\partial z} = \\pmb{\\tau}_w, \\text{ at } z = \\eta \\end{equation}\\] where the stress \\(\\pmb{\\tau}_z\\) can be parameterized using the approach of Zeng et al. (1998) or the simpler approach of Pond and Pickard (1998) . If the Wind Wave Model is invoked, it can also be calculated from the wave model. Because the bottom boundary layer is usually not well resolved in ocean models, the no-slip condition at the sea or river bottom ( \\(\\pmb{u} = w = 0\\) ) is replaced by a balance between the internal Reynolds stress and the bottom frictional stress. \\[\\begin{equation} \\nu \\frac{\\partial \\pmb{u}}{\\partial z} = \\pmb{\\tau}_b, \\text{ at } z=-h \\end{equation}\\] The specific form of the bottom stress \\(\\pmb{\\tau}_b\\) depends on the type of boundary layer used and here we will only discuss the turbulent boundary layer below (Blumberg and Mellor 1987), given its prevalent usage in ocean modeling. The bottom stress is then - \\[\\begin{equation} \\pmb{\\tau}_b = C_D \\left| \\pmb{u}_b \\right| \\pmb{u}_b \\equiv \\chi \\pmb{u}_b \\end{equation}\\] The velocity profile in the interior of the bottom boundary layer obeys the logarithmic law, which is smoothly matched to the exterior flow at the top of the boundary layer. \\[\\begin{equation} \\pmb{u} = \\frac{ln[(z+h)/z_0]}{ln(\\delta_b/z_0)}\\pmb{u}_b, z_0-h \\leq z \\leq \\delta_b -h \\end{equation}\\] Here, \\(\\delta_b\\) is the thickness of the bottom computational cell (assuming that the bottom is sufficiently resolved in SCHISM that the bottom cell is inside the boundary layer), \\(z_0\\) is the bottom roughness, and \\(\\pmb{u}_b\\) is the velocity measured at the top of the bottom computational cell. Therefore the Reynolds stress inside the boundary layer is derived as - \\[\\begin{equation} \\nu \\frac{\\partial \\pmb{u}}{\\partial z} = \\frac{\\nu}{(z+h)ln(\\delta_b/z_0)} \\pmb{u}_b \\end{equation}\\] Utilizing the turbulence closure theory discussed below, we can show that the Reynolds stress is constant inside the boundary layer - \\[\\begin{equation} \\nu \\frac{\\partial \\pmb{u}}{\\partial z} = \\frac{\\kappa_0}{ln(\\delta_b/z_0)} C_D^{1/2} \\left| \\pmb{u}_b \\right| \\pmb{u}_b, z_0-h \\leq z \\leq \\delta_b -h \\end{equation}\\] and the drag coefficient is calculated from Eq. 7, 8, and 11 as - \\[\\begin{equation} C_D = \\left( \\frac{1}{\\kappa_0} ln(\\delta_b/z_0) \\right) ^{-2} \\end{equation}\\] which is the drag formula as discussed in Blumberg and Mellor (1987) . Eq. 11 also shows that the vertical viscosity term in the momentum equation vanishes inside the boundary layer. This fact will be utilized in the numerical formulation.","title":"Boundary conditions (B.C.)"},{"location":"schism/physical-formulation.html#turbulence-closure","text":"Eq 1-4 are not closed and must be supplemented by turbulence closure equations for the viscosity/diffusivity. We use the Generic Length-scale (GLS) model of Umlauf and Burchard (2003) , which has the advantage of encompassing most of the Eq 6 closure models \\(k-\\varepsilon\\) ( Rodi 1984 ); \\(k-\\omega\\) ( Wilcox 1998 ; Mellor and Yamada, 1982 ). In this framework, the transport, production, and dissipation of the turbulent kinetic energy ( \\(K\\) ) and of a generic length-scale variable ( \\(\\psi\\) ) are governed by - \\[\\begin{equation} \\frac{Dk}{Dt} = \\frac{\\partial}{\\partial z} \\left( \\nu_k^{\\psi} \\frac{\\partial k}{\\partial z} \\right) + \\nu M^2 + \\kappa N^2 - \\varepsilon + c_{fk} \\alpha \\left| \\pmb{u} \\right|^3 \\mathcal{H} (z_v - z) \\end{equation}\\] \\[\\begin{equation} \\frac{D \\psi}{Dt} = \\frac{\\partial}{\\partial z} \\left( \\nu_{\\psi} \\frac{\\partial \\psi}{\\partial z} \\right) + \\frac{\\psi}{k}\\left[ c_{\\psi 1} \\nu M^2 + c_{\\psi 3} \\kappa N^2 - c_{\\psi 2}\\varepsilon F_{wall} + c_{f\\psi} \\alpha \\left| \\pmb{u} \\right|^3 \\mathcal{H}(z_v-z) \\right] \\end{equation}\\] where \\(\\nu_k^{\\psi}\\) and \\(\\nu_{\\psi}\\) are vertical turbulent diffusivities, \\(c_{\\psi 1}\\) , \\(c_{\\psi 2}\\) , and \\(c_{\\psi 3}\\) are model-specific constants ( Umlauf and Burchard 2003 ), \\(F_{wall}\\) is a wall proximity function, \\(M\\) and \\(N\\) are shear and buoyancy frequencies, and \\(\\varepsilon\\) is a dissipation rate. The generic length-scale is defined as - \\[\\begin{equation} \\psi = (c_{\\mu}^0)^p K^m \\ell^n \\end{equation}\\] where \\(c_{\\mu}^0 = 0.3^{1/2}\\) and \\(\\ell\\) is the turbulence mixing length. The specific choices of the constants \\(p\\) , \\(m\\) , and \\(n\\) lead to the different closure models mentioned above. Finally, vertical viscosities and diffusivities as appeared in Eq 1-4 are related to \\(K\\) , \\(ell\\) , and stability functions - \\[\\begin{equation} \\begin{aligned} \\nu = \\sqrt{2} s_m K^{1/2} \\ell \\\\ \\kappa = \\sqrt{2} s_h K^{1/2} \\ell \\\\ \\nu_k^{\\psi} = \\frac{\\nu}{\\sigma_k^{\\psi}} \\\\ \\nu_{\\psi} = \\frac{\\nu}{\\sigma_{\\psi}} \\end{aligned} \\end{equation}\\] where the Schmidt numbers \\(\\sigma_k^{\\psi}\\) and \\(\\sigma_{\\psi}\\) are model-specific constants. The stability functions ( \\(s_m\\) and \\(s_h\\) ) are given by an Algebraic Stress Model (e.g.: Kantha and Clayson 1994 , Canuto et al. 2001 , or Galperin et al. 1988 ). Following Shimizu and Tsujimoto (1994; ST94 hereafter) , we set \\(c_{fk} = 0.07\\) and \\(c_{f\\psi} = 0.16\\) . At the free surface and at the bottom of rivers and oceans, the turbulent kinetic energy and the mixing length are specified as Direchlet boundary conditions - \\[\\begin{equation} K = \\frac{1}{2} B_1^{2/3} \\left| \\pmb{\\tau_b} \\right|, \\text{ or } \\frac{1}{2} B_1^{2/3} \\left| \\pmb{\\tau_w} \\right| \\end{equation}\\] \\[\\begin{equation} \\ell = \\kappa_o d_b \\text{ or } \\kappa_0 d_s \\end{equation}\\] where \\(\\pmb{\\tau_b}\\) is a bottom frictional stress, \\(\\kappa_0 = 0.4\\) is the von Karman\u2019s constant, \\(B_1\\) is a constant, and \\(d_b\\) and \\(d_s\\) are the distances to the bottom and the free surface, respectively.","title":"Turbulence closure"},{"location":"schism/physical-formulation.html#air-sea-exchange","text":"We use the bulk aerodynamic module of Zeng et al. (1998) , which can be viewed here . References Blumberg, A.F. and G.L. Mellor (1987) A description of a three-dimensional coastal ocean circulation model. In: Three-Dimensional Coastal Ocean Models, vol. 4, Coastal and Estuarine Studies, N. Heaps, editor, Washington, D.C.: AGU, pp. 1-16. Canuto, V.M., A. Howard, Y. Cheng and M.S. Dubovikov (2001) Ocean turbulence I: one-point closure model. Momentum and heat vertical diffusivities. J. Phys. Oceano., 31, pp. 1413-1426. Galperin, B., L. H. Kantha, S. Hassid and A. Rosati (1988) A quasi-equilibrium turbulent energy model for geophysical flows. J. Atmos. Sci., 45, pp. 55-62. Kantha, L.H. and C.A. Clayson (1994) An improved mixed layer model for geophysical applications. J. Geophy. Res, 99(25), pp. 235-266. Mellor, G.L. and T. Yamada (1982) Development of a turbulence closure model for geophysical fluid problems. Rev. Geophys., 20, pp. 851-875. Pond, S. and G.L. Pickard (1998) Introductory Dynamical Oceanography, Butterworth-Heinmann. Rodi, W. (1984) Turbulence models and their applications in hydraulics: a state of the art review. Delft, The Netherlands, International Association for Hydraulics Research. Umlauf, L. and H. Burchard (2003) A generic length-scale equation for geophysical turbulence models. J. Mar. Res., 6, pp. 235-265. Wilcox, D.C. (1998) Reassessment of scale determining equation for advance turbulence models. AIAA J., 26, pp. 1299-1310. Zeng, X., M. Zhao and R.E. Dickinson (1998) Intercomparison of bulk aerodynamic algorithms for the computation of sea surface fluxes using TOGA COARE and TAO data. J. Clim., 11, pp. 2628-2644. Zhang, Y., Ye, F., Stanev, E.V., Grashorn, S. (2016). Seamless cross-scale modeling with SCHISM, Ocean Modelling, 102, 64-81. doi:10.1016/j.ocemod.2016.05.002","title":"Air-sea exchange"},{"location":"schism/spherical-coordinates.html","text":"We used the approach of Comblen et al. (2009) and transform the coordinates instead of the equations. Since the unstructured grids work naturally on a sphere, the polar singularity is avoided. Most of the work is done inside local frames. There are 2 frames used (Figure 1 ); note that all frames rotate with the earth. Coordinate frames on a sphere. Global frame \\((x_g, y_g, z_g)\\) (Figure 1 ). The origin is located at center of the earth (assumed to be a sphere) of radius \\(R_0\\) , \\(x_g\\) axis pointing to prime meridian, \\(z_g\\) to the north pole. The coordinates are related to the longitude and latitude of a point on the spherical surface as: \\[\\begin{equation} \\label{eq01} \\begin{cases} x_g = R_0 \\cos\\phi\\cos\\lambda\\\\ y_g = R_o \\cos\\phi\\sin\\lambda\\\\ z_g = R_0 \\sin\\phi \\end{cases} \\end{equation}\\] Local frame , located at a point on sphere (e.g., node/side center/element centroid): The 3 axes of this frame are: \\(\\pmb\\lambda^0\\) (zonal), \\(\\pmb\\phi^0\\) (meridional North), and \\(\\pmb r^0 = \\pmb\\lambda^0 \\times \\pmb\\phi^0\\) (radial). The relationship between this frame and global frame is: \\[\\begin{equation} \\label{eq02} \\begin{aligned} \\pmb\\lambda^0 = -\\sin\\lambda\\pmb i + \\cos\\lambda\\pmb j\\\\ \\pmb\\phi^0 = -\\cos\\lambda\\sin\\phi\\pmb i - \\sin\\lambda\\sin\\phi j + \\cos \\phi \\pmb k \\end{aligned} \\end{equation}\\] The frame \\((\\pmb\\lambda^0, \\pmb\\phi^0, \\pmb r^0)\\) is then the local \\((x, y, z)\\) frame. Here, \\(\\pmb i, \\pmb j, \\pmb k\\) are unit vectors of the global frame. Strictly speaking this frame is undefined at the 2 poles, but we can still use it there as long as the axes are unique. Further assumption is made that when the origins are close to each other, the z-axes also coincide with each other, e.g. in the back-tracking part etc. This is reasonable as the relevant distances are much smaller than \\(R_0\\) . With the aid from all these frames, the equations can be solved in a very similar way as in Cartesian frame. The main difference is in the evaluation of the vectors in the local frame. The changes to the code are therefore minimal. Below are some important info about arrays used in the code that are affected by lon/lat frames: (xnd,ynd,znd) , (xcj,ycj,zcj) , (xctr,yctr,zctr) are global coordinates of node, side center and element centroid for ics=1 or 2 . If ics=1 (Cartesian), znd=zcj=zctr= 0 ; (znl, zs, ze) are local z-coordinates measured vertically upward from the undisturbed surface (i.e. local frame when ics=2 ), at node, side, and element; eframe(1:3,1:3,1:nea) is the tensor for the element frame (w.r.t. global frame). The 2nd index indicates axid id (1=x; 2=y; 3=z) and the 1st index indicates tensor components. sframe and pframe are similar. References Comblen, R., Legrand, S., Deleersnijder, E., and Legat, V. (2009) A finite element method for solving the shallow water equations on the sphere. Ocean Mod., 28, 12-23.","title":"Spherical coordinates"},{"location":"schism/transport-equation.html","text":"SCHISM supports a few FV solvers for the transport equation. All of the tracers, including T,S, sediment (if invoked) etc are solved simultaneously for efficiency. The transport equation for a generic tracer C is given by: \\[\\begin{equation} \\label{eq01} \\frac{\\partial C}{\\partial t} + \\nabla \\cdot (\\pmb{u}C) = \\frac{\\partial}{\\partial z} \\left( \\kappa \\frac{\\partial C}{\\partial z} \\right) + F_h \\end{equation}\\] where \\(F_h\\) includes vertical settling term (see Vertical movement ), source/sink and also horizontal viscosity terms. The vertical B.C. is: \\[\\begin{equation} \\label{eq02} \\begin{aligned} \\kappa\\frac{\\partial C}{\\partial z} &= \\hat{C}, z = \\eta\\\\ \\kappa\\frac{\\partial C}{\\partial z} &= \\hat{C}_b, z = -h \\end{aligned} \\end{equation}\\] Note that the 3D continuity equation ensures the constancy condition for the transport equation, i.e. \\(C=\\text{const}\\) initially will remain so in the absence of sinks/source. In the following, we describe the numerical algorithm starting from the simplest 1st-order upwind scheme to the more complex 3rd-order WENO. In the newer versions, the pure upwind and explicit TVD schemes have been deprecated. Upwind \u00b6 Since most of the variables below are defined at prism center, we will use shorthand like \\(i\\) etc to denote a prism at level \\(k + 1/2\\) when there is no confusion. Also we often omit the superscript \\(n\\) in the explicit terms for brevity. A FV discretization of Eq. \\(\\ref{eq01}\\) for prism \\(i\\) is : \\[\\begin{equation} \\label{eq03} C_i^{m+1} = C_i^m - \\frac{\\Delta t'}{V_i}\\sum_{j\\in S} Q_j C_{j*} + (F_h)_i^n \\Delta t' + \\frac{A_i \\Delta t'}{V_i} \\left[ \\kappa_{i, k} \\frac{C_{i, k+1}^{m+1} - C_{i,k}^{m+1}}{\\Delta z_{i, k+\\frac{1}{2}}} - \\kappa_{i, k-1} \\frac{C_{i,k}^{m+1} - C_{i,k-1}^{m+1}}{\\Delta z_{i, k-\\frac{1}{2}}} \\right], (k = kbe + 1, \\cdots, N_z) \\end{equation}\\] where \\(\\Delta t' \\neq \\Delta t\\) is the transport time step (subject to Courant condition below), \\(V_i\\) is the volume of the prism, \\(C_i\\) s a shorthand for \\(C_{i, k}\\) (i.e., concentration at prism \\((i,k)\\) ), and \\(Q_j\\) is the flux at face \\(j\\) outward of the prism. Note that we have treated the diffusion term implicitly. For the sake of brevity we\u2019ll drop the source and diffusion terms from now on and focus on the advection term. With the upwind scheme, the face concentration is defined as: \\[\\begin{equation} \\label{eq04} C_{j*} = \\begin{cases} C_i, j \\in S^+\\\\ C_j, j \\in S^- \\end{cases} \\equiv C_{up} \\end{equation}\\] where we have used shorthand for concentration at prism \\(j\\) (i.e. the prism adjacent to \\((i,k)\\) from face j), and \\(S^+\\) and \\(S^-\\) are outflow and inflow faces respectively. The face concentration take different forms with higher-order schemes. Mass conservation Eq. \\(\\ref{eq03}\\) is the starting point of all FV solvers in SCHISM, from which a conservation statement can be derived. Assuming no zero fluxes at surface, bottom and lateral boundary, summing up over all prisms leads to: \\[\\begin{equation*} \\sum_i V_i C_i^{m+1} = \\sum_i V_i C_i^m - \\Delta t' \\sum_{j\\in FS} Q_j C_j \\end{equation*}\\] where \\(FS\\) stands for free surface. Note that the volume \\(V_i\\) is evaluated at previous step \\(m\\) . The 2nd term in Eq. \\(\\ref{eq03}\\) cancels out at all faces (or vanish at lateral boundary) except at the free surface. The 2nd term in above equation represents the contribution from the surface movement and is supposed to account for the movement from \\(m\\) to \\(m+1\\) . However, this balance is not precise (time truncation error). In the case of \\(TVD^2\\) or \\(WENO\\) ( itr_met>2 ), there is also additional splitting error. Therefore mass conservation is only good up to time truncation error. Retaining only the advection term, Eq. \\(\\ref{eq03}\\) then becomes: \\[\\begin{equation} \\label{eq05} C_i^{m+1} = C_i \\left( 1 - \\frac{\\Delta t'}{V_i} \\sum_{j\\in S^+} \\left| Q_j \\right| \\right) + \\frac{\\Delta t'}{V_i}\\sum_{j\\in S^+} \\left| Q_j \\right| C_j \\end{equation}\\] We have utilized the volume conservation: \\[\\begin{equation} \\label{eq06} \\sum_{j\\in S^+} \\left| Q_j \\right| = \\sum_{j\\in S^-} \\left| Q_j \\right| \\end{equation}\\] Therefore the Courant condition is: \\[\\begin{equation} \\label{eq07} 1 - \\frac{\\Delta t'}{V_i} \\sum_{j\\in S^+} \\left| Q_j \\right| \\geq 0 \\end{equation}\\] SCHISM uses this eq. to dynamically adjust the time step for transport for each step. Moreover, to improve efficiency, the vertical flux terms in Eq. \\(\\ref{eq05}\\) are treated implicitly, and the corresponding terms are then removed in the Courant condition - Eq. \\(\\ref{eq07}\\) . This is allowable because upwind is a linear method. TVD (explicit) \u00b6 The only difference between TVD and upwind schemes lies in the evaluation of the interfacial concentration: \\[\\begin{equation} \\label{eq08} C_{j*} = C_{up} + \\frac{\\varphi_j}{2}\\left( C_{jD} - C_{up} \\right) \\end{equation}\\] where \\(C_{up}\\) is given in Eq. \\(\\ref{eq04}\\) , \\(C_{jD}\\) is the downstream concentration, and \\(0 \\leq \\varphi_j \\leq 2\\) is a limiter function. TVD scheme nominally approaches 2nd order accuracy due to the anti-diffusion term. After some algebraic manipulation, the final eq. for TVD is: \\[\\begin{equation} \\label{eq09} C_i^{m+1} = C_i + \\frac{\\Delta t'}{V_i} \\sum_{j\\in S^-} \\left| Q_j \\right| (C_j - C_i) + \\frac{\\Delta t'}{V_i} \\sum_{j\\in S} \\left| Q_j \\right| \\frac{\\varphi_j}{2} (C_i - C_j) + \\text{source} + \\text{diffusion} \\end{equation}\\] and the Courant condition is: \\[\\begin{equation} \\label{eq10} \\Delta t' \\leq \\frac{V_i}{\\sum_{j\\in S^-}\\left| Q_j \\right| \\left( 1-\\frac{\\varphi_j}{2} + \\delta_i\\right)} \\end{equation}\\] where: \\[\\begin{equation} \\label{eq11} \\delta_i = \\sum_{p\\in S^+} \\frac{\\varphi(r_p)}{2r_p} \\end{equation}\\] and the upwind ratio, which involves upwind of upwind neighboring prism, is given by: \\[\\begin{equation} \\label{eq12} r_p = \\frac{\\sum_{m\\in S^-} \\left| Q_m \\right| (C_m - C_i)}{\\left| Q_p \\right| (C_i - C_p)}, p \\in S^+ \\end{equation}\\] In Eqs. \\(\\ref{eq09}\\) and \\(\\ref{eq10}\\) , the faces \\(S\\) , \\(S^+\\) , and \\(S^-\\) need to exclude the locations where upwind is applied: all horizontal and vertical boundaries, and interfaces between wetting and drying. In those places, \\(\\varphi_j = \\delta_i = 0\\) . Again SCHISM automatically calculates the time step according to the Courant condition (Eq. \\(\\ref{eq10}\\) ); the sub-time step used is the minimum of all prisms. The choices for the limiter function include: MINMOD , OSHER , van Leer , Super Bee etc. Since TVD scheme here is a nonlinear method, we cannot treat the vertical fluxes implicitly, and so all fluxes have to be treated explicitly. TVD method is therefore more expensive than upwind. A more efficient \\(TVD^2\\) using a fractional time step method should be used. \\(TVD^2\\) \u00b6 The TVD scheme shown above is explicit in 3D space and thus subject to the Courant condition, which comprises of horizontal and vertical fluxes across each of the prism faces ( Casulli and Zanolli 2005 ). The restriction related to the vertical fluxes is especially severe due to smaller grid size used in the vertical dimension, and therefore a large number of sub-cycles within each time step are usually required. To partially mitigate the issue, a hybrid upwind-TVD approach can be used in which the more efficient upwind scheme, with an implicit treatment of the vertical fluxes, is used when the flow depth falls below a given threshold (with the assumption that stratification is usually much smaller in the shallows). However, this approach does not work in deeper depths of eddying regime, as large vertical velocities are not uncommon along steep bathymetric slopes. Together with the fact that a large number of vertical levels are usually required in the eddying regime, the explicit scheme leads to subpar computational performance and usually takes over 90% of the total CPU time. We therefore develop an implicit TVD scheme in the vertical dimension in SCHISM. We start from the FVM formulation of the 3D transport equation at a prism \\(i\\) : \\[\\begin{equation} \\label{eq13} C_i^{n+1} = C_i^n - \\frac{\\Delta t}{V_i} \\sum_{j\\in S^-} \\left| Q_j \\right| (C_i - C_j) - \\frac{\\Delta t}{V_i} \\sum_{j\\in S} Q_j C_{jr} + \\frac{A_i \\Delta t}{V_i} \\left[ \\left(\\kappa \\frac{\\partial C}{\\partial z} \\right)_{i,k} - \\left(\\kappa \\frac{\\partial C}{\\partial z} \\right)_{i, k-1} \\right] + \\frac{\\Delta t}{V_i} \\int_{V_i} F_h dV \\end{equation}\\] where \\(C_j\\) is the concentration at the neighboring prism of \\(i\\) across a prism face \\(j\\in S = S^+ \\cup S^-\\) , with \\(S^+/S^-\\) denoting outflow/inflow faces (which can be horizontal or vertical) respectively, \\(V_i\\) is the prism volume, \\(A_i\\) is the area of the associated surficial element, and \\(Q_j\\) is the flux at a face. In Eq. \\(\\ref{eq13}\\) we have utilized the volume conservation in a prism (which is enforced by the solution of the vertical velocity): \\(\\sum_{j\\in S^-}\\left| Q_j \\right| = \\sum_{j\\in S^+} \\left| Q_j \\right|\\) . We have also approximated the concentration at a face as the sum of an upwind and a correction part as: \\[\\begin{equation} \\label{eq14} C\\Biggr|_j = C_{jup} + C_{jr} \\end{equation}\\] Note that in the 2nd term of RHS of Eq. \\(\\ref{eq13}\\) , we have \\(C_j = C_{jup}\\) as \\(j\\) is an inflow face. In addition, we have intentionally left out the time level in some terms in Eq. \\(\\ref{eq13}\\) as they will be treated explicitly or implicitly in the following. We split the solution of Eq. \\(\\ref{eq13}\\) into 3 sub-steps: \\[\\begin{equation} \\label{eq15} C_i^{m+1} = C_i^n + \\frac{\\Delta t_m}{V_i} \\sum_{j\\in S_H^-} \\left| Q_j \\right| (C_j^m - C_i^m) - \\frac{\\Delta t_m}{V_i} \\sum_{j\\in S_H} Q_j \\hat\\psi_j^m, (m = 1, \\cdots, M) \\end{equation}\\] \\[\\begin{equation} \\label{eq16} \\widetilde C_i = C_i^{M+1} + \\frac{\\Delta t}{V_i} \\sum_{j\\in S_V^-} \\left| Q_j \\right| (\\widetilde C_j - \\widetilde C_i) - \\frac{\\Delta t}{V_i} \\sum_{j\\in S_V} Q_j (\\Phi_j + \\Psi_j), (j = kbe+1, \\cdots, N_z) \\end{equation}\\] \\[\\begin{equation} \\label{eq17} C_i^{n+1} = \\widetilde C_i + \\frac{A_i \\Delta t}{V_i} \\left[ \\left( \\kappa \\frac{\\partial C}{\\partial z} \\right)_{i,k}^{n+1} - \\left( \\kappa \\frac{\\partial C}{\\partial z} \\right)_{i, k-1}^{n+1} \\right] + \\frac{\\Delta t}{V_i} \\int_{V_i} F_h^n dV, (k = kbe+1, \\cdots, N_z) \\end{equation}\\] The 1st step solves the horizontal advection part (for all 3D prisms \\(i\\) ), the 2nd step deals with the vertical advection part (where \\(k_b\\) is the bottom level index and \\(N_z\\) is the surface level index), and the last step tackles the remaining terms. We could have combined the 1st and 3rd steps into a single step at the expense of efficiency, because sub-cycling is used in the 1st step. In Eq. \\(\\ref{eq15}\\) , sub-cylcing in \\(M\\) sub-steps is required because of the horizontal Courant number condition, \\(\\Delta t_m\\) is the sub-time step used, and \\(\\hat\\psi_j^m\\) is a standard TVD limiter function. Eq. \\(\\ref{eq15}\\) is then solved with a standard TVD method. The last step (Eq. \\(\\ref{eq17}\\) ) requires the solution of a simple tri-diagonal matrix. So we will only focus on the 2nd step. Following Duraisamy and Baeder (2007, hereafter DB07) , we use two limiter functions in Eq. \\(\\ref{eq16}\\) : \\(\\Phi_j\\) is the space limiter and \\(\\Psi_j\\) is the time limiter - thus the name \\(TVD^2\\) . The origin of these two limiters is the approximation Eq. \\(\\ref{eq14}\\) via a Taylor expansion in both space and time ( DB07 ): \\[\\begin{equation} \\label{eq18} \\begin{aligned} C_j^{n+\\frac{1}{2}} &= C_{jup}^{n+1} + \\Phi_j + \\Psi_j\\\\ &= C_{jup}^{n+1} + \\pmb{r}\\cdot\\Bigr[ \\nabla C \\Bigr]_{jup}^{n+1} - \\frac{\\Delta t}{2} \\Bigr[ \\frac{\\partial C}{\\partial t} \\Bigr]_{jup}^{n+1} \\end{aligned} \\end{equation}\\] Note that the interface value is taken at time level \\(n+\\frac{1}{2}\\) to gain 2nd-order accuracy in time. The vector \\(\\pmb{r}\\) points from prism center \\(jup\\) to face center \\(j\\) . Due to the operator splitting method, \\(C^{n+1}\\) now actually corresponds to \\(\\widetilde{C}\\) . Customary in a TVD method, we then replace the last 2 terms with limiter functions: \\[\\begin{equation} \\label{eq19} C_j^{n+\\frac{1}{2}} = \\widetilde C_{jup} + \\frac{\\phi_j}{2} (\\widetilde C_{jD} - \\widetilde C_{jup}) - \\frac{\\psi_j}{2} (\\widetilde C_{jup} - C_{jup}^{M+1}) \\end{equation}\\] and so: \\[\\begin{equation} \\label{eq20} \\begin{aligned} \\Phi_j = \\frac{\\phi_j}{2} (\\widetilde C_{jD} - \\widetilde C_{jup})\\\\ \\Psi_j = \\frac{\\psi_j}{2} (\\widetilde C_{jup} - C_{jup}^{M+1}) \\end{aligned} \\end{equation}\\] where \u2018jD\u2019 stands for the downwind prism of \\(i\\) along the face \\(j\\) , and \\(\\phi_j\\) and \\(\\psi_j\\) are 2 limiter functions in space and time respectively. Note that \\(\\phi_j = \\psi_j = 1\\) leads to 2nd-order accuracy in both space and time. Substituting Eq. \\(\\ref{eq20}\\) in to Eq. \\(\\ref{eq16}\\) and after some algebra we obtain a nonlinear equation for the unknown concentration: \\[\\begin{equation} \\label{eq21} \\widetilde C_i + \\frac{\\frac{\\Delta t}{V_i} \\sum_{j\\in S_V^-} \\left| Q_j \\right| \\left[ 1 + \\frac{1}{2} \\left( \\sum_{p\\in S_V^+} \\frac{\\phi_p}{r_p} - \\phi_j \\right) \\right] (\\widetilde C_i - \\widetilde C_j)}{1 + \\frac{\\Delta t}{2V_i} \\sum_{j\\in S_V^+} \\left| Q_j \\right| \\left( \\sum_{q\\in S_V^-} \\frac{\\psi_q}{s_q} - \\psi_j \\right)} = C_i^{M+1} \\end{equation}\\] where \\(r_p\\) and \\(s_q\\) are upwind and downwind ratios respectively: \\[\\begin{equation} \\label{eq22} \\begin{aligned} r_p &= \\frac{\\sum_{q\\in S_V^-}\\left| Q_q \\right| (\\widetilde C_q - \\widetilde C_i)}{\\left| Q_p \\right| (\\widetilde C_i - \\widetilde C_p)}, p \\in S_V^+\\\\ s_q &= \\frac{(\\widetilde C_i - C_i^{M+1}) \\sum_{p\\in S_V^+} \\left| Q_p \\right|}{\\left| Q_p \\right| (\\widetilde C_q - C_q^{M+1})}, q\\in S_V^- \\end{aligned} \\end{equation}\\] DB07 showed that a sufficient TVD condition for Eq. \\(\\ref{eq21}\\) is that the coefficient of the 2nd LHS term be non-negative, i.e.: \\[\\begin{equation} \\label{eq23} 1 + \\frac{1}{2}\\left(\\sum_{p\\in S_V^+} \\frac{\\phi_p}{r_p} - \\phi_j \\right) \\geq 0 \\end{equation}\\] \\[\\begin{equation} \\label{eq24} 1 + \\frac{\\Delta t}{2V_i} \\sum_{j\\in S_V^+} \\left| Q_j \\right| \\left( \\sum_{q\\in S_V^-} \\frac{\\psi_q}{s_q} - \\psi_j \\right) \\geq \\delta \\gt 0 \\end{equation}\\] where \\(\\delta\\) is a small positive number. Eq. \\(\\ref{eq23}\\) can be satisfied with any choice of standard limiter functions in space, and Eq. \\(\\ref{eq24}\\) must be solved together with Eq. \\(\\ref{eq21}\\) iteratively, because \\(\\psi\\) and \\(s_q\\) are functions of \\(\\widetilde C\\) . We need to discuss 3 scenarios for prism \\(i\\) : Scenario 1. vertically convergent flow: in this case, the outer sum in Eq. \\(\\ref{eq24}\\) is 0, so the inequality is always true; Scenario 2. divergent flow: the numerator of the 2nd LHS term in Eq. \\(\\ref{eq21}\\) is 0, and so \\(\\widetilde C_i = C_i^{M+1}\\) ; Scenario 3. uni-directional flow (either upward or downward): in this case, prism \\(i\\) has exactly 1 inflow and 1 outflow face vertically, so a sufficient condition for Eq. \\(\\ref{eq24}\\) is: \\[\\begin{equation} \\label{eq25} 1 - \\frac{\\Delta t}{2 V_i} \\left| Q_j \\right| \\psi_j \\geq \\delta \\gt 0, j\\in S_V^+ \\end{equation}\\] Therefore we choose the following form for the limiter: \\[\\begin{equation} \\label{eq26} \\psi_j = \\text{max}\\left[0, \\text{min}\\left[1, \\frac{2(1-\\delta)V_i}{\\left| Q_j \\right|\\Delta t} \\right] \\right], j\\in S_V^+ \\end{equation}\\] where we have imposed a maximum of 1 in an attempt to obtain 2nd-order accuracy in time. Note that the limiter is a function of the vertical Courant number: it decreases as the Courant number increases. Eqs. \\(\\ref{eq21}\\) and \\(\\ref{eq26}\\) are then solved using a simple Picard iteration method starting from \\(\\psi = 0\\) everywhere, and fast convergence within a few iterations is usually observed. Simple benchmark tests indicate that \\(TVD^2\\) is accurate for a wide range of Courant numbers as found in typical geophysical flows. It works equally well in eddying and non-eddying regimes, from very shallow to very deep depths, and is thus ideal for cross-scale applications. You are encouraged to use this option as much as possible. Third-order WENO scheme \u00b6 This option starts from the same Eqs ( \\(\\ref{eq15}\\) - \\(\\ref{eq17}\\) ), but solves Eq. ( \\(\\ref{eq15}\\) ) using a third-order WENO scheme. Essentially we use a higher-order reconstruction method to approximate the numerical flux and the details can be found in Ye et al. (2019) . Hybridization with Eulerian-Lagrangian Method \u00b6 The FV schemes described above all have explicit component (in the horizontal dimension) that is subject to stability constraint (Courant condition). This constraint can become severe, e.g. with high mesh resolution in the shallows in watershed applications. To alleviate this constaint, SCHISM allows local hybridization between any of the FV schemes and the Eulerian-Lagrangian Method (ELM). Like the ELM scheme used for momentum advection, the ELM scheme for the transport advection is unconditionally stable and monotone (if a linear interpolation is used at the foot of the characteristic line). The only downside of the ELM is that it does not conserve mass in Eulerian sense (but it does in Lagrangian sense), and therefore should be used sparingly, i.e., only to locally speed up the transport solver. The user can invoke this scheme by setting ielm_transport=1 and prescribing a maximum allowed number of sub-sucyclings per time step max_subcyc . To limit the use of ELM only for extreme cases, it's important to set a proper max_subcyc . A rule of thumb is that a sub time step (for the explicit FV sovler) should be around 10 sec, so max_subcyc should be dt/10 . Another issue with this hybridized scheme is that the combination of WENO and ELM in shallows can sometimes lead to large numerical dispersion; see Known issues for details. A simple solution for this issue is to make the affected regions upwind via tvd.prop . Vertical movement \u00b6 Many tracers have \u2018behaviors\u2019 in the form of vertical migration (upward or downward) in the water column. This is modeled with a \u2018settling\u2019 term: \\[\\begin{equation} \\label{eq27} \\frac{\\partial C}{\\partial t} + \\nabla \\cdot (\\pmb{u}C) = \\frac{\\partial}{\\partial z} \\left( \\kappa \\frac{\\partial C}{\\partial z} \\right) + \\frac{\\partial (w_s C)}{\\partial z} \\end{equation}\\] where \\(w_s\\) is the settling velocity ( positive downward ). This term is treated implicitly to avoid stability issues; in particular, it\u2019s solved in the 3rd step together with the diffusion term in Eq. \\(\\ref{eq17}\\) . The benefit of this approach is that often the settling term balances the diffusion at boundary (e.g., sediment). Horizontal B.C. for transport \u00b6 In either upwind or TVD schemes, the concentration at the neighboring prism \\(T_j\\) at the open boundary is known. For outflow, \\(T_j=T_i\\) and the signal is advected out of the domain without hindrance. For incoming flow, \\(T_j\\) is specified by the B.C. (either in bctides.in or *.th ), and SCHISM nudges to this value with a relaxation constant (specified in bctides.in ), in order to prevent sharp gradient there. For a complete list of horizontal B.C. supported by SCHISM, see bctides.in . References Casulli, V. and P. Zanolli (2005) High resolution methods for multidimensional advection\u2013diffusion problems in free-surface hydrodynamics. Ocean Modelling, 10, pp.137-151. Duraisamy, K. and J.D. Baeder (2007), Implicit Scheme For Hyperbolic Conservation Laws Using Nonoscillatory Reconstruction In Space And Time, Siam J. Sci. Comput. 29(6), 2607\u20132620.","title":"Transport equation"},{"location":"schism/transport-equation.html#upwind","text":"Since most of the variables below are defined at prism center, we will use shorthand like \\(i\\) etc to denote a prism at level \\(k + 1/2\\) when there is no confusion. Also we often omit the superscript \\(n\\) in the explicit terms for brevity. A FV discretization of Eq. \\(\\ref{eq01}\\) for prism \\(i\\) is : \\[\\begin{equation} \\label{eq03} C_i^{m+1} = C_i^m - \\frac{\\Delta t'}{V_i}\\sum_{j\\in S} Q_j C_{j*} + (F_h)_i^n \\Delta t' + \\frac{A_i \\Delta t'}{V_i} \\left[ \\kappa_{i, k} \\frac{C_{i, k+1}^{m+1} - C_{i,k}^{m+1}}{\\Delta z_{i, k+\\frac{1}{2}}} - \\kappa_{i, k-1} \\frac{C_{i,k}^{m+1} - C_{i,k-1}^{m+1}}{\\Delta z_{i, k-\\frac{1}{2}}} \\right], (k = kbe + 1, \\cdots, N_z) \\end{equation}\\] where \\(\\Delta t' \\neq \\Delta t\\) is the transport time step (subject to Courant condition below), \\(V_i\\) is the volume of the prism, \\(C_i\\) s a shorthand for \\(C_{i, k}\\) (i.e., concentration at prism \\((i,k)\\) ), and \\(Q_j\\) is the flux at face \\(j\\) outward of the prism. Note that we have treated the diffusion term implicitly. For the sake of brevity we\u2019ll drop the source and diffusion terms from now on and focus on the advection term. With the upwind scheme, the face concentration is defined as: \\[\\begin{equation} \\label{eq04} C_{j*} = \\begin{cases} C_i, j \\in S^+\\\\ C_j, j \\in S^- \\end{cases} \\equiv C_{up} \\end{equation}\\] where we have used shorthand for concentration at prism \\(j\\) (i.e. the prism adjacent to \\((i,k)\\) from face j), and \\(S^+\\) and \\(S^-\\) are outflow and inflow faces respectively. The face concentration take different forms with higher-order schemes. Mass conservation Eq. \\(\\ref{eq03}\\) is the starting point of all FV solvers in SCHISM, from which a conservation statement can be derived. Assuming no zero fluxes at surface, bottom and lateral boundary, summing up over all prisms leads to: \\[\\begin{equation*} \\sum_i V_i C_i^{m+1} = \\sum_i V_i C_i^m - \\Delta t' \\sum_{j\\in FS} Q_j C_j \\end{equation*}\\] where \\(FS\\) stands for free surface. Note that the volume \\(V_i\\) is evaluated at previous step \\(m\\) . The 2nd term in Eq. \\(\\ref{eq03}\\) cancels out at all faces (or vanish at lateral boundary) except at the free surface. The 2nd term in above equation represents the contribution from the surface movement and is supposed to account for the movement from \\(m\\) to \\(m+1\\) . However, this balance is not precise (time truncation error). In the case of \\(TVD^2\\) or \\(WENO\\) ( itr_met>2 ), there is also additional splitting error. Therefore mass conservation is only good up to time truncation error. Retaining only the advection term, Eq. \\(\\ref{eq03}\\) then becomes: \\[\\begin{equation} \\label{eq05} C_i^{m+1} = C_i \\left( 1 - \\frac{\\Delta t'}{V_i} \\sum_{j\\in S^+} \\left| Q_j \\right| \\right) + \\frac{\\Delta t'}{V_i}\\sum_{j\\in S^+} \\left| Q_j \\right| C_j \\end{equation}\\] We have utilized the volume conservation: \\[\\begin{equation} \\label{eq06} \\sum_{j\\in S^+} \\left| Q_j \\right| = \\sum_{j\\in S^-} \\left| Q_j \\right| \\end{equation}\\] Therefore the Courant condition is: \\[\\begin{equation} \\label{eq07} 1 - \\frac{\\Delta t'}{V_i} \\sum_{j\\in S^+} \\left| Q_j \\right| \\geq 0 \\end{equation}\\] SCHISM uses this eq. to dynamically adjust the time step for transport for each step. Moreover, to improve efficiency, the vertical flux terms in Eq. \\(\\ref{eq05}\\) are treated implicitly, and the corresponding terms are then removed in the Courant condition - Eq. \\(\\ref{eq07}\\) . This is allowable because upwind is a linear method.","title":"Upwind"},{"location":"schism/transport-equation.html#tvd-explicit","text":"The only difference between TVD and upwind schemes lies in the evaluation of the interfacial concentration: \\[\\begin{equation} \\label{eq08} C_{j*} = C_{up} + \\frac{\\varphi_j}{2}\\left( C_{jD} - C_{up} \\right) \\end{equation}\\] where \\(C_{up}\\) is given in Eq. \\(\\ref{eq04}\\) , \\(C_{jD}\\) is the downstream concentration, and \\(0 \\leq \\varphi_j \\leq 2\\) is a limiter function. TVD scheme nominally approaches 2nd order accuracy due to the anti-diffusion term. After some algebraic manipulation, the final eq. for TVD is: \\[\\begin{equation} \\label{eq09} C_i^{m+1} = C_i + \\frac{\\Delta t'}{V_i} \\sum_{j\\in S^-} \\left| Q_j \\right| (C_j - C_i) + \\frac{\\Delta t'}{V_i} \\sum_{j\\in S} \\left| Q_j \\right| \\frac{\\varphi_j}{2} (C_i - C_j) + \\text{source} + \\text{diffusion} \\end{equation}\\] and the Courant condition is: \\[\\begin{equation} \\label{eq10} \\Delta t' \\leq \\frac{V_i}{\\sum_{j\\in S^-}\\left| Q_j \\right| \\left( 1-\\frac{\\varphi_j}{2} + \\delta_i\\right)} \\end{equation}\\] where: \\[\\begin{equation} \\label{eq11} \\delta_i = \\sum_{p\\in S^+} \\frac{\\varphi(r_p)}{2r_p} \\end{equation}\\] and the upwind ratio, which involves upwind of upwind neighboring prism, is given by: \\[\\begin{equation} \\label{eq12} r_p = \\frac{\\sum_{m\\in S^-} \\left| Q_m \\right| (C_m - C_i)}{\\left| Q_p \\right| (C_i - C_p)}, p \\in S^+ \\end{equation}\\] In Eqs. \\(\\ref{eq09}\\) and \\(\\ref{eq10}\\) , the faces \\(S\\) , \\(S^+\\) , and \\(S^-\\) need to exclude the locations where upwind is applied: all horizontal and vertical boundaries, and interfaces between wetting and drying. In those places, \\(\\varphi_j = \\delta_i = 0\\) . Again SCHISM automatically calculates the time step according to the Courant condition (Eq. \\(\\ref{eq10}\\) ); the sub-time step used is the minimum of all prisms. The choices for the limiter function include: MINMOD , OSHER , van Leer , Super Bee etc. Since TVD scheme here is a nonlinear method, we cannot treat the vertical fluxes implicitly, and so all fluxes have to be treated explicitly. TVD method is therefore more expensive than upwind. A more efficient \\(TVD^2\\) using a fractional time step method should be used.","title":"TVD (explicit)"},{"location":"schism/transport-equation.html#tvd2","text":"The TVD scheme shown above is explicit in 3D space and thus subject to the Courant condition, which comprises of horizontal and vertical fluxes across each of the prism faces ( Casulli and Zanolli 2005 ). The restriction related to the vertical fluxes is especially severe due to smaller grid size used in the vertical dimension, and therefore a large number of sub-cycles within each time step are usually required. To partially mitigate the issue, a hybrid upwind-TVD approach can be used in which the more efficient upwind scheme, with an implicit treatment of the vertical fluxes, is used when the flow depth falls below a given threshold (with the assumption that stratification is usually much smaller in the shallows). However, this approach does not work in deeper depths of eddying regime, as large vertical velocities are not uncommon along steep bathymetric slopes. Together with the fact that a large number of vertical levels are usually required in the eddying regime, the explicit scheme leads to subpar computational performance and usually takes over 90% of the total CPU time. We therefore develop an implicit TVD scheme in the vertical dimension in SCHISM. We start from the FVM formulation of the 3D transport equation at a prism \\(i\\) : \\[\\begin{equation} \\label{eq13} C_i^{n+1} = C_i^n - \\frac{\\Delta t}{V_i} \\sum_{j\\in S^-} \\left| Q_j \\right| (C_i - C_j) - \\frac{\\Delta t}{V_i} \\sum_{j\\in S} Q_j C_{jr} + \\frac{A_i \\Delta t}{V_i} \\left[ \\left(\\kappa \\frac{\\partial C}{\\partial z} \\right)_{i,k} - \\left(\\kappa \\frac{\\partial C}{\\partial z} \\right)_{i, k-1} \\right] + \\frac{\\Delta t}{V_i} \\int_{V_i} F_h dV \\end{equation}\\] where \\(C_j\\) is the concentration at the neighboring prism of \\(i\\) across a prism face \\(j\\in S = S^+ \\cup S^-\\) , with \\(S^+/S^-\\) denoting outflow/inflow faces (which can be horizontal or vertical) respectively, \\(V_i\\) is the prism volume, \\(A_i\\) is the area of the associated surficial element, and \\(Q_j\\) is the flux at a face. In Eq. \\(\\ref{eq13}\\) we have utilized the volume conservation in a prism (which is enforced by the solution of the vertical velocity): \\(\\sum_{j\\in S^-}\\left| Q_j \\right| = \\sum_{j\\in S^+} \\left| Q_j \\right|\\) . We have also approximated the concentration at a face as the sum of an upwind and a correction part as: \\[\\begin{equation} \\label{eq14} C\\Biggr|_j = C_{jup} + C_{jr} \\end{equation}\\] Note that in the 2nd term of RHS of Eq. \\(\\ref{eq13}\\) , we have \\(C_j = C_{jup}\\) as \\(j\\) is an inflow face. In addition, we have intentionally left out the time level in some terms in Eq. \\(\\ref{eq13}\\) as they will be treated explicitly or implicitly in the following. We split the solution of Eq. \\(\\ref{eq13}\\) into 3 sub-steps: \\[\\begin{equation} \\label{eq15} C_i^{m+1} = C_i^n + \\frac{\\Delta t_m}{V_i} \\sum_{j\\in S_H^-} \\left| Q_j \\right| (C_j^m - C_i^m) - \\frac{\\Delta t_m}{V_i} \\sum_{j\\in S_H} Q_j \\hat\\psi_j^m, (m = 1, \\cdots, M) \\end{equation}\\] \\[\\begin{equation} \\label{eq16} \\widetilde C_i = C_i^{M+1} + \\frac{\\Delta t}{V_i} \\sum_{j\\in S_V^-} \\left| Q_j \\right| (\\widetilde C_j - \\widetilde C_i) - \\frac{\\Delta t}{V_i} \\sum_{j\\in S_V} Q_j (\\Phi_j + \\Psi_j), (j = kbe+1, \\cdots, N_z) \\end{equation}\\] \\[\\begin{equation} \\label{eq17} C_i^{n+1} = \\widetilde C_i + \\frac{A_i \\Delta t}{V_i} \\left[ \\left( \\kappa \\frac{\\partial C}{\\partial z} \\right)_{i,k}^{n+1} - \\left( \\kappa \\frac{\\partial C}{\\partial z} \\right)_{i, k-1}^{n+1} \\right] + \\frac{\\Delta t}{V_i} \\int_{V_i} F_h^n dV, (k = kbe+1, \\cdots, N_z) \\end{equation}\\] The 1st step solves the horizontal advection part (for all 3D prisms \\(i\\) ), the 2nd step deals with the vertical advection part (where \\(k_b\\) is the bottom level index and \\(N_z\\) is the surface level index), and the last step tackles the remaining terms. We could have combined the 1st and 3rd steps into a single step at the expense of efficiency, because sub-cycling is used in the 1st step. In Eq. \\(\\ref{eq15}\\) , sub-cylcing in \\(M\\) sub-steps is required because of the horizontal Courant number condition, \\(\\Delta t_m\\) is the sub-time step used, and \\(\\hat\\psi_j^m\\) is a standard TVD limiter function. Eq. \\(\\ref{eq15}\\) is then solved with a standard TVD method. The last step (Eq. \\(\\ref{eq17}\\) ) requires the solution of a simple tri-diagonal matrix. So we will only focus on the 2nd step. Following Duraisamy and Baeder (2007, hereafter DB07) , we use two limiter functions in Eq. \\(\\ref{eq16}\\) : \\(\\Phi_j\\) is the space limiter and \\(\\Psi_j\\) is the time limiter - thus the name \\(TVD^2\\) . The origin of these two limiters is the approximation Eq. \\(\\ref{eq14}\\) via a Taylor expansion in both space and time ( DB07 ): \\[\\begin{equation} \\label{eq18} \\begin{aligned} C_j^{n+\\frac{1}{2}} &= C_{jup}^{n+1} + \\Phi_j + \\Psi_j\\\\ &= C_{jup}^{n+1} + \\pmb{r}\\cdot\\Bigr[ \\nabla C \\Bigr]_{jup}^{n+1} - \\frac{\\Delta t}{2} \\Bigr[ \\frac{\\partial C}{\\partial t} \\Bigr]_{jup}^{n+1} \\end{aligned} \\end{equation}\\] Note that the interface value is taken at time level \\(n+\\frac{1}{2}\\) to gain 2nd-order accuracy in time. The vector \\(\\pmb{r}\\) points from prism center \\(jup\\) to face center \\(j\\) . Due to the operator splitting method, \\(C^{n+1}\\) now actually corresponds to \\(\\widetilde{C}\\) . Customary in a TVD method, we then replace the last 2 terms with limiter functions: \\[\\begin{equation} \\label{eq19} C_j^{n+\\frac{1}{2}} = \\widetilde C_{jup} + \\frac{\\phi_j}{2} (\\widetilde C_{jD} - \\widetilde C_{jup}) - \\frac{\\psi_j}{2} (\\widetilde C_{jup} - C_{jup}^{M+1}) \\end{equation}\\] and so: \\[\\begin{equation} \\label{eq20} \\begin{aligned} \\Phi_j = \\frac{\\phi_j}{2} (\\widetilde C_{jD} - \\widetilde C_{jup})\\\\ \\Psi_j = \\frac{\\psi_j}{2} (\\widetilde C_{jup} - C_{jup}^{M+1}) \\end{aligned} \\end{equation}\\] where \u2018jD\u2019 stands for the downwind prism of \\(i\\) along the face \\(j\\) , and \\(\\phi_j\\) and \\(\\psi_j\\) are 2 limiter functions in space and time respectively. Note that \\(\\phi_j = \\psi_j = 1\\) leads to 2nd-order accuracy in both space and time. Substituting Eq. \\(\\ref{eq20}\\) in to Eq. \\(\\ref{eq16}\\) and after some algebra we obtain a nonlinear equation for the unknown concentration: \\[\\begin{equation} \\label{eq21} \\widetilde C_i + \\frac{\\frac{\\Delta t}{V_i} \\sum_{j\\in S_V^-} \\left| Q_j \\right| \\left[ 1 + \\frac{1}{2} \\left( \\sum_{p\\in S_V^+} \\frac{\\phi_p}{r_p} - \\phi_j \\right) \\right] (\\widetilde C_i - \\widetilde C_j)}{1 + \\frac{\\Delta t}{2V_i} \\sum_{j\\in S_V^+} \\left| Q_j \\right| \\left( \\sum_{q\\in S_V^-} \\frac{\\psi_q}{s_q} - \\psi_j \\right)} = C_i^{M+1} \\end{equation}\\] where \\(r_p\\) and \\(s_q\\) are upwind and downwind ratios respectively: \\[\\begin{equation} \\label{eq22} \\begin{aligned} r_p &= \\frac{\\sum_{q\\in S_V^-}\\left| Q_q \\right| (\\widetilde C_q - \\widetilde C_i)}{\\left| Q_p \\right| (\\widetilde C_i - \\widetilde C_p)}, p \\in S_V^+\\\\ s_q &= \\frac{(\\widetilde C_i - C_i^{M+1}) \\sum_{p\\in S_V^+} \\left| Q_p \\right|}{\\left| Q_p \\right| (\\widetilde C_q - C_q^{M+1})}, q\\in S_V^- \\end{aligned} \\end{equation}\\] DB07 showed that a sufficient TVD condition for Eq. \\(\\ref{eq21}\\) is that the coefficient of the 2nd LHS term be non-negative, i.e.: \\[\\begin{equation} \\label{eq23} 1 + \\frac{1}{2}\\left(\\sum_{p\\in S_V^+} \\frac{\\phi_p}{r_p} - \\phi_j \\right) \\geq 0 \\end{equation}\\] \\[\\begin{equation} \\label{eq24} 1 + \\frac{\\Delta t}{2V_i} \\sum_{j\\in S_V^+} \\left| Q_j \\right| \\left( \\sum_{q\\in S_V^-} \\frac{\\psi_q}{s_q} - \\psi_j \\right) \\geq \\delta \\gt 0 \\end{equation}\\] where \\(\\delta\\) is a small positive number. Eq. \\(\\ref{eq23}\\) can be satisfied with any choice of standard limiter functions in space, and Eq. \\(\\ref{eq24}\\) must be solved together with Eq. \\(\\ref{eq21}\\) iteratively, because \\(\\psi\\) and \\(s_q\\) are functions of \\(\\widetilde C\\) . We need to discuss 3 scenarios for prism \\(i\\) : Scenario 1. vertically convergent flow: in this case, the outer sum in Eq. \\(\\ref{eq24}\\) is 0, so the inequality is always true; Scenario 2. divergent flow: the numerator of the 2nd LHS term in Eq. \\(\\ref{eq21}\\) is 0, and so \\(\\widetilde C_i = C_i^{M+1}\\) ; Scenario 3. uni-directional flow (either upward or downward): in this case, prism \\(i\\) has exactly 1 inflow and 1 outflow face vertically, so a sufficient condition for Eq. \\(\\ref{eq24}\\) is: \\[\\begin{equation} \\label{eq25} 1 - \\frac{\\Delta t}{2 V_i} \\left| Q_j \\right| \\psi_j \\geq \\delta \\gt 0, j\\in S_V^+ \\end{equation}\\] Therefore we choose the following form for the limiter: \\[\\begin{equation} \\label{eq26} \\psi_j = \\text{max}\\left[0, \\text{min}\\left[1, \\frac{2(1-\\delta)V_i}{\\left| Q_j \\right|\\Delta t} \\right] \\right], j\\in S_V^+ \\end{equation}\\] where we have imposed a maximum of 1 in an attempt to obtain 2nd-order accuracy in time. Note that the limiter is a function of the vertical Courant number: it decreases as the Courant number increases. Eqs. \\(\\ref{eq21}\\) and \\(\\ref{eq26}\\) are then solved using a simple Picard iteration method starting from \\(\\psi = 0\\) everywhere, and fast convergence within a few iterations is usually observed. Simple benchmark tests indicate that \\(TVD^2\\) is accurate for a wide range of Courant numbers as found in typical geophysical flows. It works equally well in eddying and non-eddying regimes, from very shallow to very deep depths, and is thus ideal for cross-scale applications. You are encouraged to use this option as much as possible.","title":"\\(TVD^2\\)"},{"location":"schism/transport-equation.html#third-order-weno-scheme","text":"This option starts from the same Eqs ( \\(\\ref{eq15}\\) - \\(\\ref{eq17}\\) ), but solves Eq. ( \\(\\ref{eq15}\\) ) using a third-order WENO scheme. Essentially we use a higher-order reconstruction method to approximate the numerical flux and the details can be found in Ye et al. (2019) .","title":"Third-order WENO scheme"},{"location":"schism/transport-equation.html#hybridization-with-eulerian-lagrangian-method","text":"The FV schemes described above all have explicit component (in the horizontal dimension) that is subject to stability constraint (Courant condition). This constraint can become severe, e.g. with high mesh resolution in the shallows in watershed applications. To alleviate this constaint, SCHISM allows local hybridization between any of the FV schemes and the Eulerian-Lagrangian Method (ELM). Like the ELM scheme used for momentum advection, the ELM scheme for the transport advection is unconditionally stable and monotone (if a linear interpolation is used at the foot of the characteristic line). The only downside of the ELM is that it does not conserve mass in Eulerian sense (but it does in Lagrangian sense), and therefore should be used sparingly, i.e., only to locally speed up the transport solver. The user can invoke this scheme by setting ielm_transport=1 and prescribing a maximum allowed number of sub-sucyclings per time step max_subcyc . To limit the use of ELM only for extreme cases, it's important to set a proper max_subcyc . A rule of thumb is that a sub time step (for the explicit FV sovler) should be around 10 sec, so max_subcyc should be dt/10 . Another issue with this hybridized scheme is that the combination of WENO and ELM in shallows can sometimes lead to large numerical dispersion; see Known issues for details. A simple solution for this issue is to make the affected regions upwind via tvd.prop .","title":"Hybridization with Eulerian-Lagrangian Method"},{"location":"schism/transport-equation.html#vertical-movement","text":"Many tracers have \u2018behaviors\u2019 in the form of vertical migration (upward or downward) in the water column. This is modeled with a \u2018settling\u2019 term: \\[\\begin{equation} \\label{eq27} \\frac{\\partial C}{\\partial t} + \\nabla \\cdot (\\pmb{u}C) = \\frac{\\partial}{\\partial z} \\left( \\kappa \\frac{\\partial C}{\\partial z} \\right) + \\frac{\\partial (w_s C)}{\\partial z} \\end{equation}\\] where \\(w_s\\) is the settling velocity ( positive downward ). This term is treated implicitly to avoid stability issues; in particular, it\u2019s solved in the 3rd step together with the diffusion term in Eq. \\(\\ref{eq17}\\) . The benefit of this approach is that often the settling term balances the diffusion at boundary (e.g., sediment).","title":"Vertical movement"},{"location":"schism/transport-equation.html#horizontal-bc-for-transport","text":"In either upwind or TVD schemes, the concentration at the neighboring prism \\(T_j\\) at the open boundary is known. For outflow, \\(T_j=T_i\\) and the signal is advected out of the domain without hindrance. For incoming flow, \\(T_j\\) is specified by the B.C. (either in bctides.in or *.th ), and SCHISM nudges to this value with a relaxation constant (specified in bctides.in ), in order to prevent sharp gradient there. For a complete list of horizontal B.C. supported by SCHISM, see bctides.in . References Casulli, V. and P. Zanolli (2005) High resolution methods for multidimensional advection\u2013diffusion problems in free-surface hydrodynamics. Ocean Modelling, 10, pp.137-151. Duraisamy, K. and J.D. Baeder (2007), Implicit Scheme For Hyperbolic Conservation Laws Using Nonoscillatory Reconstruction In Space And Time, Siam J. Sci. Comput. 29(6), 2607\u20132620.","title":"Horizontal B.C. for transport"},{"location":"schism/turbulence-closure.html","text":"Umlauf and Burchard \u2019s Generic Length Scale (GLS) model is \\[\\begin{equation} \\label{eq01} \\begin{aligned} \\frac{DK}{Dt} &= \\frac{\\partial}{\\partial z} ( \\nu_k^\\psi \\frac{\\partial K}{\\partial z} ) + \\nu M^2 + \\mu N^2 - \\varepsilon\\\\ \\frac{D\\psi}{Dt} &= \\frac{\\partial}{\\partial z} ( \\nu_\\psi \\frac{\\partial \\psi}{\\partial z} ) + \\frac{\\psi}{K} ( c_{\\psi 1} \\nu M^2 + c_{\\psi 3} \\mu N^2 - c_{\\psi 2} F_w \\varepsilon) \\end{aligned} \\end{equation}\\] with natural B.C. \\[\\begin{equation} \\label{eq02} \\begin{cases} \\nu_k^\\psi \\frac{\\partial K}{\\partial z} = 0, z = -h \\text{ or } \\eta\\\\ \\nu_\\psi \\frac{\\partial\\psi}{\\partial z} = \\kappa_0 n \\nu_\\psi \\frac{\\psi}{l}, z = -h\\\\ \\nu_\\psi \\frac{\\partial\\psi}{\\partial z} = -\\kappa_0 n \\nu_\\psi \\frac{\\psi}{l}, z = \\eta \\end{cases} \\end{equation}\\] and essential B.C.: \\[\\begin{equation} \\label{eq03} \\begin{cases} K = ( c_\\mu^0 )^{-2} \\nu \\left| \\frac{\\partial u}{\\partial z} \\right|\\\\ l = \\kappa_0\\Delta, \\text{ at } z = -h \\text{ or } \\eta\\\\ \\psi = ( c_\\mu^0 )^p K^m ( \\kappa_0 \\Delta )^n \\end{cases} \\end{equation}\\] where \\(K\\) is the TKE, \\(l\\) is the mixing length, \\(c_{\\psi *}\\) are constants, \\(\\psi = ( c_\\mu^0 )^p K^m l^n\\) is a generic length-scale variable, and \\(\\Delta\\) is the distance to the boundary (surface or bottom). The turbulence production and dissipation terms are: \\[\\begin{equation} \\label{eq04} M^2 = (\\frac{\\partial u}{\\partial z})^2 + (\\frac{\\partial v}{\\partial z})^2 \\end{equation}\\] \\[\\begin{equation} \\label{eq05} N^2 = \\frac{g}{\\rho_0}\\frac{\\partial \\rho}{\\partial z} \\end{equation}\\] \\[\\begin{equation} \\label{eq06} \\varepsilon = (c_\\mu^0)^3 K^{1.5} l^{-1} \\end{equation}\\] In the code, the natural B.C. is applied first (see the FEM formulation below), and the essential B.C. is then used to overwrite the boundary values of the unknown, as suggested by GOTM. We also follow some other models and neglect the advection terms here. In the FEM formulation, \\(K\\) , \\(\\psi\\) are defined at nodes and whole levels. Furthermore, the sums of \\(M^2\\) and \\(N^2\\) are treated explicitly/implicitly depending on the sign. The final equations look similar to those for the momentum equation: \\[\\begin{equation} \\label{eq07} \\begin{aligned} &\\mathcal{H} (N_z -m) \\left[ \\frac{\\Delta z_{m+1}}{6} (2K_m^{n+1} + K_{m+1}^{n+1} - 2K_m^n - K_{m+1}^n) - \\Delta t (\\nu_k^\\psi)_{m+\\frac{1}{2}}^n \\frac{K_{m+1}^{n+1} - K_m^{n+1}}{\\Delta z_{m+1}} \\right]\\\\ &+ \\mathcal{H}(m-kbp) \\left[ \\frac{\\Delta z_m}{6} (2K_m^{n+1} + K_{m-1}^{n+1} - 2K_m^n - K_{m-1}^n) - \\Delta t (\\nu_k^\\psi)_{m-\\frac{1}{2}}^n \\frac{K_m^{n+1} - K_{m-1}^{n+1}}{\\Delta z_m} \\right]\\\\ &= \\mathcal{H} (N_z - m) \\Delta t \\left[ \\begin{Bmatrix} \\frac{\\Delta z_m + 1}{2} (\\nu_t M^2 + \\nu_t^\\theta N^2)_{m+\\frac{1}{2}}^{n}\\\\ \\frac{\\Delta z_{m+1}}{2} (\\nu_t M^2 + \\nu_t^\\theta N^2)_{m+\\frac{1}{2}}^{n} \\frac{2K_m^{n+1} + K_{m+1}^{n+1}}{K_{m+\\frac{1}{2}}^{n}} \\end{Bmatrix} - (c_\\mu^0)^3 (K^{0.5} l^{-1})_{m+\\frac{1}{2}}^{n} \\frac{\\Delta z_{m+1}}{6} (2K_m^{n+1} + K_{m+1}^{n+1}) \\right]\\\\ &+ \\mathcal{H}(m-kbp)\\Delta t \\left[ \\begin{Bmatrix} \\frac{\\Delta z_m}{2} (\\nu_t M^2 + \\nu_t^\\theta N^2)_{m-\\frac{1}{2}}^{n}\\\\ \\frac{\\Delta z_m}{2} (\\nu_t M^2 + \\nu_t^\\theta N^2)_{m-\\frac{1}{2}}^{n} \\frac{2K_m^{n+1} + K_{m-1}^{n+1}}{K_{m-\\frac{1}{2}}^{n}}\\end{Bmatrix} - (c_\\mu^0)^3 (K^{0.5}l^{-1})_{m-\\frac{1}{2}}^{n} \\frac{\\Delta z_m}{6} (2K_m^{n+1} + K_{m-1}^{n+1}) \\right] , (l = kbp, \\cdots, N_z) \\end{aligned} \\end{equation}\\] \\[\\begin{equation} \\label{eq08} \\begin{aligned} &\\mathcal{H}(N_z - m) \\left[ \\frac{\\Delta z_{m+1}}{6} (2\\psi^{n+1}_{m} + \\psi_{m+1}^{n+1} - 2\\psi_m^n - \\psi_{m+1}^{n}) - \\Delta t (\\nu_\\psi)_{m+\\frac{1}{2}}^{n} \\frac{\\psi_{m+1}^{n+1} - \\psi_{m}^{n+1}}{\\Delta z_{m+1}} \\right]\\\\ &+ \\mathcal{H}(m-kbp) \\left[ \\frac{\\Delta z_{m+1}}{6} (2\\psi_m^{n+1} + \\psi_{m-1}^{n+1} -2\\psi_m^n - \\psi_{m-1}^n) - \\Delta t (\\nu_\\psi)_{m-\\frac{1}{2}}^n \\frac{\\psi_m^{n+1} - \\psi_{m-1}^{n+1}}{\\Delta z_m} \\right]\\\\ &+ \\kappa_0 n \\Delta t \\left[ \\delta_{m, N_z} \\left(\\frac{\\nu_\\psi}{l}\\right)_{N_z}^n \\psi_{N_z}^{n+1} + \\delta_{m, kbp} \\left( \\frac{\\nu_\\psi}{l} \\right)_{kbp}^n \\psi_{kbp}^{n+1} \\right]\\\\ &= \\mathcal{H}(N_z - m) \\Delta t \\left[ \\begin{Bmatrix} \\frac{\\Delta z_{m+1}}{2} (c_{\\psi 1} \\nu_t M^2 + c_{\\psi 3} \\nu_t^\\theta N^2)_{m+\\frac{1}{2}}^{n} \\left(\\frac{\\psi}{K}\\right)_{m+\\frac{1}{2}}^{n} \\\\ \\frac{\\Delta z_{m+1}}{2} \\left( \\nu_t M^2 + \\nu_t^\\theta N^2 \\right)_{m+\\frac{1}{2}}^n \\frac{2\\psi_m^{n+1} + \\psi_{m+1}^{n+1}}{2K_{m+\\frac{1}{2}}^n} \\end{Bmatrix} - c_{\\psi 2} \\left( c_\\mu^0 \\right)^3 \\left(K^{0.5}l^{-1}F_w\\right)_{m+\\frac{1}{2}}^{n} \\frac{\\Delta z_{m+1}}{6} \\left( 2\\psi_m^{n+1} + \\psi_{m+1}^{n+1} \\right) \\right] \\\\ &+\\mathcal{H}(m-kbp) \\Delta t \\left[ \\begin{Bmatrix} \\frac{\\Delta z_m}{2} \\left( c_{\\psi 1} \\nu_t M^2 + c_{\\psi 3} \\nu_t^\\theta N^2 \\right)_{m-\\frac{1}{2}}^{n} \\left( \\frac{\\psi}{K} \\right)_{m-\\frac{1}{2}}^{n}\\\\ \\frac{\\Delta z_m}{2} \\left( \\nu_t M^2 + \\nu_t^\\theta N^2 \\right)_{m-\\frac{1}{2}}^{n} \\frac{2\\psi_{m}^{n+1} + \\psi_{m-1}^{n+1}}{2K_{m-\\frac{1}{2}}^{n}} \\end{Bmatrix} - (c_\\mu^0)^3 \\left(K^{0.5}l^{-1}F_w\\right)_{m-\\frac{1}{2}}^{n} \\frac{\\Delta z_m}{6} \\left( 2\\psi_{m}^{n+1} + \\psi_{m-1}^{n+1} \\right) \\right], (l = kbp, \\cdots, N_z) \\end{aligned} \\end{equation}\\] where \\(\\begin{Bmatrix}\\end{Bmatrix}\\) indicates the alternative explicit/implicit schemes mentioned above, and \\(\\mathcal{H}\\) is a step function. We have applied the natural B.C. (Eqs. \\(\\ref{eq02}\\) ) in these equations, and after \\(K\\) and \\(\\psi\\) are solved, the essential B.C. (Eqs \\(\\ref{eq03}\\) ) is then used to overwrite the boundary values. References Umlauf, L. and H. Burchard (2003) A generic length-scale equation for geophysical turbulence models. J. Mar. Res., 6, pp. 235-265.","title":"Turbulence closure"},{"location":"schism/updating-levels.html","text":"After all variables are solved at the new step, the vertical grid is updated to reflect the newly solved elevations. An important aspect of this update is the treatment of inundation (wetting/drying). SCHISM supports 2 options for inundation. Note that the elevations are solved at all nodes including dry nodes at the previous time step; in other words, the elevations at the dry nodes \u2013 they are simply below the local bottom and can be thought as inactive ground water. The 1st option ( inunfl=0 ) is the default one that should be used in most applications. It uses a simple book-keeping algorithm to mark node/side/element as wet/dry based on a threshold depth ( h0 ). SCHISM does not support partial wetting and drying, and so the rule inside the code is: an element is wet if all of its nodes and sides are wet, and is dry if any of its nodes or sides becomes dry. A node/side is wet iff (if and only if) at least 1 of its surrounding element is wet. For newly rewetted element/node/side, some state variables may be re-initialized based wet neighbors. The 2nd option ( inunfl=1 ) uses a shoreline tracking algorithm which requires finer resolution to be effective; otherwise the extrapolation procedure below may over-predict the inundation. In realistic cases, <5m resolution is usually sufficient for this purpose. Starting from the shoreline position at step \\(n\\) , each node on this line is checked for wetting and drying, and the local portion of the line is updated accordingly (Figure 1 ). The process is iterative and multi-layer wetting and drying is possible. After the new shoreline position is found at step \\(n+1\\) ,a constant extrapolation of surface elevation is used from this position projected onto the nearest \u2018dry\u2019 node, in order to enhance the stability of the wetting and drying front (a technique advocated by the tsunami MOST model). Shoreline tracking algorithm. (a) The orange line is the shoreline from step n, and the light blue line is the updated portion since A is wetted and B becomes dry at step n+1. (b) At the end of the tracking, constant extrapolation of elevation is used at the new shoreline position, which may flood the next dry node.","title":"Updating the levels/Inundation"},{"location":"schism/vertical-velocity.html","text":"The vertical velocity serves as a diagnostic variable for local volume conservation 1 , but is a physically important quantity, especially when a steep slope is present ( Zhang et al. 2004 ). To solve the vertical velocity, we apply a finite-volume method to a typical prism, as depicted in Figure 6 , assuming that \\(w\\) is constant within an element \\(i\\) , and obtain - \\[\\begin{equation} \\label{eq01} \\hat{S}_{k+1} \\left( \\overline{u}_{k+1}^{n+1} n_{k+1}^{x} + \\overline{v}_{k+1}^{n+1} n_{k+1}^{y} + w_{i, k+1}^{n+1} n_{k+1}^{z} \\right) - \\hat{S}_{k} \\left( \\overline{u}_{k}^{n+1} n_{k}^{x} + \\overline{v}_{k}^{n+1} n_{k}^{y} + w_{i, k}^{n+1} n_{k}^{z} \\right) + \\sum_{m=1}^{3} \\hat{P}_{js(i, m)} \\left( \\hat{q}_{js(i, m), k}^{n+1} + \\hat{q}_{js(i, m), k+1}^{n+1} \\right)/2 = 0, (k=k^b, \\cdots, N_z - 1) \\end{equation}\\] where \\(\\hat{S}\\) and \\(\\hat{P}\\) are the areas of the prism surfaces (Figure 6 ), ( \\(n^x, n^y, n^z\\) ), are the normal vector (pointing upward), \\(\\overline{u}\\) and \\(\\overline{v}\\) the averaged horizontal velocities at the top and bottom surfaces, and \\(\\hat{q}\\) is the outward normal velocity at each side center. The vertical velocity is then solved from the bottom to the surface, in conjunction with the bottom boundary condition \\((u, v, q)\\cdot\\pmb{n}=0\\) . In the case of earthquake module ( imm\u22600 ), the bed velocity is prescribed. A compact form for Eqs \\(\\ref{eq01}\\) is \\(\\sum_{j\\epsilon S^+} \\left| Q_j\\right| = \\sum_{j\\epsilon S^-} \\left| Q_j\\right|\\) , where \\(Q_j\\) is the facial fluxes outward of a prism \\(i\\) . This conservation will be utilized in the transport equation as the foundation for mass conservation and constancy. References Zhang, Y., Baptista, A.M. and Myers, E.P. (2004) \"A cross-scale model for 3D baroclinic circulation in estuary-plume-shelf systems: I. Formulation and skill assessment\". Cont. Shelf Res., 24: 2187-2214. Although other definitions of volume/mass exist, we define volume/mass in the finite-volume sense throughout this paper and measure conservation based on this definition. \u21a9","title":"Vertical velocity"}]}
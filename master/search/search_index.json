{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Semi-implicit Cross-scale Hydroscience Integrated System Model (SCHISM)","text":"<p>SCHISM modeling system is a derivative work from the original SELFE model (v3.1dc as of Dec. 13 , 2014). SCHISM has been implemented by Dr. Joseph Zhang (College of William &amp; Mary) and other developers around the world, and licensed under Apache. SELFE was developed at the Oregon Health Sciences University. However, there are now significant differences between the two models.</p> <p>SCHISM (Semi-implicit Cross-scale Hydroscience Integrated System Model) is an open-source community-supported modeling system based on unstructured grids, designed for seamless simulation of 3D baroclinic circulation across creek-lake-river-estuary-shelf-ocean scales. It uses a highly efficient and accurate semi-implicit finite-element/finite-volume method with Eulerian-Lagrangian algorithm to solve the Navier-Stokes equations (in hydrostatic form), in order to addresses a wide range of physical and biological processes. The numerical algorithm judiciously mixes higher-order with lower-order methods, to obtain stable and accurate results in an efficient way. Mass conservation is enforced with the finite-volume transport algorithm. It also naturally incorporates wetting and drying of tidal flats.</p> <p></p> SCHISM modelling framework. <p>The SCHISM system has been extensively tested against standard ocean/coastal benchmarks and applied to a number of regional seas/bays/estuaries around the world (see 'Case study') in the context of general circulation, tsunami and storm-surge inundation, water quality, oil spill, sediment transport, coastal ecology, and wave-current interaction. SCHISM now includes many upgrades of the original SELFE code (v3.1dc); the major differences are summarized in Zhang et al. (Seamless cross-scale modeling with SCHISM, Ocean Modelling, 2016; see Publications).</p> <p>The source code and user manual can be downloaded from this web site. The plot above (Figure 1) shows a snapshot of various modules inside SCHISM.</p>"},{"location":"index.html#major-characteristics-of-schism","title":"Major Characteristics of SCHISM","text":"<ul> <li>Finite element/volume formulation</li> <li>Unstructured mixed triangular/quadrangular grid in the horizontal dimension</li> <li>Hybrid SZ coordinates or new \\(LSC^2\\) in the vertical dimension</li> <li>Polymorphism: a single grid can mimic 1D/2DV/2DH/3D configurations</li> <li>Semi-implicit time stepping (no mode splitting): no CFL stability constraints \u2192 numerical efficiency</li> <li>Robust matrix solver</li> <li>Higher-order Eulerian-Lagrangian treatment of momentum advection (with ELAD filter)</li> <li>Natural treatment of wetting and drying suitable for inundation studies</li> <li>Mass conservative, monotone, higher-order transport solver: TVD2; WENO</li> <li>No bathymetry smoothing necessary</li> <li>Very tolerant of bad-quality meshes in the non-eddying regime</li> </ul>"},{"location":"index.html#modeling-system-application-areas","title":"Modeling system &amp; application areas","text":"<ul> <li>3D baroclinic cross-scale lake-river-estuary-plume-shelf-ocean circulations</li> <li>Tsunami hazards</li> <li>Storm surge</li> <li>Sediment transport</li> <li>Biogeochemistry/ecology/water quality</li> <li>Oil spill</li> <li>Short wave-current interaction</li> </ul>"},{"location":"index.html#citation","title":"Citation","text":"<p>We suggest the following language for citing the model:</p> <p>SCHISM (Semi-implicit Cross-scale Hydroscience Integrated System Model) is a derivative product built from the original SELFE (v3.1dc; Zhang and Baptista 2008) and distributed with an open-source Apache v2 license, with many enhancements and upgrades including new extension to large-scale eddying regime and a seamless cross-scale capability from creek to ocean (Zhang et al. 2016).</p> <ul> <li>Zhang, Y. and Baptista, A.M. (2008) SELFE: A semi-implicit Eulerian-Lagrangian finite-element model for cross-scale ocean circulation\", Ocean Modelling, 21(3-4), 71-96.</li> <li>Zhang, Y., Ye, F., Stanev, E.V., Grashorn, S. (2016) Seamless cross-scale modeling with SCHISM, Ocean Modelling, 102, 64-81.</li> </ul>"},{"location":"case-study.html","title":"Case studies","text":""},{"location":"case-study.html#hydrologic-flow","title":"Hydrologic flow","text":"<p>Simulation of hydrologic flow in watershed, with bottom elevation above sea level (thus strong wetting and drying) and with complex river channel network, is challenging. The discussions below are taken from a training course on compound flooding simulation.</p> <p>A common, convenient method for introducing river flows into watershed in SCHISM mesh is via the point source/sinks as shown in Figure 8. Together with proper parameter choices (e.g., a small minimum depth of 10-5m, a fully implicit scheme, a large bottom friction with proper vertical grid to allow for 2D representation in the watershed etc) this usually works fine for smaller rivers. For large rivers, the open-boundary approach (i.e., river channels as open boundary segments) is the preferred method. In general, the point source approach injects flow via the continuity equation alone without providing extra momentum (note that the volume sources/sinks are added to the RHS of Eqs. 2 and 3 but not in the momentum Eqs. 1, and thus it will take the system some time to adjust internally to set up the flow from the pressure gradient. Because of this drawback, large elevations may be found near the injection points, especially during initial ramp up or during high and rapidly varying flow periods. This symptom can be exacerbated by the following missteps:</p> <ol> <li>Pairs of source and sink in close proximity (Figure 9a). Users should combine these pairs;</li> <li>Steep slopes near boundary with coarse resolution (Figure 9b); </li> <li>Inverted bed slopes near the injection location (so the flow has to overcome gravity; Figure 9c);</li> <li>Poorly ventilated \u2018dead-end\u2019 (Figure 9d);</li> <li>Undulating channel (\u2018water fall\u2019; Figure 9e).</li> </ol> <p>The model is stable, but interpretation of results may be problematic in those cases. Besides more grid work in those spots, using open-boundary segments can help. Also one should really exclude transient responses during ramp-up period in computing the maximum elevation to allow the system time to adjust. Also don\u2019t forget that sometimes the rainfall (which can also be introduced as sources) on high mountains should result in high surface elevations there, which are realistic.</p> <p>To get accurate results in the hydrologic regime, it is also important to resolve channels to avoid blocking flows. Semi-automatic mesh generation  tools have been developed specifically for this purpose; see this chapter.</p> <p></p> Coupling of hydrologic model (National Water Model in this case) with SCHISM. The river network (lines) intersects SCHISM land boundary, and the river flow is introduced at the intersection points (sources for inflow and sinks for outflow). <p></p> Pathologic cases for hydrologic flows."},{"location":"case-study.html#tsunami-simulations","title":"Tsunami simulations","text":"<p>Your can diwnload a sample tsunami run (impact of Alaska tsunami waves on Cannon Beach, OR) at http://www.ccrm.vims.edu/yinglong/wiki_files/tsunami_ex15.tgz</p> <p>Note that the files are compatible with the serial version of SCHISM, but the idea for parallel version is similar.</p> <p>The operational time step for tsunami applications is generally in the range of a few seconds because of the constraint from shorter wavelength  and inundation processes. You'll need higher mesh resolution also to satisfy the inverse CFL criterion (<code>CFL&gt;0.2</code>).   The inundation results may also be sensitive to the min. depth used in the run (1cm in this example).  If you use the newer parallel version, you can also use a 2D model with a proper Manning coefficient.</p> <p>Typically you need to follow these 2 steps in tsunami simulations:</p> <ol> <li>Deformation run (EX15/Def/ in the sample run): this simulates the earthquake and the set-up of the initial surface waves. For this you need: <pre><code>  a) `bdef.gr3` (refer to the user manual) which specifies the total seafloor deformation.\n  b) turn on the hotstart output handle, and `dt=1s, ibdef=10, rnday=1.158e-4`\n  c) We typically run this stage for 10 sec duration and at the end of the run you'll find an output files called `10_hotstart` which is then used as hotstart.in for the next (propagation and inundation) stage.\n  d) In addition, use `mod_depth.f` (inside the bundle), which takes info in `bdef.gr3` and `hgrid.gr3` (pre-earthquake depths) to generate hgrid.new (post-earthquake depths). The latter is used in the next stage. For completeness you need to attach the boundary condition part (`b.tmp` in the bundle) of `hgrid.gr3` to the end of `hgrid.new`;\n</code></pre></li> <li>Propagation and inundation stage (EX15/ in the sample run): this run continues from the deformation run above with no further seafloor movement. You'll notice that many input files are identical to the Def/ run, but be careful of differences in hgrid.gr3 (linked to Def/hgrid.new) and param.in (imm=0 etc). <pre><code>  a) For this run we also turn off the advection in the open ocean (up to say 60m isobath) because it's negligible there (`adv.gr3`) -  this bypasses the inverse CFL criterion and allows you to use a coarser resolution in deeper ocean.\n  b) Also note that `hotstart.in` is from the previous stage. \n</code></pre></li> <li>After the run is done you can look at global outputs (elevation, depth-averaged velocity etc). The maximum elevation (<code>maxelev.gr3</code>) and depth-averaged velocity (<code>maxdahv.gr3</code>) are also part of the outputs (for parallel versions, use <code>/src/Utility/Combining_Scripts/combine_gr3.f90</code>). The maximum inundation can be easily computed from <code>maxelev.gr3</code>.</li> </ol>"},{"location":"changelog.html","title":"Changelog","text":"<p>Up to date information on bug fixes/major algorithmic changes, as well as changes in input/output formats can be found in source bundle: src/Readme.beta_notes.</p> <p>In particular, errors when hopping among versions can be fixed by referring to src/Readme.beta_notes.   E.g, new mandatory (CORE) parameters in <code>param.nml</code> are found by searching for 'mandatory' in this file. Obsolete optional parameters  are found by searching for 'removed'. You do not need to worry about newly introduced  optional parameters as the model  will set default for you.</p>"},{"location":"code-contribution.html","title":"Code structure","text":"<p>The information presented in this chapter is mostly intended for developers or anyone who wishes to work on the code. To know more about how to contribute your code see CONTRIBUTING.md on SCHISM github repo. </p>"},{"location":"code-contribution.html#general-info","title":"General info","text":"<p>SCHISM was written in MPI FORTRAN 90. After svn revision 5225, we have migrated to github. Figure 1 shows the directory structure of the SCHISM github repository schism. General public have access to all branches.</p> <p></p> SCHISM github repository. <p>Figure 2 shows its main work flow and major code blocks. Two files inside <code>src/</code> (<code>Hydro/schism_init.F90</code> and <code>Hydro/schism_step.F90</code>) represent bulk of the hydro code, and are driven by a master program (<code>Driver/schism_driver.F90</code>). The global variables are defined in <code>Core/schism_glbl.F90</code>, and the message passing routines are defined in <code>Core/schism_msgp.F90</code>.</p> <p></p> SCHISM code work flow. The percentages are estimates from a test case with an earlier version and may not be up to date. <p>The domain decomposition is done using ParMETIS graph partitioning library (included in the <code>src/</code>). Figure 3 shows an example of sub-domains generated by this lib.</p> <p></p> Domain decomposition. Each color represents a sub-domain (\u2018resident domain\u2019) taken by a MPI process and the thick black polygon represents the \u2018augmented\u2019 (=resident+ghost) domain of process 6. <p>The Utility dir has a lot of useful utility scripts for pre- and post-processing. The header of each program generally has info on its purpose and instructions on how to use it.</p> <ul> <li><code>ACE</code>: source code and install notes for ACE tools; the manual can be found on Forum.</li> <li><code>Combining_Scripts</code>: FORTRAN and perl scripts used to gather outputs from SCHISM (e.g., <code>outputs/schout_0*_[stack number].nc</code> etc) into one binary file (<code>schout_[stack_number].nc</code>).</li> <li><code>Grid_Scripts</code>: FORTRAN codes to interpolate depths from DEM files in either structured grid (raster) or unstructured grid format. While ACE/xmgredit5 can do similar things, these scripts are mostly for interpolating from very large DEM files.</li> <li><code>Gen_Hotstart</code>: scripts for preparing <code>hotstart.nc</code> from e.g., netcdf outputs from a structured-grid model.</li> <li><code>Pre-Processing</code>: various scripts for pre-processing (checking, viz etc)</li> <li><code>OneWayNestScripts</code>: scripts for 1-way nesting, by preparing <code>*[23]D.th.nc</code> (elevation, horizontal velocity, salinity and temperature boundary condition) that can be used for the 'small-domain' run.</li> <li><code>Particle_Tracking</code>: particle tracking code that uses SCHISM's outputs for 3D tracking.</li> <li><code>Post-Processing-Fortran</code>: FORTRAN codes for extracting time series at selected 3D points (including transects). You can modify these codes for your own purposes.</li> <li><code>Sflux_nc</code>: matlab scripts useful for preparing your own .nc files for <code>sflux/</code>. <code>NARR_util/</code> has scripts to prepare .nc files from NCEP's NARR products.</li> <li><code>SMS</code>: scripts to convert between <code>.2dm</code> of SMS and <code>.gr3</code>.</li> <li><code>Vis_Matlab</code>: matlab scripts for viz. At the moment, these scripts have not been updated to handle \\(LSC^2\\) grid.</li> </ul>"},{"location":"code-contribution.html#domain-partitioning","title":"Domain partitioning","text":"<p>The domain is first portioned into non-overlapping sub-domains (in element sense; see Figure 3) using ParMETIS. Then each sub-domain is augmented with 1 layer of ghost elements. This is accomplished by the call <code>partition_hgrid()</code> early in the main program. After calling <code>aquire_hgrid(.true.)</code> immediately after that, the elements, nodes, sides in each augmented and non-augmented (i.e., without ghosts) domains are shown in Figure 3. The corresponding variable denoting number of Elements, Nodes, and Sides are given in the following table. Intuition is typically followed although there are exceptions as will be described below.</p> Global Local non-augmented Ghost Augmented Elements <code>ne_global</code> <code>ne</code> <code>neg</code> <code>nea=ne+neg</code> Nodes <code>np_global</code> <code>np</code> <code>npg</code> <code>npa=np+npg</code> Sides <code>ns_global</code> <code>ns</code> <code>nsg</code> <code>nsa=ns+nsg</code> <p>The call to ParMETIS routine is as follows - </p> <pre><code>call ParMETIS_V3_PartGeomKway(vtxdist,xadj,adjncy,vwgt,adjwgt,wgtflag, &amp;\n    numflag,ndims,xyz,ncon,nproc,tpwgts,ubvec,options, &amp;\n    edgecut,part,comm)\n</code></pre> <ul> <li><code>p</code> : # of processors;</li> <li><code>n</code> : total # of vertices (local) in graph sense;</li> <li><code>m</code> : total # of neighboring vertices (\"edges\"); double counted between neighboring vertice u and v.</li> <li><code>ncon</code>: # of weights for each vertex.</li> <li><code>int(in) vtxdist(p+1)</code> : Processor <code>j</code> stores vertices <code>vtxdist(j):vtxdist(j+1)-1</code></li> <li><code>int (in) xadj(n+1), adjncy(m)</code> : locally, vertex <code>j</code>'s neighboring vertices are <code>adjncy(xadj(j):xadj(j+1)-1)</code>. adjncy points to global index;</li> <li><code>int(in) vwgt(ncon*n), adjwgt(m)</code> : weights at vertices and \"edges\". Format of adjwgt follows adjncy;</li> <li><code>int(in) wgtflag</code> : <ul> <li><code>0</code>: none (<code>vwgt</code> and <code>adjwgt</code> are NULL); </li> <li><code>1</code>: edges (<code>vwgt</code> is <code>NULL</code>); </li> <li><code>2</code>:vertices (<code>adjwgt</code> is <code>NULL</code>); </li> <li><code>3</code>: both vertices &amp; edges;</li> </ul> </li> <li><code>int(in) numflag</code> : <ul> <li><code>0</code>: C-style numbering from 0; </li> <li><code>1</code>: FORTRAN style from 1;</li> </ul> </li> <li><code>int(in) ndims</code>: 2 or 3 (D);</li> <li><code>float(in) xyz(ndims*n)</code> : coordinate for vertex <code>j</code> is <code>xyz(j*ndims:(j+1)*ndims-1)</code> (C style); <code>ndims*(j-1)+1: ndims*j</code> (FORTRAN style);</li> <li><code>int(in) nparts</code>: # of desired sub-domains (usually <code>nproc</code>);</li> <li><code>float(in) tpwgts(ncon*nparts)</code> : <code>=1/nparts</code> if sub-domains are to be of same size for each vertex weight;</li> <li><code>float(in) ubvec(ncon)</code> : imbalance tolerance for each weight;</li> <li><code>int(in) options</code> : additonal parameters for the routine (see above);</li> <li><code>int(out) edgecut</code> : # of edges that are cut by the partitioning;</li> <li><code>int(out) part()</code> : array size = # of local vertices. It stores indices of local vertices.</li> </ul>"},{"location":"code-contribution.html#arrays-and-constant","title":"Arrays and constant","text":"<ol> <li><code>llist_type :: iegl(iegb)</code> : <code>iegb</code> is a global element #. If the element is resident (not ghost), <code>iegl(iegb)%rank=myrank</code>, and <code>iegl(iegb)%id = local element index</code>, and <code>iegl%next=null</code>. If <code>iegb</code> is a ghost, then <code>iegl</code> list has two entries: <code>myrank</code> and the rank where <code>iegb</code> is resident. All processors have this info, but the lists are different (1st entry is usually myrank etc).</li> <li><code>llist_type :: ipgl(ipgb)</code> : <code>ipgb</code> is a global node #. Use this list only when the node is resident (not ghost); it\u2019s confusing when <code>ipgb</code> is ghost. If <code>ipgb</code> is resident, <code>ipgl(ipgb)%rank=myrank</code>, and <code>ipgl(ipgb)%id = local node index</code>. <code>ipgl%next%next%next....</code> is the linked list, with ranks in ascending order. Unless <code>ipgb</code> is an interface node (i.e., resident in more than 1 process), the list has only 1 entry. All processors have this info, but the lists are different (1st entry is usually myrank etc).</li> <li><code>llist_type :: isgl(isgb)</code> : <code>isgb</code> is a global side #. Similar to <code>ipgl</code>, if the side is resident (not ghost), <code>isgl(isgb)%rank=myrank</code>, and <code>isgl(isgb)%id = local side index</code>. <code>isgl%next%next...</code> is the list, with ranks in ascending order. All processors have this info, but the lists are different (1st entry is usually myrank etc).</li> <li><code>int :: ielg(ie), iplg(ip), islg(isd)</code> : The global element index of local element ie in the augmented domain. Similar for the other two (nodes/sides).</li> <li><code>int :: iegrpv(iegb)</code> : The rank # for global element <code>iegb</code> (before augmenting the domain). Used mainly in partitioning the grid.</li> <li>Arrays that have similar meaning between global and local aug. domains, i.e., they do not have problem of getting outside the aug. domain: <code>i34</code>, <code>elnode</code> (old name: <code>nm</code>), <code>elside</code> (<code>js</code>), <code>ssign</code>, <code>snx</code>, <code>sny</code>.</li> <li>Arrays that need special attention in the aug. domain - <ul> <li><code>int :: ic3(1:i34(), ie)</code> \u2013 <code>positive</code> if the neighbor element is inside the aug. domain as well (and in this case it is the local index of the neighbor element); <code>0</code> if (global) boundary; <code>negative</code> if the neighbor element is outside the aug. domain and in this case, the absolute value is the global element index.</li> <li><code>int :: nne(ip)</code> \u2013 total # of neighbor elements around local node <code>ip</code>, including those outside the aug. domain (i.e., same as <code>nnegb()</code>).</li> <li><code>int :: indel(1: nne(ip),ip)</code> \u2013 surrounding element indices. If inside aug. domain, this is the local element index; if outside, this is the negative of the global element index.</li> <li><code>int :: iself(1: nne(ip),ip)</code> \u2013 same as global <code>iselfgb</code>, i.e., the elemental local index for node <code>ip</code> in neighbor element <code>indel()</code> (even if it is outside).</li> <li><code>int :: nnp(ip)</code> \u2013 total # of surrounding nodes for node <code>ip</code>, excluding all nodes outside the aug. domain. For SCHISM, include all nodes outside.</li> <li><code>int :: indnd(1: nnp(ip),ip)</code> \u2013 list of surrounding nodes, excluding all nodes outside the aug. domain. For SCHISM, all nodes outside will have negative global index returned.</li> <li><code>int :: isdel(1:2,isd)</code> &amp; <code>isidenode(1:2,isd)</code> \u2013 order of the two adjacent elements follows global indices, and so the vector from node 1 to 2 in <code>isidenode(1:2,isd)</code> forms local y-axis while the vector from element 1 to 2 in isdel(1:2,isd) forms local x-axis. Therefore either of <code>isdel(1:2,isd)</code> can be negative. The element index is local (positive) if it is inside the aug. domain; otherwise the minus of global element index is returned. The local side <code>isd</code> is on the boundary if and only if <code>isdel(2,isd)=0</code>, and in this case, <code>isdel(1,isd)</code> must be inside the aug. domain (i.e., positive) (if <code>isd</code> is resident). If <code>isd</code> is resident and not ghost, <code>isdel()</code> has the same meaning as serial code, i.e., <code>is(1,isd)&gt;0</code> (inside the aug. domain), and <code>isdel(2,isd)&gt;=0</code>, and <code>isd</code> is on the boundary if and only if <code>isdel(2,isd)=0</code>.</li> <li><code>double :: delj(isd)</code> \u2013 meaningful only if isd is resident.</li> </ul> </li> <li>Boundary arrays : Most arrays point to global bnd segment #. Most B.C. arrays are global as well.<ul> <li><code>nope_global</code> \u2013 total # of open bnd segements in the global domain.</li> <li><code>nope</code> \u2013 total # of open bnd segements in the aug. domain.</li> <li><code>iopelg(1:nope)</code> \u2013 returns global open bnd segment # for a local open bnd segment.</li> <li><code>iopegl(0,k)</code> - # of local fragmentations of global open bnd segment k.</li> <li><code>iopegl(j,k)</code> - local segment # of jth (<code>1&lt;=j&lt;=iopegl(0,k)</code>) fragmentation of global open bnd segment k.</li> <li><code>nond(1:nope)</code> \u2013 total # of open bnd nodes on each segment. The corresponding global array is <code>nond_global()</code>.</li> <li><code>iond(nope,1: nond(1:nope))</code> \u2013 list of local node indices on each open bnd segment. The corresponding global array is <code>iond_global()</code>.</li> <li><code>nland</code> - total # of land bnd segements in the aug. domain. <code>nland_global</code> is global.</li> <li><code>nlnd(1:nland)</code> - total # of land bnd nodes on each segment.</li> <li><code>ilnd(nland,1: nlnd(1:nland))</code> \u2013 list of local node indices on each land bnd segment.</li> <li><code>nosd(nope)</code> (ELCIRC) - # of open bnd sides on each segment.</li> <li><code>iosd(nope, 1: nosd(nope))</code> (ELCIRC) \u2013 list of open bnd side on each segment.</li> <li><code>noe(nope)</code> (ELCIRC) - # of open bnd elements on each segment.</li> <li><code>ioe(nope, 1: noe(nope))</code> (ELCIRC) \u2013 list of open bnd elements on each segment.</li> <li><code>isbe(2,1:nea)</code> (ELCIRC) \u2013 if the element is on the local open bnd, this returns the local segment # and element #. 0 otherwise.</li> <li><code>isbs()</code> (ELCIRC) \u2013 similar to <code>isbe</code>.</li> <li><code>isbnd(-2:2,ip)</code> (SCHISM) - If <code>ip</code> is on 1 open bnd only, <code>isbnd(1,ip)</code> points to the global segment # of that open bnd and <code>isbnd(2,ip)=0</code>; if <code>ip</code> is on 2 open bnds, <code>isbnd(1:2,ip)</code> point to the global segment #s for the 2 open bnds. If <code>ip</code> is on land bnd only (i.e., not on open bnd), <code>isbnd(1,ip)= 1</code> and <code>isbnd(2,ip)=0</code>. If <code>ip</code> is an internal node, <code>isbnd(1:2,ip)=0</code>. Therefore, <code>ip</code> is on open bnd if <code>isbnd(1,ip)&gt;0</code> (and in this case <code>isbnd(2,ip)</code> may also be positive, even though <code>isbnd(2,ip)</code> may be outside the aug. domain), on land bnd (not on any open bnd) if <code>isbnd(1,ip)= 1</code>, and an internal node if <code>isbnd(1,ip)=0</code>. If on open bnd, <code>isbnd(-2:-1,ip)</code> are global index (i.e., <code>isbnd(-1,ip)</code>th node on the <code>isbnd(1,ip)</code>th open bnd);</li> <li><code>isbs(nsa)</code> - positive if a local side is on the global open bnd (in this case, <code>isbs()</code> is the global segment #); 1 if it is on land bnd; 0 if internal side.</li> <li><code>iettype</code>, <code>ifltype</code>, <code>itetype</code>, and <code>isatype</code> all take global bnd segment as argument; other b.c. arrays (<code>eth</code> etc) are also global.</li> <li><code>uth(nvrt,nsa)</code>,<code>vth(nvrt,nsa)</code> \u2013 local b.c. for <code>ifltype/=0</code> for a local side.</li> <li><code>uthnd(nvrt,mnond_global, nope_global)</code>, <code>vthnd()</code> \u2013 global arrays.</li> <li><code>elbc(ip)</code> \u2013 <code>ip</code> is a local node.</li> </ul> </li> <li>Arrays defined in <code>elfe_msgp.F90</code><ul> <li><code>nnbr</code> - # of neighbor processors (excluding <code>myrank</code>).</li> <li><code>nbrrank(nnbr)</code> \u2013 rank of each neighbor processor.</li> <li><code>int :: ranknbr(0:nproc-1)</code> \u2013 neighbor # for each processor (0 if not neighbor).</li> <li><code>nerecv(nnbr)</code> - # of elements to be received from each neighbor.</li> <li><code>ierecv(1: nerecv(nnbr),nnbr)</code> \u2013 list of element indices (ghost in <code>myrank</code>) to be received from each neighbor (where the elements are resident and not ghost).</li> <li><code>nesend(nnbr)</code> - # of elements to be sent to each neighbor.</li> <li><code>iesend(1: nesend(nnbr),nnbr)</code> \u2013 list of element indices (local resident in <code>myrank</code>) to be sent to each neighbor (where the elements are ghost). Similar for nodes/side (<code>nprecv</code>, <code>iprecv</code> etc).</li> </ul> </li> </ol> <p>A note on ghost exchange</p> <p>Since the message exchanges between processors have to wait for each other in order to communicate collectively, it's not necessary to synchronize the processes.</p>"},{"location":"code-contribution.html#important-mpi-routines","title":"Important MPI routines","text":"<ul> <li><code>MPI_Recv</code></li> </ul> <pre><code>int MPI_Recv(\n    void *buf, \n    int count, \n    MPI_Datatype datatype, \n    int source, \n    int tag,\n    MPI_Comm comm, \n    MPI_Status *status )\n!Inputs:\n!  count - maximum number of elements in receive buffer (integer);\n!  datatype - datatype of each receive buffer element (handle);\n!  source - rank of source (integer);\n!  tag - message tag (integer);\n!  comm - communicator (handle).\n!Outputs:\n!  buf - initial address of receive buffer (choice);\n!  status - status object (Status).\n</code></pre> <ul> <li><code>MPI_Irecv</code> : nonblock receive.</li> </ul> <pre><code>int MPI_Irecv( \n    void *buf, \n    int count, \n    MPI_Datatype datatype, \n    int source, \n    int tag, \n    MPI_Comm comm, \n    MPI_Request *request )\n!Inputs:\n!   buf - initial address of receive buffer (choice);\n!   count - number of elements in receive buffer (integer);\n!   datatype - datatype of each receive buffer element (handle);\n!   source - rank of source (integer);\n!   Tag - message tag (integer);\n!   comm - communicator (handle).\n!Output:\n!   request - communication request (handle)\n</code></pre> <ul> <li><code>MPI_Send</code></li> </ul> <pre><code>int MPI_Send( \n    void *buf, \n    int count, \n    MPI_Datatype datatype, \n    int dest, \n    int tag,\n    MPI_Comm comm )\n!Inputs:\n!   buf - initial address of send buffer (choice);\n!   count - number of elements in send buffer (nonnegative integer);\n!   datatype - datatype of each send buffer element (handle);\n!   dest - rank of destination (integer);\n!   tag - message tag (integer);\n!   comm - communicator (handle).\n</code></pre> <ul> <li><code>MPI_Isend</code> : non-block send</li> </ul> <pre><code>int MPI_Isend( \n    void *buf, \n    int count, \n    MPI_Datatype datatype, \n    int dest, \n    int tag,\n    MPI_Comm comm, \n    MPI_Request *request )\n! Inputs:\n!   buf - initial address of send buffer (choice);\n!   count - number of elements in send buffer (integer);\n!   datatype - datatype of each send buffer element (handle);\n!   dest - rank of destination (integer);\n!   tag - message tag (integer);\n!   comm - communicator (handle).\n!Output:\n!   request - communication request (handle).\n</code></pre> <ul> <li><code>MPI_Allreduce</code> : Combines values from all processes and distribute the result back to all processes</li> </ul> <pre><code>int MPI_Allreduce ( \n    void *sendbuf, \n    void *recvbuf, \n    int count, \n    MPI_Datatype datatype, \n    MPI_Op op, \n    MPI_Comm comm )\n! Inputs:\n!   sendbuf - starting address of send buffer (choice);\n!   count - number of elements in send buffer (integer). Also the size of the output \n!           (i.e., ith elements from each processor are summed up and returned as ith element of output);\n!   datatype - data type of elements of send buffer (handle);\n!   op - operation (handle) (e.g., MPI_SUM, MPI_LOR);\n!   comm - communicator (handle).\n! Output:\n!   recvbuf - starting address of receive buffer (choice).\n</code></pre> <ul> <li><code>MPI_Reduce</code></li> </ul> <pre><code>int MPI_Reduce ( \n    void *sendbuf, \n    void *recvbuf, \n    int count, \n    MPI_Datatype datatype, \n    MPI_Op op, \n    int root, \n    MPI_Comm comm )\n! only difference from MPI_Allreduce is that the result is sent to rank \"root\".\n</code></pre> <ul> <li><code>MPI_Gather</code> : Gathers together values from a group of processes.</li> </ul> <pre><code>int MPI_Gather ( \n    void *sendbuf, \n    int sendcnt, \n    MPI_Datatype sendtype, \n    void *recvbuf, \n    int recvcount, \n    MPI_Datatype recvtype, \n    int root, \n    MPI_Comm comm )\n! Inputs:\n!   sendbuf - starting address of send buffer (choice)\n!   sendcount - number of elements in send buffer (integer)\n!   sendtype - data type of send buffer elements (handle)\n!   recvcount - number of elements for any single receive (integer, significant !  only at root)\n!   recvtype - data type of recv buffer elements (significant only at root) (handle)\n!   root - rank of receiving process (integer)\n!   comm - communicator (handle)\n! Output:\n!   Recvbuf - address of receive buffer (choice, significant only at root). The received values\n!   are stacked according to the rank number (i.e., first recvcount are from rank 0 etc).\n</code></pre> <ul> <li><code>MPI_Allgatherv</code> : Gathers data from all tasks and deliver it to all.</li> </ul> <pre><code>int MPI_Allgatherv ( \n    void *sendbuf, \n    int sendcount, \n    MPI_Datatype sendtype, \n    void *recvbuf, \n    int *recvcounts, \n    int *displs, \n    MPI_Datatype recvtype, \n    MPI_Comm comm )\n\n!Inputs:\n!   sendbuf - starting address of send buffer (choice);\n!   sendcount - number of elements in send buffer (integer)\n!   sendtype - data type of send buffer elements (handle);\n!   recvcounts - integer array (of length group size) containing the number of elements \n!       that are received from each process;\n!   displs - integer array (of length group size). Entry i specifies the displacement\n!       (relative to recvbuf) at which to place the incoming data from process i;\n!   recvtype - data type of receive buffer elements (handle);\n!   comm. - communicator (handle).\n! Output:\n!   recvbuf - address of receive buffer (choice).\n</code></pre> <ul> <li><code>MPI_Type_indexed</code> : Creates an indexed datatype; the corresponding routine in <code>MPI2 is mpi_type_create_indexed_block()</code>.</li> </ul> <pre><code>int MPI_Type_indexed(\n    int count,\n    int blocklens[],\n    int indices[],\n    MPI_Datatype old_type,\n    MPI_Datatype *newtype )\n! Inputs:\n!   count - number of blocks -- also number of entries in indices and blocklens;\n!   blocklens - number of elements in each block (array of nonnegative integers);\n!   indices - displacement of each block in multiples of old_type (array of integers);\n!   old_type - old datatype (handle).\n! Output:\n!   newtype - new datatype (handle)\n</code></pre> <p>Note</p> <p>The new MPI type treats multi-dimensional arrays in FORTRAN as 1D array, expanding with 1st index varying before 2nd etc. So this routine can be used to grab discontiguous data blocks from multi- dimensional arrays. So if a 2D array is a(nvrt,nea) the corresponding 1D array is illustrated below:</p> \\[\\begin{equation*} nea \\stackrel{nvrt}{ \\begin{bmatrix} (1, 1) &amp; (2, 1) &amp; \\cdots &amp; (nvrt, 1)\\\\ (1, 2) &amp; (2, 2) &amp; \\cdots &amp; (nvrt, 2)\\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots\\\\ (1, nea) &amp; (2, nea) &amp; \\cdots &amp; (nvrt, nea) \\end{bmatrix} } \\end{equation*}\\] <p>Now suppose we need to grab all ghost elements iesend(1:nesend), these will correspond to rows iesend(i) of the table. In this case the # of blocks is nesend, block length is nvrt, and displacement of ith block is (iesend(i)-1)*nvrt.</p> <ul> <li><code>MPI_Barrier</code> : Blocks until all process have reached this routine.</li> </ul> <pre><code>int MPI_Barrier (MPI_Comm comm )\n! Input: comm. - communicator (handle)\n</code></pre> <ul> <li><code>MPI_Type_struct</code> : Creates a struct datatype.</li> </ul> <pre><code>int MPI_Type_struct(\n    int count,\n    int blocklens[],\n    MPI_Aint indices[],\n    MPI_Datatype old_types[],\n    MPI_Datatype *newtype )\n\n! Inputs:\n!   count - number of blocks (integer)\n!       also number of entries in arrays array_of_types, array_of_displacements and array_of_blocklengths;\n!   blocklens - number of elements in each block (array);\n!   indices \u2013 byte displacement of each block relative to the start of the type (array);\n!   old_types - type of elements in each block (array of handles to datatype objects).\n! Output:\n!   newtype - new datatype (handle)\n</code></pre> <ul> <li><code>MPI_Alltoall</code> : Sends data from all to all processes.</li> </ul> <pre><code>int MPI_Alltoall( \n    void *sendbuf, \n    int sendcount, \n    MPI_Datatype sendtype, \n    void *recvbuf, \n    int recvcnt, \n    MPI_Datatype recvtype, \n    MPI_Comm comm )\n! Inputs:\n!   sendbuf - starting address of send buffer (choice);\n!   sendcount - number of elements to send to each process (integer);\n!   sendtype - data type of send buffer elements (handle);\n!   recvcount- number of elements received from any process (integer);\n!   recvtype - data type of receive buffer elements (handle);\n!   comm. - communicator (handle).\n! Outputs\n!   recvbuf - address of receive buffer (choice)\n</code></pre>"},{"location":"code-contribution.html#io-channels-in-schism","title":"I/O channels in SCHISM","text":"<p>You need to exercise caution when dealing with parallel I/O especially for writing. For writing outputs, you\u2019d generally let only 1 process do the job, e.g. </p> <pre><code>if(myrank==0) write(10,*)\n</code></pre> <p>If you do need to have all processes write e.g. debug messages, you\u2019d consider using channel <code>12</code> which has been pre-set to point to multiple files from each MPI process (see below).</p> <p>Here are all I/O channel numbers currently used in different sub-models of SCHISM (and so you\u2019d avoid using them). A good way to find out if a channel is available is to issue the following cmd from <code>src/</code> -</p> <pre><code>grep \"(61\" */*.F90 # Looks for '(61'\n</code></pre> <p>Please contact lead developer after you have selected a channel number to use in your module.</p> <ol> <li> <p><code>Hydro/</code> : Channels between 8 and 200 are used by various codes for I/O. In particular - </p> <ul> <li>101 to 100+noutputs (inclusive of both): reserved for global outputs (including from tracers like sediment, EcoSim, ICM, as well as WWM);</li> <li>201-250: non-standard outputs (e.g. at sidecenters, prism centers);</li> <li>251 to 259: reserved for station outputs;</li> <li>16: this channel points to mirror.out (on rank 0), the main message output about the run. You should use it with <code>if(myrank==0)</code>.</li> </ul> </li> <li> <p><code>WWM</code></p> <ul> <li>1100 to 1200: handles for inputs/outputs etc</li> </ul> </li> <li> <p><code>EcoSim</code></p> <ul> <li>600: outputting some messages</li> </ul> </li> <li> <p><code>ICM</code></p> <ul> <li>301 to 323: reading channels for non-point source inputs for ICM</li> </ul> </li> <li> <p><code>Sediment (SED and SED2D)</code></p> <ul> <li>26, 2626</li> </ul> </li> </ol> <p>Following are some generic channels - </p> <ol> <li><code>10, 31, 32</code>: used for one-off I/O \u2013 can be used by other sub-models as long as you close them immediately after use;</li> <li><code>12</code>: this channel is initialized by different processes to point to files <code>outputs/nonfatal_xxxx</code>, where \u201cxxxx\u201d are the process IDs. Therefore it\u2019s very useful for debugging purpose; you can use it anywhere in your part of the code to dump messages to these files.</li> </ol>"},{"location":"code-contribution.html#example-code","title":"Example code","text":"<p>If you are working on the code you may be confused about the exchanges inside SCHISM. When should you use these?</p> <p>The first thing you need to remember when writing MPI code with domain decomposition is that a rank (or MPI 'process') only has info in its 'augmented' (=resident + ghost) domain, and knows absolutely nothing outside this region.</p> <p></p>  Domain decomposition for code example. <p>Consider Figure 4. For example, you want to do averaging at each node of the sub-domain around its ball of elements.</p> <pre><code>do i=1,np !not 'npa'\n    sum1=0\n    sum_a=0\n\n    do j=1,nne(i)\n        ie=indel(j,i)\n        sum1=sum1+stokes(ie)*area(ie)\n        sum_a=sum_a+area(ie)\n    enddo !j\n\n    stokes_nd(i)=sum1/sum_a\nenddo !i\n\ncall exchange_p2d(stokes_nd)\n</code></pre> <p>Notice that you'd use <code>np</code> instead of <code>npa</code> (<code>=np+npg</code>; augmented domain) here. For any resident node <code>P</code>, <code>indel()</code> is well defined (because again, Rank 1 has info in its augmented domain including the ghost zone), and so the loops make sense. As long as all ranks have same info in each others' ghost zones (which is the purpose of exchange routines), <code>stokes_nd</code> at an interface node (e.g. <code>P</code>) will be same across ranks. However, for a ghost node <code>Q</code>, some surrounding elements are located outside the augmented domain (and in this case, <code>indel()</code> are actually negative!), and so if you use the same operation, erroneous values at ghost nodes would be generated. Therefore you cannot use npa in the outer loop.</p> <p>Now, after this loop is executed, what happens to the ghost nodes like <code>Q</code>? Since they are excluded on Rank 1, the <code>stokes_nd</code> will be wrong there. Fortunately, some neighboring ranks have the correct values for these nodes, which are resident nodes in those neighboring ranks; e.g., <code>Q</code> is a resident node of Rank 0. So now different ranks will have different values at some overlapping nodes, and this needs to be avoided. In order to make sure each rank has correct (and up-to-date) values in its augmented domain, you need to follow this loop with an exchange routine. Remember that for the exchange routines to work, you need to define the exchanged array in the augmented domain - </p> <pre><code>allocate(stokes_nd(npa)) !not 'np'\n</code></pre> <p>in order to allow each rank to receive info in the ghost zone. Description of all exchange routines used in SCHISM can be found in <code>schism_msgp.F90</code>.</p> <p>The above is just one example of when exchanges are needed. Usually this involves some kind of queries into a neighborhood, but beware that there are other circumstances where exchanges are necessary. </p> <p>The most important thing to remember</p> <ul> <li>A rank only has info in its 'augmented' domain, and knows absolutely nothing outside this region.</li> <li>In MPI code, it's crucial to make sure all ranks have identical values in overlapping zone.</li> </ul> <p>Now let's consider an example where no exchanges are needed. Say you want to simply go through all elements and update some arrays defined at elements:</p> <pre><code>do i=1,nea !not 'ne'\n    qdl_e(i)=cde(i)*dte/area(i)\nenddo !i\n</code></pre> <p>Since all ranks have info of <code>cde</code> and <code>area</code> locally available, <code>qdl_e</code> will be correctly calculated even inside the ghost zones, and its values are the same cross ranks there (since <code>cde</code> and <code>area</code> are same cross ranks in the overlapping zones). So in this case you'd use <code>nea</code> instead of <code>ne</code> in the loop. Of course, there is nothing wrong with using <code>ne</code> in the loop followed by an exchange routine, but doing so would be less efficient and incur unnecessary communication cost.</p>"},{"location":"code-contribution.html#general-code-guide","title":"General code guide","text":"<p>Here are some house rules for preparing your own code - </p> <ol> <li>No spaces between <code>#</code> (pre-processor) and <code>if/else/end</code> for CPP flag;</li> <li>Try to use the I/O channel number directly, e.g., <code>read(61, etc)</code> instead of assigning a number to a variable (e.g. <code>read(ich,)</code>. This'd facilitate others searching for conflicts;</li> <li>Avoid using tabs in editor as they mess up with the appearance. Use space instead and strictly align code blocks for easy read.</li> <li>Do not use automatic arrays of \u22652 dimensions. It\u2019s often tempting to grab dimensions directly from the module <code>schism_glbl</code> and use them to define arrays in a routine; e.g. <code>vel_sd(nvrt,nsa)</code>. This causes trouble with some compilers and may result in segfault. Use either of the following 2 approaches instead: <ol> <li>allocatable arrays (and always remember to deallocate them at the end of the routine);</li> <li>pass on the dimensions explicitly as dummy arguments (e.g. <code>subroutine routine1(nvrt2,nsa2, vel_sd..)</code>, where <code>nvrt2=nvrt</code> and <code>nsa2=nsa</code>, and then use these to define: <code>vel_sd (nvrt2,nsa2)</code>).</li> </ol> </li> </ol>"},{"location":"contribute-to-this-online-manual.html","title":"Overview","text":"<p>All SCHISM developers are encouraged to keep this online manual up to date with their code development. This section serves as a brief guide for contributing to this manual. </p>"},{"location":"contribute-to-this-online-manual.html#directory-structure","title":"Directory structure","text":"<p>All files used to build this manual are included in SCHISM's Git Repository. As of April 9, 2021, you automatically get a copy of them after you download the SCHISM code: <pre><code>git clone https://github.com/schism-dev/schism\n</code></pre></p> <p>For you to update this online manual, the relavant files are</p> <ul> <li> <p>The mkdoc configuration file: <pre><code>$your_dir/schism/mkdocs.yml\n</code></pre></p> </li> <li> <p>The \"docs\" folder: <pre><code>$your_dir/schism/docs/\n</code></pre> , which mainly contains markdown files: <pre><code>docs\n\u251c\u2500\u2500 schism\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 barotropic-solver.md\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 eulerian-lagrangian-method.md\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 geometry-discretization.md\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 momentum-equation.md\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 overview.md\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 physical-formulation.md\n\u2502   ...\n\u2514\u2500\u2500 verification-tests.md\n    ...\n</code></pre> and assets files (such as *.png files) <pre><code>docs\n\u251c\u2500\u2500 assets\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 bay-delta-schism-grid.png\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 bnd-elem.png\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 case-study-guam.png\n\u2502   ...\n</code></pre> </p> </li> </ul>"},{"location":"contribute-to-this-online-manual.html#updating-the-manual","title":"Updating the manual","text":""},{"location":"contribute-to-this-online-manual.html#minor-edits","title":"Minor edits","text":"<p>If you are only making minor changes on an existing manual page, the easiest way is probably directly editing the *.md file on Github. Simply click the \"edit\" button at the top-right corner of any manual page:</p> <p></p> <p>It will take you to the Github page, where you can directly edit the *.md file then commit changes. We do ask you to provide a brief and sensible commit message.</p>"},{"location":"contribute-to-this-online-manual.html#adding-a-short-content","title":"Adding a short content","text":"<p>Follow these steps if your content is short enough to fit in a single page:</p> <ul> <li> <p>Decide where your new page fits in this manual and specify it in the last section of \"mkdocs.yml\". For example, see how \"your-new-page\" is inserted in \"mkdocs.yml\" below: <pre><code>...\nnav:\n  - Home: index.md\n  ...\n  ...\n  - Modules:\n    - Overview: modules/overview.md\n    - Generic tracer module: modules/generic-tracer.md\n    - AGE: modules/age.md\n    ...\n    ...\n  - Title of your new page: your-new-page.md\n    ...\n    ...\n  - Contribute to this online manual: contribute-to-this-online-manual.md\n</code></pre> Please give a meaningful name to the *.md file associated with your new page.</p> </li> <li> <p>Put your *.md file directly under \"docs/\", for example: <pre><code>$your_dir/schism/docs/your-new-page.md\n</code></pre> and put any additional materials in <pre><code>$your_dir/schism/docs/assets/\n</code></pre> Please give a sensible name to any additional materials, for example: \"your-new-page-some-figure.png\" </p> </li> </ul>"},{"location":"contribute-to-this-online-manual.html#adding-a-content-with-multiple-subsections","title":"Adding a content with multiple subsections","text":"<ul> <li> <p>Decide where your new content fits in this manual and specify it in the last section of \"mkdocs.yml\". For example, see how \"your-multi-page-content\" is inserted in \"mkdocs.yml\" below: <pre><code>...\nnav:\n  - Home: index.md\n  ...\n  ...\n  - Modules:\n    - Overview: modules/overview.md\n    - Generic tracer module: modules/generic-tracer.md\n    - AGE: modules/age.md\n    ...\n    ...\n  - Title of your-multi-page-content:\n    - Overview: your-multi-page-content/overview.md\n    - Some topic: your-multi-page-content/some-topic.md\n    ...\n  - Contribute to this online manual: contribute-to-this-online-manual.md\n</code></pre></p> </li> <li> <p>Make a subfolder under \"docs\", which will contain all new *.md files <pre><code>$your_dir/schism/docs/your-multi-page-content/\n</code></pre></p> </li> <li> <p>For each subsection, create one *.md file: <pre><code>$your_dir/schism/docs/your-multi-page-content/overview.md\n$your_dir/schism/docs/your-multi-page-content/some-topic.md\n...\n</code></pre></p> </li> </ul> <p>Although other directory structures can be used to make multi-page contents, we kindly ask you to follow our convention.  </p>"},{"location":"contribute-to-this-online-manual.html#preview-your-edits","title":"Preview your edits","text":"<p>If you are making non-trivial changes, you may want to preview your edits before committing them to Git. To do this, you will have to install \"mkdocs\" on your local machine. This can be done system-wide using the system python installation (and associated pip command): <pre><code>pip install mike mkdocs mkdocs_material mkdocs-with-pdf\n</code></pre> Then, under <pre><code>$your_dir/schism/\n</code></pre> do <pre><code>mkdocs serve\n</code></pre> If there are no errors, it will return an IP address of the manual under editing at the end of the initial command line message: <pre><code>INFO     -  Building documentation...\nWARNING  -  without generate PDF(set environment variable ENABLE_PDF_EXPORT to 1 to enable)\nINFO     -  Cleaning site directory\nWARNING  -  Both index.md and readme.md found. Skipping readme.md from /media/feiye/My Book/schism/docs\nWARNING  -  Documentation file 'contribute-to-this-online-manual.md' contains a link to '{{ site.baseurl }}{% link docs/compound-flood/compound-flood.md %}' which is not found in the documentation files.\nWARNING  -  Documentation file 'contribute-to-this-online-manual.md' contains a link to '{{ site.baseurl }}{% link docs/acetool-tips/acetool-tips.md %}' which is not found in the documentation files.\nINFO     -  Documentation built in 0.77 seconds\nINFO     -  [22:21:41] Watching paths for changes: 'docs', 'mkdocs.yml'\nINFO     -  [22:21:41] Serving on http://127.0.0.1:8000/\n</code></pre> You can open it with a web browser and any changes in the source files will be reflected immediately.</p> <p>See more instructions here.  </p>"},{"location":"contribute-to-this-online-manual.html#markdown","title":"Markdown","text":"<p>A quick reference of the Markdown syntax.  </p>"},{"location":"contribute-to-this-online-manual.html#cross-referencing","title":"Cross-referencing","text":"<p>Most equations, figures and papers in this document are labeled, so these can be referenced in another place in the  same or different .md files. The general syntax is [ ] followed by (#). Some examples are:  <pre><code> [Zhang et al. 2016](#zhang2016)   &lt;--refers to #zhang2016 in same .md\n (Figure [5ab](./barotropic-solver.md#figure05))   &lt;-- refers to figure05 inside barotropic-solver.md in the same dir\n</code></pre>"},{"location":"contribute-to-this-online-manual.html#more-features","title":"More features","text":"<p>If you need advanced features for your tutorial page, you can use some HTML syntax in your *.md files. However, we recommend that you keep the page layout and syntax as simple as possible.</p>"},{"location":"faq.html","title":"Frequently Asked Questions","text":"<p>Besides the following info, you may also search archived messages from the SCHISM mailing list on the same web where you registered yourself for the mailing list. Just log in, and select 'Archive' from the left of the screen, and then on right side of screen select 'Advanced search'. </p> My results show platform/compiler/CPU dependency <p>Due to some intricate differences between different compilers/platforms some minor differences in results are expected. Bit-by-bit match of results using different numbers of CPUs is impossible also. But the differences should be small and should stabilize over time iteration.</p> Run crashed with a fatal.error error message \"QUICKSEARCH: no intersecting edge....\" <p>First you need to viz the results before the crash (e.g. surface velocity) to see if anything is  outrageously wrong. Often times, errors such as this, related to the backtracking, come from other errors (e.g. NaN in inputs). </p> <p>Very rarely, the error originates from the underflow issue in the backtracking/ELM (and the results otherwise  look reasonable). In the backtracking step, the code assumes that the path intersects sides of elements at 1 unique point that does not coincide with any node (cf. Fig. 1). Obviously this causes problem especially in some academic cases (e.g. the velocity aligns perfectly with grid line). To avoid this issue, the code nudges the starting position of backtracking (with parameter <code>btrack_nudge</code>) toward the starting element's centroid. Occasionally, this is still insufficient when the velocity is large on very fine meshes. One way out of this is to reduce <code>dtb_max</code> and <code>dtb_min</code> to get more accurate trajectory.</p> Run crashed with a fatal.error error message \"bktrk_subs: overflow...\" or \"MAIN: nbtrk &gt; mxnbt\" <p>The backtracking (ELM) in SCHISM is parallelized across MPI processes, and some arrays need to be allocated to store trajectories that exited the augmented domain. The dimension of those arrays is defined in mxnbt and mnbt, which are proportional to local # of side and # of levels, and the proportionality constants are defined in param.nml:</p> <p><code>s1_mxnbt = 0.5</code>, <code>s2_mxnbt = 3.5</code></p> <p>(Gradually) increasing these (to say 1, and 4) will solve the problem. Note that these constants only affect memory consumption and not accuracy.</p> How to do a tidal simulation with SCHISM? <p>The simplest way is to use SCHISM 2D. If you have to use SCHISM 3D, make sure the vertical grid is reasonable.</p> My run crashed; how can I find out why? <p>The best way to find out the reason for a crash is to visualize the surface velocity with VisIT. Usually you may see some large/noisy velocity somewhere, which may give you some hints on grid or forcing issues etc.</p> <p>Sometimes you want to visualize the problem right before the crash. You cannot use <code>autocombine_MPI_elfe.pl</code> as the last stack of output is incomplete. But you can use the FORTRAN combine script (e.g., <code>combine_output*</code>) to directly combine an incomplete stack. Just follow the instruction in the header of this script to prepare the inputs and run. Then visualize the combined outputs.</p> How to impose river discharge if the depth is negative there? <p>See Grid generation.</p> Run crashes with a dry boundary/depth error. <p>SCHISM allows dry open-boundary nodes, but the entire open boundary segment cannot be dry at any given time if the velocity B.C. is imposed there. Either relocate the boundary or deepen some nodes to allow flow to come in. See Grid generation.</p> I have large velocity at open boundary <p>In hydrostatic models, the incoming velocity should be specified at open boundary. Over-specification i.e. elevation+velocity B.C. there usually avoids the problem, but the two B.C.\u2019s must be largely consistent with each other. The velocity B.C. can be generated using global circulation model (HYCOM etc) plus global tidal model (FES etc).</p> My 3D velocity has noise or weird patterns <p>This can be caused by a number of reasons, but a common one is that when user switches from 2D to 3D, they forgot to set itur=3 to use turbulence closure.</p> fatal.error indicates \u201cCould not find suitable element in input\u201d <p>This is likely because your <code>sflux*.nc</code> is not prepared properly: either the grid in <code>.nc</code> does not cover <code>hgrid.ll</code>, or the structured grid in <code>.nc</code> has a mixture of clockwise and counter-clockwise orientations.</p>"},{"location":"known_issues.html","title":"Known issues","text":""},{"location":"known_issues.html#freshwater-injection-stuck-near-injection-place","title":"Freshwater injection stuck near injection place","text":"<p>This can happen with the combined use of (1) point source/sink (<code>if_source</code>=1); (2) LSC2 with 1-2 layers near  injection places; (3) baroclinic model. The main symptom is that the freshwater seemingly gets stuck near the   injection points and does not flow out as expected.</p> <p>The reason is that insufficient number of vertical layers cannot properly set up an exchange flow (that  requires stratification), and as a result, the fresh/salt water interface oscillates instead of tilting as expected. Some work-arounds are:</p> <ol> <li>Change to open boundary condition approach</li> <li>Better salinity initial condition. If the salt intrusion should never reach the injection place, create    a freswater zone near the injection in the I.C.</li> <li>Use more vertical layers near injection (one way to do this is to deepen the local depths to allow for more layers)</li> <li>Nudge (inu_tr(2)=1 or 2) strongly in a region near injection</li> </ol>"},{"location":"known_issues.html#numerical-dispersion-with-weno","title":"Numerical dispersion with WENO","text":"<p>The 3rd-order WENO scheme has numerical dispersion that needs to be controlled, usually by adjusting <code>epsilon[12]</code>   in <code>param.nml</code>. This approach usually works well. Under some circumstances, e.g. watershed in the compound flooding cases, this  adjustment is not enough, especially if hybrization with ELM transport is used (<code>ielm_transport=1</code>). This is   because ELM tracer results may introduce 'shocks' to the local WENO stencil, which in turn generate disperision.  In those cases, the users need to adjust <code>tvd.prop</code> to make some areas upwind as well to ensure monotonicity, because  upwind scheme handles shocks well.</p> <p>Figure 1 shows the result of disperion symptom from WENO, in the form of high salinity in some upriver  regions of Chesapeake Bay. Higher-order WENO, 1st-order upwind and ELM solvers are applied in adjacent  elements in close proximity in those upriver regions  (note that <code>h_tvd</code>=5m in this case). Making those upriver elements upwind via <code>tvd.prop</code> resolves this issue; cf. Fig. 2.</p> <p>There are scripts in Utility/ that can be used to create appropriate <code>tvd.prop</code> for cross-scale applications.</p> <p></p> Numerical dispersion in WENO led to high surface salinity in Chesapeake Bay (circled area). <p></p> Making upstream rivers upwind resolved the high surface salinity issue in Chesapeake Bay."},{"location":"readme.html","title":"Documenting on mkdocs","text":""},{"location":"readme.html#installation-optional-for-local-development","title":"Installation (optional; for local development)","text":"<p>The basic install only requires <code>mkdocs</code> and <code>mkdocs_materials</code> to be installed. This can be done system-wide using the system python installation (and associated <code>pip</code> command). </p> <pre><code>pip install mkdocs mkdocs_material mkdocs-with-pdf\n</code></pre> <p>To check where <code>pip</code> is located, use <code>which pip</code> in linux/unix system.</p> <p>If you are a conda/anaconda user, you can also create a new environment from the provided <code>environment.yml</code> file</p>"},{"location":"readme.html#writing-markdown-document","title":"Writing markdown document","text":"<p>Basic text</p> <p>Sections, subsections: <code>#</code>, <code>##</code> etc.</p> <p>Bold: <code>**Text**</code> \\(\\rightarrow\\) Text</p> <p>Italic: <code>_Text_</code> \\(\\rightarrow\\) Text</p> <p>Image </p> <pre><code>&lt;figure markdown id='figureXX'&gt;\n![alt-text](relative/path/to/figure.png)\n&lt;figcaption&gt;A good figure caption&lt;/figcaption&gt;\n&lt;/figure&gt;\n</code></pre> <p>To reference this figure in the text, create a link <code>[Figure XX](path/to/page.md#figureXX)</code>. If the figure is referenced in the same page, the <code>path/to/page.md</code> can be omitted.</p> <p>Table</p> <p><pre><code>| header 1| header 2|\n|---------|---------|\n| item 1 | item 2|\n</code></pre> will produce - </p> header 1 header 2 item 1 item 2 <p>Add a <code>span</code> before for a referencable caption</p> <pre><code>&lt;span id=\"table01\"&gt;Table caption&lt;/span&gt;\n</code></pre> <p>and refer using link notation <code>Table [1](#table01)</code>.</p> <p>Equations</p> <p>Equations can be added using standard latex <code>\\begin{equation}\\label{eqxx}\\end{equation}</code> block, or inline with <code>$...$</code> block. Other latex command works inside these blocks. The equation inside <code>equation</code> block with label <code>eqxx</code> can be referred inline using <code>$\\ref{eqxx}$</code>.</p> <p>References</p> <p>References can be added as link. For example <code>[Zhang et al. 2016](#zhang2016)</code>. An entry for this reference cab be added with html <code>&lt;span&gt;</code> in the end of each page as <code>&lt;span id=\"zhang2016\"&gt;Zhang, Y., Stanev, E.V. and S. Grashorn (2016) Unstructured-grid model for the North Sea and Baltic Sea: validation against observations, Ocean Modelling, 97, 91-108.&lt;/span&gt;</code>. Here <code>id</code> is what makes the link works.</p>"},{"location":"readme.html#build-and-deploy-site","title":"Build and deploy site","text":"<pre><code>mkdocs serve # to see locally\nmkdocs build # build site\nmkdocs gh-deploy --force # serve site to github on gh-page branch\n</code></pre> <p>You will need github pages fully setup. See Github Pages for more information.</p>"},{"location":"coupling/cesm.html","title":"NCAR's Community Earth System Model","text":"<p>The Community Earth System Model (CESM) is a fully coupled global climate model developed in collaboration with colleagues in the research community. CESM provides state of the art computer simulations of Earth's past, present, and future climate states.</p> <p>The CESM project is supported primarily by the National Science Foundation (NSF). Administration of the CESM is maintained by the Climate and Global Dynamics Laboratory (CGD) at the National Center for Atmospheric Research (NCAR).</p> <p>The SCHISM NUOPC can be integrated into the CESM as an ocean component in principle, once it is integrated into their Common Infrastructure for Modeling the Earth (CIME, see below).  </p>"},{"location":"coupling/cesm.html#obtaining-cesm","title":"Obtaining CESM","text":"<p>The version of CESM supporting SCHISM can be obtained as </p> <pre><code>git clone  https://github.com/mvertens/cesm.git -b feature/add_schism\n./manage_externals/checkout_externals -v -o\n</code></pre>"},{"location":"coupling/cesm.html#obtaining-and-building-with-cime","title":"Obtaining and building with CIME","text":"<p>CIME, pronounced \"SEAM\", primarily consists of a Case Control System that supports the configuration, compilation, execution, system testing and unit testing of an Earth System Model. The two main components of the Case Control System are:</p> <ol> <li>Scripts to enable simple generation of model executables and associated input files for different scientific cases, component resolutions and combinations of full, data and stub components with a handful of commands.</li> <li>Testing utilities to run defined system tests and report results for different configurations of the coupled system.</li> </ol> <p>A test case with SCHISM can be built with CIME by executing </p> <pre><code>cd cime/scripts\n./create_newcase --case test_schism --res TL319_rsfb --compset CSCHISM --run-unsupported --machine conda\n</code></pre> <p>After the case is created, one needs to execute <code>./case.build</code> and <code>./case.submit</code>, but these currently do not yet work.  Tasks are - fill in <code>cime_config/buildlib</code> - fill in <code>cime_config/buildnml</code></p> <p>The development process is documented in https://github.com/schism-dev/schism-esmf/issues/20.  Help is much appreciated.</p>"},{"location":"coupling/coastalapp.html","title":"NOAA's CoastalApp","text":"<p>The NOAA Environmental Modeling System (NEMS) Coastal Application \"CoastalApp\" is a NUOPC-based coupled system using the NEMS coupler.</p> <p>The SCHISM NUOPC cap is currently being integrated as an ocean component of the CoastalApp; CoastalApp is available from a public repository https://github.com/noaa-ocs-modeling/CoastalApp, and its integration with SCHISM occurs in the <code>develop-updates</code> branch</p>"},{"location":"coupling/coastalapp.html#obtaining-and-building-coastalapp","title":"Obtaining and building CoastalApp","text":"<pre><code>export COASTALAPP_DIR=/my/path/to/coastalapp\ngit clone https://github.com/noaa-ocs-modeling/CoastalApp -b develop $COASTALAPP_DIR \ncd $COASTALAPP_DIR\ngit submodule update --init --recursive SCHISM/schism SCHISM/schism-esmf NEMS \nbash ./build.sh -component \"SCHISM\"\n</code></pre> <p>You can add components like <code>WW3</code> or <code>ADCIRC</code>, and you may be required to choose a <code>-compiler</code>  or <code>-platform</code>, or set environment variables like <code>PARMETIS</code> or <code>ESMFMKFILE</code>.  Consult <code>./build.sh -h</code> for help and further information.</p> <p>A typical coupled system that we currently use for testing would, e.g., include the three components OCN-ATM-WAV:</p> <pre><code>git submodule update --init --recursive SCHISM/schism SCHISM/schism-esmf NEMS WW3 ATMESH\n./scripts/download_parmetis.sh\nbash ./build.sh -component \"SCHISM WW3 ATMESH\" --thirdparty parmetis\n</code></pre>"},{"location":"coupling/coastalapp.html#reporting-bugs-or-requesting-features","title":"Reporting bugs or requesting features","text":"<p>The integration of SCHISM into CoastalApp is still in development.  Please report any errors or annoyances in the upstream bug tracker on https://github.com/noaa-ocs-modeling/CoastalApp/issues. </p>"},{"location":"coupling/esmf.html","title":"Earth System Modeling Framework","text":"<p>The Earth System Modeling Framework (ESMF) is a suite of software tools for developing high-performance, multi-component Earth science modeling applications. Such applications may include a few or dozens of components representing atmospheric, oceanic, terrestrial, or other physical domains, and their constituent processes (dynamical, chemical, biological, etc.). Often these components are developed by different groups independently, and must be \u201ccoupled\u201d together using software that transfers and transforms data among the components in order to form functional simulations.</p> <p>SCHISM can be such a model component within an ESMF-coupled system.  A so-called \"cap\" wraps SCHISM and exposes it via the ESMF Application Programming Interface (API).  The interfaces exposed through the API are (1) import of fields, (2) export of fields, and (3) control structure.</p> <p>A live manual can be found here.</p>"},{"location":"coupling/esmf.html#obtaining-and-building-the-cap","title":"Obtaining and building the cap","text":"<p>The ESMF and the NUOPC caps are jointly hosted in a separate repository on https://github.com/schism-dev/schism-esmf.  It requires that the SCHISM core is built and pointed to by the environment variable <code>$SCHISM_BUILD_DIR</code> </p> <p><pre><code>export SCHISM_ESMF_DIR=/my/path/to/schism-esmf\ngit clone https://github.com/schism-dev/schism-esmf.git $SCHISM_ESMF_DIR\ncd $SCHISM_ESMF_DIR\nmake install-esmf\n</code></pre> The combined SCHISM and SCHISM-ESMF libraries will be available in the <code>./lib</code> subdirectory.  </p>"},{"location":"coupling/esmf.html#pre-configured-executables","title":"Pre-configured executables","text":"<p>While the API exposed through the SCHISM-ESMF library is the core functionality of the cap, there are also several pre-configured simple coupled systems available for you to  <code>make</code> or use as a template: </p> <pre><code>concurrent_esmf_test.F90  \nmulti_schism.F90\nschism_driver_interfaces.F90\nschism_pdaf.F90\ntriple_schism.F90\n</code></pre> <p>Have a look at the <code>examples</code> subdirectory!</p>"},{"location":"coupling/esmf.html#applications","title":"Applications","text":"<p>(1) The SCHISM ESMF cap is used to couple SCHISM to the Parallel Data Assimilation Framework leveraging the control structures of ESMF, see the example <code>schism_pdaf.F90</code>.</p> <p>(2) The SCHISM ESMF cap is used in the Modular System for Shelves and Coasts, see  MOSSCO.  Within that system, SCHISM can be flexibly coupled to components for the atmosphere, waves, ocean BGC, generic input/output, sediment. </p>"},{"location":"coupling/esmf.html#publications","title":"Publications","text":"<p>Yu, H.-C., Zhang, Y. J., Nerger, L., Lemmen, C., Yu, J. C. S., Chou, T.-Y., Chu, C.-H., and Terng, C.-T.: Development of a flexible data assimilation method in a 3D unstructured-grid ocean model under Earth System Modeling Framework, EGUsphere [preprint], https://doi.org/10.5194/egusphere-2022-114, 2022.</p>"},{"location":"coupling/esmf.html#reporting-bugs-or-requesting-features","title":"Reporting bugs or requesting features","text":"<p>The ESMF cap is still in development.  Please report any errors or annoyances in our bug tracker on https://github.com/schism-dev/schism-esmf/issues.  Also, please request features there, such as additional import or export fields.</p>"},{"location":"coupling/mossco.html","title":"Modular System for Shelves and Coasts","text":"<p>The Modular System for Shelves and Coasts (MOSSCO) is a framework for coupling processes or domains that are originally developed in standalone numerical models. The software MOSSCO implements this infrastructure in the form of a library of components and couplers, and of example coupled applications. The components \"wrap\" external models used in coastal and shelf sciences; these wrapped components are then coupled to each other in the Earth System Modeling Framework (ESMF).</p> <p>The SCHISM ESMF cap integrates with MOSSCO.</p>"},{"location":"coupling/mossco.html#obtaining-and-building-mossco","title":"Obtaining and building MOSSCO","text":"<pre><code>export SCHISM_BUILD_DIR=/my/path/to/schism/build\nexport SCHISM_ESMF_DIR=/my/path/to/schism-esmf\nexport MOSSCO_DIR=/my/path/to/mossco\n\ngit clone https://git.code.sf.net/p/mossco/code $MOSSCO_DIR\n\ncd $MOSSCO_DIR\nmake all install\n</code></pre>"},{"location":"coupling/mossco.html#using-schism-as-part-of-a-mossco-coupled-system","title":"Using SCHISM as part of a MOSSCO coupled system","text":"<p>A simple preconfigured application is available in <code>$MOSSCO_DIR/examples/esmf/schism</code>. To build it, run <code>make</code> in that directory.  You can use the resulting executable as a drop-in replacement for SCHISM's standalone <code>pschism</code> executable, but you need to add the <code>mossco.cfg</code> resource file which overrides <code>param.nml</code> for control parameters of the coupled system, like start and stop time.</p>"},{"location":"coupling/mossco.html#reporting-bugs-or-requesting-features","title":"Reporting bugs or requesting features","text":"<p>The integration of SCHISM into MOSSCO is still in development.  Please report any errors or annoyances in the bug tracker on https://sourceforge.net/p/mossco/tickets/. </p>"},{"location":"coupling/nuopc.html","title":"National Unified Operational Prediction Capability","text":"<p>The National Unified Operational Prediction Capability (NUOPC) is a consortium of Navy, NOAA, and Air Force modelers and their research partners. It aims to advance the weather prediction modeling systems used by meteorologists, mission planners, and decision makers. NUOPC partners are working toward a common model architecture - a standard way of building models - in order to make it easier to collaboratively build modeling systems. To this end, they have developed the NUOPC Layer that defines conventions and a set of generic components for building coupled models using the Earth System Modeling Framework (ESMF).</p> <p>SCHISM can be such a model component within an NUOPC-coupled system.  A so-called \"cap\" wraps SCHISM and exposes it via the NUOPC Application Programming Interface (API).  The interfaces exposed through the API are (1) import of fields, (2) export of fields, and (3) control structure.</p>"},{"location":"coupling/nuopc.html#obtaining-and-building-the-cap","title":"Obtaining and building the cap","text":"<p>The NUOPC and the ESMF caps are jointly hosted in a separate repository on https://github.com/schism-dev/schism-esmf.  It requires that the SCHISM core is built and pointed to by the environment variable <code>$SCHISM_BUILD_DIR</code> </p> <p><pre><code>export SCHISM_ESMF_DIR=/my/path/to/schism-esmf\ngit clone https://github.com/schism-dev/schism-esmf.git $SCHISM_ESMF_DIR\ncd $SCHISM_ESMF_DIR\nmake install-nuopc\n</code></pre> The combined SCHISM and SCHISM-NUOPC libraries, as well as the NUOPC-compliant <code>Makefile</code> snippet <code>schism.mk</code> will be available in the <code>./lib</code> subdirectory.  </p>"},{"location":"coupling/nuopc.html#applications","title":"Applications","text":"<p>The SCHISM NUOPC cap is currently used in the development version of the NOAA Environmental Modeling System (NEMS) CoastalApp.  Within that system, SCHISM is coupled to components for the atmosphere (data or WRF), waves (data or WaveWatch III), and inland water (National Water Model).</p>"},{"location":"coupling/nuopc.html#reporting-bugs-or-requesting-features","title":"Reporting bugs or requesting features","text":"<p>The ESMF cap is still in development.  Please report any errors or annoyances in our bug tracker here. Also, please request features there, such as additional import or export fields.</p>"},{"location":"getting-started/compilation.html","title":"Compilation","text":"<p>Your system must have a FORTRAN and C compiler (and MPI wrapper like mpif90, mpicc), netcdf (version 4.4 or newer is required), python (version 2.7 and above) and perl installed.</p> <p>Two build system is currenlty available - GNU Make and Cmake</p>"},{"location":"getting-started/compilation.html#gnu-make","title":"GNU Make","text":"<p>You need the following two directories for gnu make. <code>src/</code> where the source code resides and  the <code>Makefile</code> which is the main makefile. In general this <code>src/Makefile</code> should not be changed.  In <code>mk/</code>, there are other makefiles <code>Make.defs.*</code> which can be used to provide system specific information (e.g., name  of compilers). </p> <p>You need a <code>mk/Make.defs.local</code> file for compilation. To help you design this file, we have put <code>Make.defs.*</code> which are from various clusters around the world as well as common linux operating systems. You should copy/link one of these to <code>Make.defs.local</code>. For example, if your MPI compiler is Intel based ifort, you may try - </p> <pre><code># Copy\ncp Make.defs.bora Make.defs.myown\n\n# and then link\nln -sf Make.defs.myown Make.defs.local\n</code></pre> <p>Then you need to edit <code>Make.defs.local</code> for e.g. the MPI compiler name, path names for <code>netcdf</code> library  (v4.4 and above preferred) on your local cluster (sometimes you may also need to add <code>FORTRAN</code> support  for netcdf, e.g. <code>\u2013lnetcdff</code>), and name of the executable (<code>EXEC</code>). Also the graph partitioning  lib ParMETIS is compiled each time together with the SCHISM code, and you may need to update the MPI  C compiler names in <code>src/ParMetis-*</code> (consult also <code>INSTALL</code> inside the <code>ParMETIS</code> directory).  Lastly, turn on/off modules in <code>include_modules</code> (note that <code>TVD_LIM</code> should always have a valid value).  Make sure <code>mk/sfmakedepend.pl</code> and <code>mk/cull_depends.py</code> are executable (otherwise make them executable with <code>chmod +x</code>).</p> <p>After all of these are done - </p> <pre><code>cd ../src\nmake clean\nmake pschism\n</code></pre> <p>You might get some errors if you did not use git to clone so the make cannot find the hash information;  ignore it and proceed in making. The final name of executable has the cluster name and also additional suffixes  if you turn on modules: pschism_* (note that you get a preview of this name when you do make clean  so you know which modules you have turned on).</p> <p>Note: the Makefile will automatically invoke <code>Core/gen_version.py</code>, which will generate <code>Core/schism_version.F90</code>, needed for querying the hash/version.</p>"},{"location":"getting-started/compilation.html#cmake","title":"Cmake","text":"<p>The cmake utility is a very powerful way of building the source code and utility script bundle. The main cmake files are found in cmake/. You\u2019ll need two essential files in this directory.</p> <ol> <li><code>SCHISM.local.build</code>: used to toggle on/off optional modules (similar to include_modules used in make).  <code>TVD_LIM</code> should always have a valid value, and BLD_STANDALONE should be ON (to build SCHISM alone; OFF is for building SCHISM as a UFS/ESMF component). All other 'modules' are usually turned off for pure hydrodynamic    applications.    <code>NO_PARMETIS</code>: you can bypass ParMETIS lib by providing instead a domain partitioning map (<code>partition.prop</code>   which is identical to the output from ParMETIS <code>global_to_local.prop</code>) at runtime.    <code>OLDIO</code>: this swtich controls the global outputs. We have implemented asynchronous I/O (aka 'scribed' I/O)   where combined global variables are outputted by dedicated scribes cores. To use this option, <code>OLDIO</code> should   be off, and the user needs to specify number of scribe cores at command line. See 'Running the model' for   more details. If <code>OLDIO</code> is turned on, previous I/O mode (i.e. outputs per MPI process) is used and    the user needs to use post-processing scripts to combine outputs;</li> <li><code>SCHISM.local.cluster_name</code>: similar to Make.defs.local, this file specifies the most important environment    variables like name/path of compiler, netcdf library etc. In general, cmake is quite adept at    inferring some of these variables but sometimes you might need to overwrite the <code>defaults</code> in this file.    You can start from an existing file for a similar cluster e.g. <code>cp -L SCHISM.local.whirlwind SCHISM.local.myown</code></li> </ol> <p>Once these two files are set, run - </p> <pre><code>mkdir ../build\ncd ../build; rm -rf * # Clean old cache\ncmake -C ../cmake/SCHISM.local.build -C ../cmake/SCHISM.local.myown ../src/\n</code></pre> <p>The cmake is essentially a pre-processor for make, and it creates cache files (e.g. build/ CMakeCache.txt,  where you can inspect all env variables). After cmake is done, make can be executed in parallel or in serial mode.</p> <pre><code>make -j8 pschism # efficient parallel build; you can replace \"8\" with number of processes you want\n# or\nmake VERBOSE=1 pschism # serial build with a lot of messages\n</code></pre> <p>The executable (<code>pschism_</code> with extensions) is found in <code>build/bin/</code> and the compiled libraries are in <code>build/lib/</code>. If <code>pschism</code> is omitted above, the main executable and all utility scripts will be built in <code>bin/</code>.</p>"},{"location":"getting-started/getting-sourcecode.html","title":"Getting the source code","text":"<p>SCHISM modeling system is mostly distributed via github. To download the source code it is good idea to have <code>git</code> installed in your system. If you have git, you can download the sourcecode with the following commands - </p> <pre><code>git clone --recurse-submodules https://github.com/schism-dev/schism.git\ncd schism\n</code></pre> <p>This will give you the latest master branch and all submodules inside (e.g. GOTM5). If you want to get certain tagged versions use the <code>tag</code> command of git as (for example) <code>git checkout tags/v5.10.0</code> - for v5.10.0.</p> <p>Note that sometimes you might need to add your system\u2019s ssh public key to your github.com account first before cloning.  If cloning fails, you can also go to https://github.com/schism-dev and directly download the zip files.</p> <p>General users have access to all branches and tags  of the repository (https://github.com/schism-dev/schism). You can find online manuals for the latest stable  master or newer tags after v5.9.0. The developers will constantly update the manuals to keep them up to date as much as possible. </p>"},{"location":"getting-started/grid-generation.html","title":"Mesh generation","text":"<p>UG (unstructured grid or 'mesh') modelling starts with mesh generation, and the latter is often an iterative process. Here lies  the greatest strength and challenges of using an UG model like SCHISM. Fortunately the meshgen tools have come  a long way since 2000s and at the moment we are routinely generating large UGs with millions of nodes and ever  higher resolution, all within a few hours (after the Digital Elevation Model (DEM) has been assembled).</p> <p>Note</p> <p>We will only cover SCHISM specific aspects of gridgen using SMS in this chapter; you are referred to schism.wiki for other info related to DEM preparation etc. Please also refer to Dr. Wood\u2019s thesis for some insight info on using SMS.</p> <p>Important</p> <p>One important point to remember is that mesh generation for SCHISM always starts from raw high-quality DEMs; do NOT use computational grids from another model as DEM because most hydrodynamic models smooth the bathymetry.</p> <p>With some practice and care, you can generate complex UG like Figure 1. A few important things to note  before we dive into details of mesh generation.</p> <ol> <li>SCHISM is an implicit model </li> <li>It can tolerate bad mesh quality (at least it won\u2019t blow up easily)</li> <li>High resolution is and should be used to faithfully capture the main features of DEMs</li> <li>Since we do not smooth or manipulate bathymetry in the model mesh, the model results are sensitive/responsive to    DEM quality. Therefore, make sure the DEM quality is sufficiently good.</li> <li>Establish your workflow starting from mesh generation to model setup so you can easily repeat/iterate.</li> </ol> <p></p> San Francisco Bay &amp; Delta grid (c/o CAL-Department of Water Resource (DWR))."},{"location":"getting-started/grid-generation.html#beware-of-cfl-number","title":"Beware of CFL number","text":"<p>You may be familiar with the CFL restriction associated with explicit (mode-splitting) models \\(\\text{CFL} \\lt 1\\), where the CFL number is defined as -</p> \\[\\begin{equation} \\label{eq01} \\text{CFL} = \\frac{\\left( \\left| \\pmb{u} \\right| + \\sqrt{gh} \\right) \\Delta t}{\\Delta x} \\end{equation}\\] <p>where \\(h\\) is the local water depth, and \\(\\pmb{u}\\) is the flow velocity. Note that the surface wave celerity term is undefined when \\(h \\lt 0\\), and in the shallow area it\u2019s best to drop this term and assume \\(\\left| \\pmb{u} \\right| \\sim 1\\), and therefore \\(\\text{CFL} \\approx \\frac{\\Delta t}{\\Delta x}\\) when \\(h \\lt 0.1\\)m.</p> <p>Being an implicit model using ELM, SCHISM has a somewhat opposite requirement:</p> \\[\\begin{equation} \\label{eq02} \\text{CFL} \\gt 0.4 \\end{equation}\\] <p>You may be able to get away with \\(\\text{CFL}\\gt 0.2\\) in some applications like tsunami. Therefore care must be taken in the mesh generation process; otherwise numerical diffusion in ELM would ruin your results, which may manifest itself in the form of either noise or dissipation. For a given mesh, the errors changes with \\(\\Delta t\\) in a nonlinear manner, as shown in Figure 2.</p> <p></p> Operational range for time step for a given mesh size. <p>The meshgen process for SCHISM therefore starts with a range of time step for your application, We found the  following ranges work for field applications: 100-400s step for barotropic applications, and 100-200s for  baroclinic applications. Eqn. \\(\\ref{eq02}\\) is then used to calculate the \\(coarsest\\) mesh size at each depth  (in anticipation of the smallest possible \\(\\Delta t = 100s\\)). Table 1 shows some examples.  You can see that the inverse CFL restriction is not restrictive.</p> <p>Table 1. Coarsest mesh resolution at sample depths, assuming a \u2018worse case\u2019 scenario of \\(\\Delta t=100s\\).</p> h(m) \\(\\Delta x_{max}\\) (m) 1 790 10 2500 50 5.5e3 100 7.9e3 500 1.7e4 1000 2.5e4 4000 5e4 <p>Three immediate consequences of Eqs. \\(\\ref{eq02}\\) are that - </p> <ol> <li>you do not need to reduce \\(\\Delta t\\) if you refine mesh (yay!)</li> <li>if you have to coarsen mesh, you will have to recheck Eq. \\(\\ref{eq02}\\)</li> <li>if you have to reduce the time step for some reason, you may have to refine mesh</li> </ol> <p>The first consequence embodies the greatest strength (efficiency) of SCHISM as an implicit model. (However, if you  are doing a convergence study, you need to keep the \\(\\text{CFL}\\) number fixed while reducing   the time step (which means you have to reduce the mesh spacing), as is done with explicit models.)   Therefore both explicit and implicit models converge (and are consistent) as \\(\\Delta x, \\Delta t \\rightarrow 0\\) and \\(\\frac{\\Delta x}{\\Delta t} = \\text{constant}\\).</p> <p>Check CFL number in xmgredit5</p> <p>With xmgredit5, you can very easily visualize CFL for the entire grid.</p> <ul> <li><code>xmgredit5 -belel -1.e-10 hgrid.gr3</code>. <code>-belel -1.e-10</code> is used mainly to increase precision for lat/lon grid. if your hgrid.gr3 is in lat/lon, you need to first project it, as the grid size dx in lat/lon is not in meters)</li> <li>Since the CFL inside ACE is calculated without \\(\\pmb{u}\\), and a different form is used for CFL in the shallow \\(h \\lt 0.1m\\), we should impose a min depth of 0.1m, so that \\(\\sqrt{gh} = 1m/s\\). You can do this by - </li> <li>Edit \\(\\rightarrow\\) Edit over grid/regions \\(\\rightarrow\\) Evaluate.</li> <li>In the dialogue box, type <code>depth=max(depth,0.1)</code></li> <li>The Evaluate function is also very useful for generation of other .gr3 files needed by SCHISM</li> <li>Special \\(\\rightarrow\\) Dimensionless numbers.</li> <li>In the right half of the dialogue box, type in 100s (\\(\\Delta t\\)), Warning value (say 0.8), Unacceptable value (say 0.4), press Display filled.</li> <li>The color will appear in the main window, with red indicating good CFL, and green for bad CFL, and orange somewhere in between. You may also 'Display Courant number' but this may take a while to refresh, and so you may want to zoom into a small region first.</li> <li>Small patches of \u2018green\u2019 are OK with SCHISM, especially if they are in shallow area. However, avoid large patches of green in deeper area.</li> <li>Revise your grid accordingly if necessary.</li> </ul> <p>Tsunami simulations</p> <p>In tsunami simulations, \\(\\Delta t\\) has to be small (~1s) due to small wavelength, and you can bypass the CFL condition by turning off advection in deeper depths as the advection is negligible there. You also need to make sure that each wavelength is resolved by at least 20 grid points.</p>"},{"location":"getting-started/grid-generation.html#mesh-quality","title":"Mesh quality","text":"<p>SCHISM\u2019s superior stability means the model is very forgiving in mesh quality; skewness of triangles (defined  as the ratio between the max. side and the equivalent radius) &gt;15 can be used without problem  (the skewness can be easily checked with xmgredit5: Evaluate \\(\\rightarrow\\) Acceptable skewness). However,  for baroclinic applications, mesh quality may be important in critical regions. Also note that  quality quads are required; always use the pre-processing script <code>fix_bad_quads.f90</code> to split bad quads.  (You can check quad quality in xmgredit5 \\(\\rightarrow\\) Edit \\(\\rightarrow\\) Edit over region \\(\\rightarrow\\)   Quality check for quadrangles, and input 0.5 (which is the ratio between the min and max interior angles) for cutoff and \u2018Accept\u2019. All violating elements will be highlighted). In addition, keep the quad aspect ratio (i.e., along-channel/cross-channel) reasonable (&lt;=5).</p> <p>Unlike explicit models, you\u2019ll find meshgen for SCHISM is more \u2018intuitive\u2019 and \u2018freer\u2019.  Implicit model allows you to focus on physics instead of numerics. You are freer to resolve important features  (e.g. jetties) without worrying about cost/instability. SCHISM is not picky about mesh quality  (except for quads). While the physics generally suggests that coarser resolution be used in deeper  depths, this is not always the best practice. E.g., you should resolve the channel to  more accurately represent the salt intrusion process.</p> <p>Barotropic simulation</p> <p>Mesh quality requirement is relatively lax for barotropic simulations. Besides the considerations above, you mainly need to use appropriate resolution based on physics (e.g., generally coarser resolution in deeper depths and finer resolution for shallow depths but make sure channels are resolved/unblocked).  Most important task is to accurately capture the water volume for tide propagation. Remember: you are on implicit UG territory, and so you are free to resolve features as you wish!</p> <p>Baroclinic simulation</p> <p>The transport process is influenced by your choice of mesh, and so the meshgen for baroclinic simulations needs some attention. The mesh quality may need to be better in some critical areas (otherwise you may see noise). Quasi-uniform grid needs to be used in the eddying regime, not for stability but to avoid distortion of eddies (Zhang et al. 2016); gradual transition in resolution should be used as much as possible for eddying regime. Avoiding excessive resolution in high-flow area would speed up the transport TVD solver. Mesh generation process for baroclinic applications requires more effort and is often an iterative process, and so it\u2019s important to establish a good work flow from the start. In a later chapter we will cover some advanced topics on meshing eddying and transitional regimes.</p> <p>Conceptual maps in SMS</p> <p>While there are many methods for creating conceptual maps in SMS, we typically extract representative isobaths (e.g., isobath at the highest gradient that represents slope) first as shapefiles using e.g. GIS tools, and then import the shapefiles into SMS as feature arcs, and specify resolution along each arc based on Table 1. An exmample map is given below. The key is to faithfully capture the main features of DEMs. There are two main types of meshing options in SMS: paving (triangles) and patch (quads) that can be effetively utilized for our purpose.</p> <p> SMS map in a stretch of San Francisco Bay. </p>"},{"location":"getting-started/grid-generation.html#channels-channels-channels","title":"Channels, channels, channels","text":"<p>Channels serve as the main conduit for fresh and ocean water flow, and thus are very   important features for gravitational circulation. When meshing channels, try to use \u2018patch\u2019 method   to generate quads as much as possible for better efficiency and precise control on cross-channel resolution   (and do not round corners (Figure 3)). Use arcs to follow the thalweg and the   steep slopes (highest gradient zone for isobaths). Avoid artificial blocking of channels   (Figure 4), which may lead to noisy flow field, but try to represent the channel   cross section as faithfully as possible to capture the water volume.   There is no need for bathymetry smoothing or other manipulation (and implicitness    allows high resolution on steep slope and skew elements). A good mesh together with    SCHISM\u2019s flexible vertical gridding system \\(LSC^2\\) one can accurately capture the 3D processes. </p> <p></p> Side view of channel representation. Remember SCHISM does not allow partial wet/dry. <p>Patch method</p> <p>It is well known that channelized flow is better simulated using flow-aligned quads.  Therefore we recommend using patch in SMS to mesh channels. This approach allows precise control on the cross-channel resolution which is important for 3D processes. Keep the aspect ratio of quads under 5. Paving, on the other hand, can lead to either excessively large mesh size or inadequate cross-channel resolution.</p>"},{"location":"getting-started/grid-generation.html#meshing-near-wetting-and-drying","title":"Meshing near wetting and drying","text":"<p>You may want to have an arc follow the initial shoreline (but there is no need to be exactly following the shoreline).   Reasonable mesh transition should be done from shoreline to dryland. Use comparable or finer mesh resolution   in the dryland that is expected to be wetted, and then transition to coarser resolution beyond (to account for rare inundation).</p> <p>Simulating wetting and drying well with SCHISM requires some care. A critical parameter in shallow area is the bottom friction. Note that the bottom friction parameterizations are very different between 2D and 3D prisms.</p> <p>From a physical point of view, the 2D and 3D models behave very differently.   Consider a straight channel with variable depths, with flow coming from deeper part and going into shallower part. Figure 5 shows the side views of 2D and 3D velocities.</p> <p></p> Side view of channel flow for (a) 2D and (b) 3D cases. Volume conservation dictates larger velocities in shallow areas. Note that strong shear is possible in 3D model. <p>In 2D model, the velocity is depth-averaged and vertical shear is not represented.   Strong friction directly translates into reduced velocity. In 3D model however,   a large bottom friction will lead to strong shear, although the depth integrated   velocity value matches that from the 2D model. This problem is exacerbated by the   exaggeration of \\(C_d\\) in the shallow if the roughness formula is used (since the bottom  cell thickness is very small). A classical pathological velocity field obtained with SCHISM is seen in Figure 6.</p> <p></p> Noisy velocity field in shallow areas in SCHISM 3D. <p>There are a few approaches to resolve this issue. First, make sure the channel is not blocked. Second,  try to use 2D prisms in shallows (so you can use large friction) with SCHISM \\(LSC^2\\) system.  Using a larger <code>thetai</code> would also stabilize the wetting and drying fronts.   As a last resort if you have to use 3D configuration in shallows,  reduce friction (or even set it to 0).</p> <p>Dredging open boundary</p> <p>A very common crash is related to the wet/dry near the open boundary. SCHISM does NOT allow an entire open boundary segment to become dry at ANY time (while drying at individual nodes is fine).  Therefore you need to make sure the depths there are deep enough compared to expected tidal range.  An easy way is to impose a minimum depth near those segments (which can be done using xmgredit5) if the accuracy near the boundary is not of importance.</p> <p>Since the wet/dry rule inside SCHISM is element-based, a node becomes dry if all of its surrounding   elements become dry. As a result, you may need to impose a minimum depth a couple of rows of elements   into the domain, not just at open boundary nodes. This ensures that water can come into the   domain without being blocked at the open boundary. Note that wet/dry is allowed to occur at   land/island boundaries or interior nodes.</p> <p>Alternative options</p> <p>If you care about wetting and drying near the open boundary location, one option is to relocate the open boundary elsewhere. Also for upstream rivers where depths become negative and you do not want to dredge depths there, you can use the bed deformation option (<code>imm=1</code>): start with a dredged boundary, and then gradually move the bed back to its original location.  The most robust option, however, is to use point sources (<code>if_source=1</code>): in this case no open boundary is required there so wet/dry can happen without crashing the code. However, the open boundary approach is usually more accurate.</p>"},{"location":"getting-started/grid-generation.html#periodic-boundary-condition","title":"Periodic boundary condition","text":"<p>Implementing this type of B.C. in SCHISM introduces some challenges in the barotropic solver because it\u2019d destroy the symmetry of the matrix and cause blowup if the conditioning is sufficiently bad. A workaround is to \u2018drape\u2019 the hgrid onto a sphere to avoid the corresponding open boundary segments altogether. A simple script to guide this process can be found in <code>Utility/Pre-Processing/periodic_grid.f90</code>.</p> <p>DWR tools</p> <p>In the git directory of BayDeltaSCHISM you will find a number of useful python tools for DEM preparation and for aiding the gridgen.</p>"},{"location":"getting-started/post-processing.html","title":"Postprocessing","text":"<p>You can find some useful post-processing tools in the <code>src/Utility</code> directory. </p>"},{"location":"getting-started/post-processing.html#combining-scripts","title":"Combining scripts","text":"<p><code>combine_output11.f90</code> is used to combine process-specific netcdf to global netcdf (under OLDIO).  <code>autocombine_MPI_elfe.pl</code> is a simple perl wrapper script that automatically combines  all available outputs during or after the run. Use these if you invoked <code>OLDIO</code> in make.</p> <p><code>combine_hotstart7.f90</code> is used combine process-specific hotstart outputs (<code>outputs/hotstart_0*.nc</code>)  into <code>hotstart.nc</code>. This is required even if you used scribed I/O (as hotstart outputs are still be emitted per MPI  process).</p> <p><code>combine_gr3.f90</code> is used to combine process-specific <code>maxelev_*</code> and <code>maxdahv_*</code> (ASCII) into <code>maxelev.gr3</code> or <code>maxdahv.gr3</code>.</p>"},{"location":"getting-started/post-processing.html#extraction-analysis","title":"Extraction &amp; analysis","text":"<p><code>read_output*.f90</code>: This group of scripts read multiple nc4 outputs and extract time series of a point,  a slab, a transect etc. They share similar code structure and can be used to understand the nc4 output  format as well as how to do your own processing. You may start from <code>read_output*_xyz.f90</code>.  After you are familiar with these scripts, you can easily customize them for your own purpose.</p> <p>Note that you'll need to use different extraction scripts depending on whether you use scribe I/O or not.  E.g., if you use scribe I/O, the FORTRAN extraction scripts are <code>read_output10*.f90</code>.</p> <p>There are also some analysis scripts, e.g. computing the averaged fields etc.</p>"},{"location":"getting-started/post-processing.html#particle-tracking","title":"Particle tracking","text":"<p>This tool is explained here. </p>"},{"location":"getting-started/post-processing.html#one-way-nesting","title":"One-way nesting","text":"<p><code>OneWayNestScripts/interpolate_variables*.f90</code>: The purpose of this script is to generate <code>elev2D.th.nc</code>,  <code>SAL_3D.th.nc</code>, <code>TEM_3D.th.nc</code> and/or <code>uv3D.th.nc</code> from a large-domain run to be used in a small-domain run.  This is of limited utility now because <code>uv3D.th.nc</code> etc for the sub-tidal component  can be generated using HYCOM or other large-scale models or observation.</p> <p>To prepare for the nesting, first do a 2D barotropic run for a larger or same grid, with only elevation b.c. Note that 2D model is inherently more stable than 3D model, and to further enhance stability, make sure you use <code>indvel=1 (ishapiro=ihorcon=0)</code>, <code>thetai=1</code>, and also use a large Manning\u2019s \\(n\\) (e.g., 0.025 or larger) near the boundary. Once this is done</p> <ol> <li>use interpolate_variables7.f90 to generate *[23]D.th.nc for the small-domain run;</li> <li>use the new *[23]D.th.nc as inputs for the small-domain run.</li> </ol> <p>Note that <code>interpolate_variables.in</code> in the directory are sample inputs for the script. A common mistake is that the parent elements of some open boundary nodes in <code>fg.gr3</code> (i.e. \u2018small-domain\u2019 hgrid) become dry and the script then fails to find a wet element to interpolate from. So make sure all open boundary nodes in <code>fg.gr3</code> are located in wet region of <code>bg.gr3</code>; this is especially important for those nodes near the coast. You can use xmgredit5 to ascertain this. If necessary, modify <code>fg.gr3</code> by moving some nodes to deeper depths.</p>"},{"location":"getting-started/pre-processing.html","title":"Preprocessing","text":"<p>All .gr3 and .prop inputs can be visualized/generated using xmgredit5. For other inputs, you can find some useful pre-proc tools in the src/Utility directory. In general, all of our FORTRAN scripts have a header that explains its purpose, how to use it (inputs/outputs) and sample compilation command.</p>"},{"location":"getting-started/pre-processing.html#grid-conversion","title":"Grid conversion","text":"<p><code>2dm2gr3_m2m.pl</code> and <code>grd2sms.pl</code> : These 2 perl scripts are used to convert between .2dm (SMS) and .gr3.</p>"},{"location":"getting-started/pre-processing.html#interpolation","title":"Interpolation","text":"<p><code>interpolate_unstructured.f90</code>: This efficient script can be used to interpolate depths from .gr3 onto another  .gr3 quickly. It uses a bucket search algorithm along either x or y direction.   To interpolate from raster files (.asc), use <code>interpolate_depth_structured2.f90</code>.</p>"},{"location":"getting-started/pre-processing.html#lsc2-scripts","title":"\\(LSC^2\\) scripts","text":"<p><code>gen_vqs.f90</code> and <code>plot_VQS.m</code>: The FORTRAN script can be used as a start for creating a \\(LSC^2\\) grid and you need to use the matlab script to plot out transects to see if the vertical grid makes sense. You may lump multiple transects into 1 <code>transect.bp</code>. If you want to use this type of vgrid, make sure you go through the FORTRAN script carefully and understand the details.</p>"},{"location":"getting-started/pre-processing.html#nudging-scripts","title":"Nudging scripts","text":"<p><code>gen_nudge.f90</code>, <code>gen_nudge2.f90</code>: the two scripts generate either a simple elliptic nudging zone or a zone with fixed distance from boundary as <code>*_nudge.gr3</code>. </p> <p><code>gen_nudge_from_hycom.f90</code>: This script generates the actual nudge data for tracers <code>*_nu.nc</code> from HYCOM (you may modify this  for other gridded data sources from other structured-grid models).</p>"},{"location":"getting-started/pre-processing.html#hotstart","title":"Hotstart","text":"<p><code>Gen_Hotstart/change_hotstart4.f90</code>: This simple script shows you the internal structure of hotstart.nc and how to manipulate it.</p> <p><code>Gen_Hotstart/gen_*_from_hycom.f90</code>: These scripts show you how to create hotstart.nc and *.th.nc from gridded outputs   like HYCOM. It essentially consists of 3D interpolations.</p>"},{"location":"getting-started/pre-processing.html#sflux_nc","title":"Sflux_nc","text":"<p>The matlab scripts inside Sflux_nc dir show you the structure of sflux*.nc as well as how to generate your own files.</p>"},{"location":"getting-started/pre-processing.html#metis-for-offline-domain-decomposition","title":"METIS for offline domain decomposition","text":"<p>You'll only need to do this if you invoked offline partitioning in compilation (e.g. with <code>NO_PARMETIS</code> turned ON in cmake)  to bypass ParMETIS. If so, you'll need to prepare an input called <code>partion.prop</code> (which is essentially the MPI process # for each element).</p> <p>Step 1: build METIS v5.1.0 by (<code>src/metis-5.1.0</code>) following README inside. You only need gpmetis. </p> <p>Step 2: run a pre-processor for METIS: <code>src/Utility/Grid_Scripts/metis_prep.f90</code>, which only requires <code>hgrid.gr3</code>     (with B.C. parts) and <code>vgrid.in</code>, to get <code>graphinfo</code>;</p> <p>Step 3: run METIS: <code>./gpmetis graphinfo &lt;nproc&gt; -ufactor=1.01 -seed=15</code> </p> <p>where <code>&lt;nproc&gt;</code> is # of     compute cores excluding scribes. The output is <code>graphinfo.part.&lt;nproc&gt;</code>, and then use awk to get <code>partion.prop</code>:</p> <p><code>awk '{print NR,$0}' graphinfo.part.&lt;nproc&gt; &gt; partition.prop</code></p> <p>(replace <code>&lt;nproc&gt;</code> with actual # of cores).</p> <p>(For VIMS users, there is a simple perl wrapper in <code>/sciclone/home10/yinglong/bin/partition_offline.pl</code>)</p>"},{"location":"getting-started/running-model.html","title":"Running the model","text":"<p>The model executable needs to be run inside the folder where all the model input files reside. The following inputs are minimum - </p> <ol> <li>hgrid.gr3</li> <li>vgrid.in</li> <li>param.nml</li> <li>[your_choice_of_bottom_friction].gr3 (drag.gr3, rough.gr3, manning.gr3)</li> <li>bctides.in</li> </ol> <p>The model is usually run through a batch script, which in essence executes the code like:</p> <ul> <li><code>mpirun -np NPROC ./pschism  &lt;# scribes&gt;</code>  (if OLDIO is OFF)</li> <li><code>mpirun -np NPROC ./pschism</code> (if OLDIO is ON)</li> </ul> <p>where NPROC is the number of process used for parallel computing. Note that your system may require   other commands than <code>mpirun</code> or more arguments. You can find example batch scripts in <code>Utility/Cluster_files</code>.</p> <p>Scribed IO</p> <p>Shortly after v5.9.0 we have implemented a new I/O mode called scribed I/O. </p> <p>Under scribed IO mode, the outputs are combined during the model simulation by dedicated \"scribed\" cores. Efficient asynchronous message passing is done inside the code for I/O that minimizes latency.</p> <p>Some details for using scribed IO mode are following:</p> <ul> <li>The user needs to specify at runtime how many 'scribe' cores they want to use. The # of scribes= # of 3D outputs (vectors counted as 2) plus 1 (the one that is used for all 2D variables).</li> <li>Each 3D output has its own netcdf output (e.g. <code>salinity_*.nc</code>) and all 2D outputs share same output <code>out2d_*.nc</code>. Each vector output is split into X,Y components, e.g. <code>horizontalVel[X,Y]_*.nc</code>.</li> <li>The outputs <code>out2d_*.nc</code> and <code>zCoordinates_*.nc</code> are needed for VisIT. </li> <li>Users must specify # of scribes on cmd line as <code>mpirun -np NPROC ./pschism &lt;nscribe&gt;</code>. The specified number can be &gt;= min required based on <code>param.nml</code> and explained above. If not you'll get an error. If you specify more than needed, you waste some cores but otherwise fine.</li> </ul> <p>WWM</p> <p>When running with WWM, make sure to remove <code>fort.*</code> in the directory where hgrid.gr3 is; otherwise the code will try to read in <code>fort.*</code> which may result in NaN error. You can add this into your batch script.</p> <p>Runtime errors due to version change</p> <p>If you get errors when switching to different versions, see here.</p>"},{"location":"getting-started/test_suite.html","title":"Test suite","text":""},{"location":"getting-started/test_suite.html#overview","title":"Overview","text":"<p>SCHISM provides benchmark tests for verifying your installation or new code development.</p> <p>Due to the large file size of these tests, they are distributed via svn. You\u2019ll need svn v1.8 or above (svn manual). Svn clients on linux/unix/windows/Mac should all work.</p> <p>The command to checkout the tests is:</p> <p><code>svn co https://columbia.vims.edu/schism/schism_verification_tests</code></p> <p>(You can also simply use wget to download, but using svn allows easy updates later)</p> <p>Note that the test suite is kept up to date with the latest <code>master branch</code> on the SCHISM's git repo. As a result, there may be some differences (some parameters may have been removed or added) between the param.nml you are using and the one from the verification tests (master branch).  It's important to use a correct <code>param.nml</code> corresponding to the version of SCHISM you are using. A sample param.nml is always provided under your SCHISM source code directory:</p> <p><code>$your_schism_dir/sample_inputs/param.nml</code></p> <p>The latest master version for this input can also be viewed on the Github page. Useful info can be found in the source code bundle <code>src/Readme.beta_notes</code> (including change of format for input files and bug fixes) if you wish to hop among different versions.</p> <p>To ease the burden of beginners who wish to verify their own build of different SCHISM  versions, we have also included a subdirectory <code>Tags</code> in the test suite, in which users can  test all major tag releases with a simple test case (Quarter Annulus).</p>"},{"location":"getting-started/test_suite.html#schism-modules-required-in-the-test-suite","title":"SCHISM Modules required in the test suite","text":"<p>Depending on which verification test you are conducting, you may need to enable certain modules when compiling SCHISM.</p> <p>Here is a reference:</p> Test Module needed Test_Btrack_Cone None Test_Btrack_Gausshill None Test_Btrack_Gausshill_CPU None Test_CORIE None Test_CORIE_LSC2 None Test_COSINE_SFBay None Test_Chezy None Test_Convergence_Grid1 None Test_Convergence_Grid2 None Test_Convergence_Grid3 None Test_Convergence_Grid4 None Test_Convergence_Grid5 None Test_ECO_Toy ECO Test_FABM_COSINE_SFBay FABM Test_Flat_Adjust None Test_GEN_MassConsv GEN Test_GEN_MassConsv2 GEN Test_Geostrophic None Test_HeatConsv_TVD None Test_HeatConsv_Upwind None Test_HeatPool None Test_HydraulicStruct None Test_ICM_ChesBay ICM Test_ICM_UB ICM Test_Inun_CircularIsland_CaseB None Test_Inun_CircularIsland_CaseB_3D None Test_Inun_CircularIsland_CaseB_CPU None Test_Inun_NWaves_2D None Test_Inun_NWaves_3D None Test_MassSource None Test_Nonhydro_Flat_Adjust Nonhydro (not active) Test_Nonhydro_StandingWaves Nonhydro (not active) Test_ParaBowl None Test_QuarterAnnulus None Test_QuarterAnnulus_hvis None Test_SED_Trench_Migration SED Test_SED_meander_2 SED Test_Sed2d_Trench_Migration SED Test_TIMOR_rouse None Test_VolConsv_2D_1 None Test_VolConsv_2D_2 None Test_VolConsv_3D_1 None Test_VolConsv_3D_2 None Test_WWM_Analytical WWM Test_WWM_Duck WWM Test_WWM_L31_2A WWM Test_WWM_VF_adiabatic_case WWM Test_WWM_limon_NODIF WWM Test_Williamson5 None"},{"location":"getting-started/typical-workflow.html","title":"Typical workflow (a cheat sheet)","text":"Typical workflow with SCHISM modeling."},{"location":"getting-started/typical-workflow.html#mesh-generation-tips","title":"Mesh generation tips","text":"<ol> <li>Generate meshes in map projection, not lon/lat; this gives flexibility of setting element size (although    newer SMS versions can now handle distance in lon/lat directly). Distortion due    to projection can be rectified later by projecting back to lon/lat;</li> <li>Make sure major channels are resolved with at least 1 row of \u2018always wet\u2019 elements \u2013 no blockage of major channel flow</li> <li>Always keep the map file and DEM sources and be willing to edit the grid, as often the model results (and sometimes performance) depend on the mesh</li> <li>Being an implicit model with ELM treatment of momentum advection, SCHISM has an <code>operating range</code> for the time step. For field applications, the range is 100-400 sec for barotropic cases, 100-200 sec for baroclinic cases. If you have to reduce the time step, make sure you recheck the inverse CFL criterion again.</li> <li>First estimate the smallest \\(\\Delta t\\) you\u2019d anticipate (e.g., 100s for field applications), and then estimate the coarsest \\(\\Delta t\\) at sample depths to make sure \\(CFL&gt;0.4\\) (cf. Table 5.1).</li> <li>Resolving features is much easier with SCHISM \u2013 be game! Bathymetry smoothing is not necessary.</li> <li>Make sure open boundaries do not become completely dry during simulation </li> <li>[3D simulations with transport] Implicit \\(TVD^2\\) transport is very efficient, but horizontal transport is still explicit  (and is the main bottleneck). Therefore beware of grid resolution in critical regions to avoid  excessive sub-cycling; use upwind in areas of no stratification. Another way to speed up is   to use hybrid ELM and FV by setting <code>ielm_transport=1</code>.</li> <li>Check the following things immediately after a mesh is generated (via ACE/xmgredit5 or scripts)<ul> <li>Minimum area: make sure there are no negative elements (under xmgredit5-&gt;Status).</li> <li>\\(CFL&gt;0.4\\) (at least in \u2018wet\u2019 areas). Note that you need to do this check in map projection (meters), not in lon/lat!</li> <li>Maximum skewness for triangle: use a generous threshold of 17, mainly to find excessive \"collapsed\" elements that originate from the SMS map issues (and fix them in SMS).</li> <li>As a general rule of thumb, SCHISM can comfortably handle elements &gt;= \\(1m^2\\) (\\(10^{-10}\\) in lon/lat), and skewness&lt;=60. Use <code>ACE/xmgredit5</code> or SMS to check these. Most of those extreme elements are due to SMS map issues so you should fix them there.</li> <li>Fix bad quads: fix all bad-quality quads using <code>fix_bad_quads.f90</code> as the last step; use 0.5 (ratio of min and max internal angles) as threshold.</li> </ul> </li> </ol>"},{"location":"getting-started/typical-workflow.html#2d-model-pre-processing","title":"2D model: pre-processing","text":"<ol> <li>Check additional grid issues with a 2D barotropic model with <code>ipre=1</code>, <code>ibc=1</code>, <code>ibtp=0</code><ul> <li>You can cheat without any open boundary segments during this step</li> <li>Remember to <code>mkdir outputs</code> in the run directory</li> </ul> </li> <li>Iterate with mesh generation step to fix any mesh issues.</li> </ol>"},{"location":"getting-started/typical-workflow.html#2d-model-calibration","title":"2D model: calibration","text":"<ol> <li>Start from simple and then build up complexity. Simplest may be a tidal run with a constant Manning\u2019s \\(n\\).</li> <li>Remember most outputs are on a per-core basis if you use OLDIO and need to be combined using the   utility scripts; e.g., for global outputs (schout*.nc), use <code>combine_output11.f90</code> to get global    netcdf outputs that can be visualized by VisIT or other tools; for hotstart, use <code>combine_hotstart7.f90</code>. If you use new   scribe I/O, you don't need to combine global outputs, but still need to combine hotstart outputs.</li> <li>Examine surface velocity in animation mode to find potential issues (e.g. blockage of channels)</li> <li>Negative river flow values for inflow</li> <li>Check all inputs: \u2018junk in, junk out\u2019. There are several pre-processing scripts for this purpose. Xmgredit5 or SMS is very useful also. </li> </ol>"},{"location":"getting-started/typical-workflow.html#3d-model-calibration","title":"3D model: calibration","text":"<ol> <li>The model may need velocity boundary condition at ocean boundary. The easiest approach is to     use FES2014 or TPXO tide package to generate tidal velocity, and use a global ocean model (e.g. HYCOM) to get sub-tidal velocity. Then use type \u20185\u2019 in <code>bctides.in</code>.</li> <li>Avoid large bottom friction in shallow areas in 3D regions</li> <li>Examine surface velocity in animation mode to find potential issues</li> <li>Control the balance between numerical diffusion and dispersion (<code>indvel</code>, <code>ihorcon</code>)</li> <li>Transport solver efficiency may require some experience.</li> <li>\\(LSC^2\\) grid requires some learning/experience, but is a very powerful tool (resembling unstructured grid in the vertical)</li> <li>See Case studies for commonly encountered issues in 3D setup.</li> </ol> <p>Note</p> <p>Another good resource for beginners is a mini live manual by Ms. Christelle Auguste (U. of Tasmania). There is a PDF on there.</p>"},{"location":"getting-started/visualization.html","title":"Visualization","text":""},{"location":"getting-started/visualization.html#visualization-with-matlab","title":"Visualization with Matlab","text":"<p>The directory Utility/Vis_Matlab/ has matlab scripts that can visualize outputs along a horizontal slab (at a fixed  z level or at a sigma level) or vertical transects. In particular, <code>SCHISM_SLAB2.m</code>  and <code>SCHISM_TRANSECT2.m</code> for for   the new scribed outputs, while <code>SCHISM_SLAB.m</code> and <code>SCHISM_TRANSECT.m</code> are for the old outputs (schout*.nc).</p>"},{"location":"getting-started/visualization.html#visualization-with-pylib","title":"Visualization with pylib","text":"<p>pylib provides <code>schismview</code> to visualize outputs (scribed outputs only). <code>schismview</code> will collect all the available variables from your outputs. For each variable, you can do 1). contour plot, 2). transect plot; 3) animation, 4). extract time series, and 5) query, etc. Please report bug to SCHISM maillist or wzhengui@gmail.com.</p>"},{"location":"getting-started/visualization.html#installation-of-pylib","title":"Installation of pylib","text":"<p>By running the following code, you can locate the executable of <code>schismview</code> <code>python -c \"from pylib import *; print(path_scripts+'/schismview')\"</code>. For ealier pylibs versions, use  <code>python -c \"from pylib import *; print(mylib.__file__[:-16]+'Scripts/schismview')\"</code></p>"},{"location":"getting-started/visualization.html#how-to-use-schismview","title":"How to use <code>schismview</code>","text":"<ul> <li> <p>To lauch <code>schismview</code>, you can run the executable either under your run directory, or pass the run directory as a argument to the executable, which will give you an <code>schismview</code> window below.      <li> <p>variable: All availalbe SCHISM output variables are collected, and you can choose the variable you want to view from the list window.</p> </li> <li> <p>figure:  list of figures. You can have multiple figures for different variables. You can close it if you want. Later on, you can retrieve previous figures from the list. If you want to add a new figure, choose add. </p> </li> <li> <p>layer: For 3D variable, you can specify which layer you want to view. For 2D variable, this option is not needed.</p> </li> <li> <p>grid or bnd: If clicked, schism grid/boundary will plotted out along with the contour plot. If you only want to view the grid/boundary, choose <code>none</code> from the variable list.</p> </li> <li> <p>ctr: By default, <code>schismview</code> will use <code>tripcolor</code> to plot contours, which is element-based. If <code>ctr</code> is clicked, <code>schismview</code> will use <code>tricontourf</code> to plot, which can be faster for very large grid.</p> </li> <li> <p>time: There are three available time options (calendar time, SCHISM stack number, or Julian date). You can set the Start and End dates for viewing variables in the textbox. This may be needed for animation if you only want to view for a specific period of time.</p> </li> <li> <p>limit: It sets the lower and upper limits of contours. The values beyond are extended.</p> </li> <li> <p>vector: You can choose vector you want to view from the list. vector shown will be limitted to the current domain specified by <code>xlim</code> and <code>ylim</code>.</p> </li> <li> <p>curve: By <code>right double click</code>, you can add location points for extractng times for the active variable. <code>middle double click</code> will remove the points. Then, click <code>curve</code>, <code>schismview</code> will extract time series in background and the button will display <code>wait</code>. Once <code>wait</code> becomes <code>curve</code> again, clicking on it will show the time series. Note, extracting time series can be very slow for 3D variables depending on how the netcdf outputs are stored (chuncking the files can help, but it is a separate topic beyond <code>schismview</code>). It is better to specify short time range. </p> </li> <li> <p>query: You can query the value of variable. By clicking query (becomes sunken once chosen), you can use <code>middle single click</code> to query the value. By clicking query again, it will exit query mode.</p> </li> <li> <p>xlim/ylim: Sspecify the X/Y axis range.</p> </li> <li> <p>animation</p> <ul> <li><code>|&lt;</code>: go to start time</li> <li><code>&lt;</code>:  go to previous time</li> <li><code>play</code>:  play animation for the current variable. The button will display <code>stop</code>, and click <code>stop</code> will stop the animation. Note <code>doulbe right click</code> will have the same effect of <code>play</code> buttion</li> <li><code>&gt;</code>:  go to next time</li> <li><code>&gt;|</code>: go to end time</li> <li>skip: specify the animation interval</li> </ul> </li> <li> <p>draw: draw plot or refresh the plot.</p> </li> <li> <p>option: Advaned features</p> <ul> <li>command window: type commands to interact with the plot, which can be used to generate desired high-quality figures.</li> <li>save animation</li> <li>show node/element number</li> </ul> </li>"},{"location":"getting-started/visualization.html#visualization-with-visit","title":"Visualization with VisIt","text":"<p>The most comprehensive way to visualize SCHISM nc4 outputs is via VisIt.</p> <p>Shortly after v5.9.0, we have successfully implemented a new mode of efficient I/O using dedicated 'scribes'.  At runtime, the user needs to specify number of scribe cores (= # of 3D outputs variables  (vectors counted as 2) plus 1), and the code, compiled without <code>OLDIO</code>, will output   combined netcdf outputs for each 3D variable and also all 2D variables in <code>out2d*.nc</code>.  Sample 3D outputs are: <code>salinity_*.nc</code>, <code>horizontalVelX_*.nc</code> etc - note that vectors variable names end with <code>X,Y</code>. You can find sample outputs here. Sample outputs using OLDIO (schout*.nc) can be found here.</p> <p>You can download newer versions of VisIt plugins c/o Jon Shu, DWR by following these steps:</p> <p>On Windows 7 or 10</p> <ol> <li>First download VisIt from LLNL site and install. Note the location, which will be in your Windows profile directory if you install for the current user or in <code>Program Files</code> if you install for all users. Note the location.</li> <li>Make sure MS visualc++ 2012 x64 is installed. If not, google it and install and restart (this is required for using multi-core VisIt). If you are using VisIt 3.3.1, you need MS visualc++ 2013 x64 also.</li> <li> <p>Download pre-built plug-in, developed at California Dept of Water Resource</p> <ul> <li>For VisIt v2.13.3</li> <li>For VisIt v3.1.4</li> <li>For VisIt v3.3.1</li> </ul> <p>You need to put the plugin dlls in: <code>%USERPROFILE%\\Documents\\VisIt\\databases</code> (create new folders if necessary), except <code>netcdf_c++.dll</code>. The NetCDF DLL needs to be copied to the VisIt installation directory, which may be <code>%USERPROFILE%\\LLNL\\VisIt 3.3.1</code> if you installed for yourself or the system install directory <code>C:Program Files\\LLNL\\VisIt3.3.1.</code> if you installed for all users.</p> </li> <li> <p>After these steps, you should be able to read in SCHISM outputs in ViSIt; look for <code>SCHISM</code>, <code>gr3</code> format from the dropdown list. To load in vectors, select only the <code>X</code> file.</p> </li> </ol> <p>On Linux Systems</p> <p>Newer versions can be found at the master branch of github.</p> <p>Note</p> <p>Note that the new plugins also work with the old I/O (combined <code>schout*.nc</code>) or even the older binary outputs. To visualize any variables under new I/O with VisIt, you'll always need corresponding <code>out2d*.nc</code>; additionally for any 3D variables, VisIt also needs corresponding <code>zCoordinates*.nc</code>. </p>"},{"location":"getting-started/pre-processing-with-pylib/installation.html","title":"Installation","text":"<p>method 1: user-mode <code>pip install pylibs-ocean</code></p> <p>method 2: developer mode (recommended)  <code>git clone https://github.com/wzhengui/pylibs.git</code> <code>cd pylibs</code> <code>pip install -e .</code></p>"},{"location":"getting-started/pre-processing-with-pylib/overview.html","title":"Overview","text":"<p>pylib provides</p> <ul> <li>a matlab-style platform for python usage</li> <li>and an independent python-based SCHISM modeling workflow</li> </ul> <p>please refer to <code>https://github.com/wzhengui/pylibs</code> for more information.</p> <p> some of pylib basic functions</p> <ul> <li>database usage</li> <li>time manipulation, geometry handling (<code>inside_polygon, near_pts, compute_contour</code>)</li> <li>data analysis: <code>low/band-pass filters, running smooth, FFT, statistics, least-square-fit, EOF, harmonic analysis, etc</code>.</li> <li>handling different file formats: <code>SCHISM inputs/outputs, ASCII files, netcdf, shapefile, Excel, DEM files, projections, etc.</code></li> </ul> <p> some of SCHISM related functions</p> <ul> <li>geometry information: <code>node, element, side, etc.</code></li> <li>hgrid: <code>plot, interplation, boundary, read/save, grid-preprocess (grd2sms, sms2grd, quads check/split, skew-element check, projection)</code></li> <li>vgrid: <code>compute_zcor, etc.</code></li> <li>point/region files</li> <li>post-process: <code>extract time series, profiles, slabs, fluxes, etc.</code></li> <li>visualization of SCHISM inputs/outputs</li> </ul>"},{"location":"getting-started/pre-processing-with-pylib/schismcheck.html","title":"schismCheck (input visualization)","text":"<ul> <li> <p>one can find the location of <code>schismcheck</code> by executing the following code. Then, running it in your schism run directory  <code>python -c \"from pylib import *; print(path_scripts+'/schismcheck')\"</code>. For ealier pylibs versions, use  <code>python -c \"from pylib import *; print(mylib.__file__[:-16]+'Scripts/schismcheck')\"</code></p> </li> <li> <p><code>schismcheck</code> is still under development/testing mode (please report bugs either on SCHISM maillist or to wzhengui@gmail.com), but it is now able to view most of SCHISM inputs in different ways. It is a good way of sanity check for your model inputs. So far, 5 types of inputs are supported (see figures below). </p> </li> <li> <p>dimension operations  the following dimension opertations are provided for the data. <code>schismcheck</code> can only plot 1D or 2D data, which will plot as time series, 2D contour plot, or scatter plot.  </p> <ol> <li><code>all</code>:   extract all data along dimension</li> <li><code>mean</code>:  compute mean value along dimension</li> <li><code>min</code>:   compute minimum value along dimension</li> <li><code>max</code>:   compute maximum value along dimension</li> <li><code>sum</code>:   compute sum of value along dimension</li> <li><code>number (0-n)</code>: extract data slice along dimension note: <code>all</code> operation will add an one dimension to your data to be plotted. </li> </ol> </li> <li> <p><code>*.gr3, hgrid.ll, *.ic, *.prop</code>: Plot value as contour. SCHISM grid and boundary can be superposed.         <li> <p><code>*_nu.nc, *_th.nc</code>: After data (1D or 2D) is extracted, it will be plotted as time series or 2D contour. For nudge 1D data, it can also be plotted on schism grid.         <li> <p><code>hotstart.nc</code>: data will be plotted as time series or 2D contour; For 1D data with dimension=node or elem, it will be plotted as contours on schism grid.         <li> <p><code>source.nc or source_input (source_sink.in, vsource, msource, vsink)</code>: data will be plotted as time series or 2D contour; For 1D data with dimension=source_number, it can be plotted as scatter points on schsim grid.         <li> <p><code>*.th</code>: data will be plotted as time series (1D data) or 2D contour (2D data)"},{"location":"getting-started/pre-processing-with-pyschism/atmos.html","title":"Atmospheric forcing","text":"<p>The sflux/ directory is required if nws=2 in param.nml. </p> <p>There are four types of files needed:</p> <p>sflux_input.txt (required): a namelist file</p> <p>sflux_air_1.[1-].nc (required): NetCDF files that have time (in days), wind speed at 10m above MSL (u, v), air temperatue and spedific humidity at 2m above MSL, sea level pressure;</p> <p>sflux_prc_1.[1-]nc (needed if isconsv=1): NetCDF files that have time and precipitation rate;</p> <p>sflux_rad_1.[1-].nc (needed if ihconsv=1): NetCDF files that have time, downward longwave and shortwave radiation fluxes.</p> <p>PySCHISM supports three types of atmpsheric datasets.</p> <p>Notes: startdate should be one day earlier than the actual run startdate, because there is no data at t00z. Acoordingly, add two more extra days for rnday in the following scripts.</p>"},{"location":"getting-started/pre-processing-with-pyschism/atmos.html#ecmwf-era5","title":"ECMWF ERA5","text":"<p>ERA5 provides hourly estimates of a large number of atmoshperic, land and oceanic climate variables. The data cover the Earth on a 30km grid and resolve the atmoshpere using 137 levels from the surface up to a height of 80km. The dataset covers from 1950 to present. PySCHISM downloads ERA5 data through CDS API service. To do so, you need to install CDS API package. Here is the instruction about how to install the package.</p> <p>The python script to generate sflux file from ERA5 is as follows: <pre><code>from datetime import datetime\nimport pathlib\n\nfrom pyschism.mesh.hgrid import Hgrid\nfrom pyschism.forcing.nws.nws2.era5 import ERA5\n\nif __name__ == '__main__'\n    startdate=datetime(2022, 4, 1)\n    rnday = 10\n    hgrid=Hgrid.open('./hgrid.gr3',crs='EPSG:4326')\n    bbox = hgrid.get_bbox('EPSG:4326', output_type='bbox')\n    outdir = pathlib.Path('./')\n\n    er=ERA5()\n    er.write(outdir=outdir, start_date=startdate, rnday=rnday, air=True, rad=True, prc=True, bbox=bbox, output_interval=interval, overwrite=True)\n</code></pre></p>"},{"location":"getting-started/pre-processing-with-pyschism/atmos.html#gfs","title":"GFS","text":"<p>The Global Forecast System (GFS) is weather forecast model produced by the National Centers for Environmental Prediction (NCEP). PySCHISM uses data hosted on AWS S3 bucket.</p> <p>The python script to generate sflux from GFS is as follows: <pre><code>from datetime import datetime\n\nfrom pyschism.mesh.hgrid import Hgrid\nfrom pyschism.forcing.nws.nws2.gfs2 import GFS\n\nif __name__ == '__main__':\n    startdate = datetime(2022, 3, 31)\n    rnday = 10\n    record = 1\n    hgrid = Hgrid.open('./hgrid.gr3', crs='epsg:4326')\n    pscr = '/sciclone/pscr/lcui01/GFS/'\n    gfs = GFS(start_date=startdate, rnday=rnday, pscr=pscr, record=record, bbox=hgrid.bbox)\n</code></pre> Parameter startdate should be one day earlier than the actual startdate in the param.nml becasue GFS have nodata at t00, pscr is the pre-generated directory to save dowloaded raw data (grib2), record is to specify how many days in each file. For hindcast, recommend record=1. For forecast, the maximum is 5, because GFS has 5-day forecast.</p>"},{"location":"getting-started/pre-processing-with-pyschism/atmos.html#hrrr","title":"HRRR","text":"<p>The HRRR is a NOAA real-time 3-km resolution, hourly updated, cloud-resolving, convection-allowing atmospheric model. The AWS archived data starts from August 2014 to present.</p> <p>The python script to generate sflux from HRRR is as follows: <pre><code>from datetime import datetime\n\nfrom pyschism.mesh.hgrid import Hgrid\nfrom pyschism.forcing.nws.nws2.hrrr3 import HRRR\n\nif __name__ == '__main__':\n    startdate = datetime(2022, 3, 31)\n    rnday = 10\n    record = 1\n    hgrid = Hgrid.open('../../../data/hgrid.gr3', crs='epsg:4326')\n    pscr='/sciclone/pscr/lcui01/HRRR/'\n\n    hrrr = HRRR(start_date=startdate, rnday=rnday, pscr=pscr, record=record, bbox=hgrid.bbox)\n</code></pre> Parameter startdate, pscr, and record are defined the same as GFS', except for forecast, the maximum of record for HRRR is 2, because HRRR only has 2-day forecast.</p>"},{"location":"getting-started/pre-processing-with-pyschism/bctides.html","title":"Bctides","text":"<p>Please refer to this page for detailed horizontal B.C. and nudging options supported by SCHISM.</p> <p>PySCHISM supports both TPXO and FES2014 tidal database. Please download the data (you may need to register) and save it as:</p> <p>For TPXO:      ~/.local/share/tpxo/h_tpxo9.v1.nc      ~/.local/share/tpxo/u_tpxo9.v1.nc</p> <p>For FES2014:     ~/.local/share/fes2014/eastward_velocity/     ~/.local/share/fes2014/northward_velocity/     ~/.local/share/fes2014/ocean_tide_extrapolated/  </p> <p>Bctides class:  <pre><code>arguments:\n    hgrid: required, hgrid.ll (lon/lat)\n    flags: requried, bctypes for each boundary [[iettype, ifltype, itetype, isatype], [...], [...], ...]\n    constituents: optional, default is \"major\", which is eight major tidal constituents\n    dabase: optional, default is \"tpxo\"\n    add_earth_tidal: optional, default is True\n    cutoff_depth: optional, default is 50.0\n    ethconst: optional, needed when using constant elevation along the boundary (iettype=2), which is given as [v1, v2, v3, ...]\n    vthconst: optional, needed when using constant discharge (ifltype=2)\n    tthconst: optional, needed when using constant temperatur (itetype=2)\n    sthconst: optional, needed when using constant temperature (isatype=2)\n    tobc: optional, nudging factor, needed when itetype is not 0, [v1, v2, v3, ...]\n    sobc: optional, nudging factor for salinity, needed when isatype is not 0, [v1, v2, v3, ...]\n    relax: optional, needed when ifttype=-4, [rel1, rel2]\n</code></pre> Below shows an example script to generate bctides.in for hgrid with three open boundaries (2 ocean + 1 river). Bctypes for ocean boundaries are [5, 5, 4, 4], and for river is [0, 1, 1, 2]:</p> <pre><code>from datetime import datetime\nimport numpy as np\n\nfrom pyschism.mesh import Hgrid\nfrom pyschism.forcing.bctides import Bctides\n\nif __name__ == '__main__':\n    start_date = datetime(2017, 12, 1)\n    rnday = 396\n    bctypes = [[5, 5, 4, 4], [5, 5, 4, 4], [0, 1, 1, 2]]\n    constituents = 'major'\n    database = 'tpxo'\n    earth_tidal_potential = True\n    sthconst = [np.nan, np.nan, 0]\n    tobc = [0.5, 0.5, 1]\n    sobc = [0.5, 0.5, 1]\n    outdir = './'\n    hgrid = Hgrid.open(\"./hgrid.gr3\", crs=\"epsg:4326\")\n\n    bctides = Bctides(\n        hgrid = hgrid,\n        flags = bctypes,\n        constituents = constituents,\n        database = database,\n        add_earth_tidal = earth_tidal_potential,\n        sthconst = sthconst,\n        tobc = tobc,\n        sobc = sobc,\n    )\n\n    bctides.write(\n        outdir, \n        start_date=start_date, \n        rnday=rnday, \n        overwrite=True,\n    )\n</code></pre>"},{"location":"getting-started/pre-processing-with-pyschism/boundary.html","title":"Boundary Condition from HYCOM","text":"<p>Please refer to this page for detailed horizontal B.C. and nudging options supported by SCHISM.</p> <p>Generating elev.2D.th.nc, SAL_3D.th.nc, TEM_3D.th.nc, and uv3D.th.nc: <pre><code>from datetime import datetime\n\nfrom pyschism.mesh.hgrid import Hgrid\nfrom pyschism.forcing.hycom.hycom2schism import OpenBoundaryInventory\n\nif __name__ == '__main__':\n    start_date = datetime(2022, 4, 1)\n    rnday = 10\n    hgrid = Hgrid.open('./hgrid.gr3', crs='epsg:4326')\n    vgrid = './vgrid.in'\n    outdir = './'\n    bnd = OpenBoundaryInventory(hgrid, vgrid)\n    bnd.fetch_data(outdir, start_date, rnday, elev2D=True, TS=True, UV=True)\n</code></pre> Generating SAL_nu.nc and TEM_nu.nc for nudging: <pre><code>from datetime import datetime\n\nfrom pyschism.mesh import Hgrid\nfrom pyschism.forcing.hycom.hycom2schism import Nudge\n\nif __name__ == '__main__':\n    start_date = datetime(2022, 4, 1)\n    rnday = 10\n    hgrid = Hgrid.open('./hgrid.gr3', crs='epsg:4326')\n    vgrid = './vgrid.in'\n    outdir = './'\n\n    nudge=Nudge()\n    nudge.fetch_data(outdir, hgrid, vgrid, start_date, rnday)\n</code></pre> This script also generates nudging coefficient files SAL_nu.gr3 and TEM_nu.gr3.</p>"},{"location":"getting-started/pre-processing-with-pyschism/installation.html","title":"Installation","text":"<p>Setting up a conda environment is recommended to install PySCHISM. Please refer here for how to install Miniconda.</p> <p>Create conda environment:  <pre><code>conda create -n pyschism python=3.9\n</code></pre></p>"},{"location":"getting-started/pre-processing-with-pyschism/installation.html#from-github-repo","title":"From GitHub repo","text":"<pre><code>conda activate pyschism\ngit clone https://github.com/schism-dev/pyschism.git\ncd pyschism\npip install .     # install as a user\n# OR\npip install -e .  #install as a developer\n</code></pre>"},{"location":"getting-started/pre-processing-with-pyschism/installation.html#python-package-from-pypi","title":"Python package from PyPI","text":"<p>Get the package with:  <pre><code>pip3 install pyschism\n</code></pre></p>"},{"location":"getting-started/pre-processing-with-pyschism/nwm.html","title":"National Water Model","text":"<p>NOAA NWM CONUS Retrospective Dataset is to provide streamflow when if_source=1 is defined in param.nml. This dataset covers from February 1979 to present, combination of different versions of NWM dataset. These four files are needed:  source_sink.in   vsource.th  vsink.th   msource.th</p> <p>The python script to generate these files is as follows: <pre><code>from datetime import datetime\n\nfrom pyschism.mesh import Hgrid\nfrom pyschism.forcing.source_sink.nwm import NationalWaterModel, NWMElementPairings\n\nif __name__ == '__main__':\n    startdate = datetime(2022, 4, 4)\n    rnday = 10\n    hgrid = Hgrid.open(\"./hgrid.gr3\", crs=\"epsg:4326\")\n    sources_pairings = pathlib.Path('./sources.json')\n    sinks_pairings = pathlib.Path('./sinks.json')\n    output_directory = pathlib.Path('./')\n\n    cache = pathlib.Path(f'./{startdate.strftime(\"%Y%m%d\")}')\n    cache.mkdir(exist_ok=True, parents=True)\n\n    if all([sources_pairings.is_file(), sinks_pairings.is_file()]) is False:\n        pairings = NWMElementPairings(hgrid)\n        sources_pairings.parent.mkdir(exist_ok=True, parents=True)\n        pairings.save_json(sources=sources_pairings, sinks=sinks_pairings)\n    else:\n        pairings = NWMElementPairings.load_json(hgrid, sources_pairings, sinks_pairings)\n\n    nwm=NationalWaterModel(pairings=pairings, cache=cache)\n    nwm.write(output_directory, hgrid, startdate, rnday, overwrite=True)\n</code></pre></p>"},{"location":"getting-started/pre-processing-with-pyschism/overview.html","title":"Overview","text":"<p>PySCHISM is a python based package for preparing most inputs required of 3D baroclinic SCHISM run, driven by TPXO, HYCOM, NWM, and  a few pre-selected atmospheric models (ERA5, GFS, and HRRR). PySCHISM has its own repository. The syntax of classes and methods in the library are subject to change in future releases, which will also significantly optimize performace and speed of some functionalities.</p>"},{"location":"input-output/bctides.html","title":"Boundary conditions (bctides.in)","text":"<p>Please refer to sample bctides.in in the source code directory when you read this. The following table summarizes all horizontal B.C. and nudging options supported by SCHISM. The format for other necessary input files are decribed in the Optional inputs section.</p> Variable Type 1 (<code>*.th</code>) Type 2 Type 3 Type 4 (<code>*[23]D.th</code>) Type 5 Type -1 Type -4, -5 (<code>uv3D.th</code>); Nudging Nudging/Sponge layer near bnd \\(\\eta\\) <code>elev.th</code>; Time history; uniform along bnd constant Tidal amp/phases <code>elev2D.th.nc</code>: time- and space- varying along bnd <code>elev2D.th.nc</code>: sum of 3 and 4 Must = 0 N\\/A <code>inu_elev=1</code> S&amp;T, Tracers <code>[MOD]_[ID].th</code>: relax to time history (uniform along bnd for inflow) Relax to specified value for inflow Relax to i.c. for inflow <code>[MOD]_3D.th.nc</code>: relax to time- and space- varying values along bnd during inflow N/A N/A N/A <code>inu_[MOD]=1 or 2</code> u,v <code>flux.th</code>: via discharge ( &lt;0 for inflow!) Via dischage (&lt;0 for inflow) Tidal amp/phases for u and v components <code>uv3D.th.nc</code>: time- and space- varying along bnd (in lon/lat for <code>ics=2</code>) <code>uv3D.th.nc</code>: sum of 3 and 4 Flather (0 for \\(\\eta\\)) Relax to <code>uv3D.th.nc</code> (2 separate relaxations for in and outflow) <code>inu_uv=1</code> <p>Following is a psudo code to explain the structure of <code>bctides.in</code> for different types of boundary conditions listed above. Spaces between lines are added for clarity.</p> <p><pre><code>&lt;you notes&gt; !Not used in code; write your own comments\n\nntip tip_dp !# of constituents used in earth tidal potential; cut-off depth for applying tidal potential (i.e., it is not calculated when depth &lt; tip_dp).\n\nfor k=1, ntip\n    talpha(k) !tidal constituent name\n    jspc(k), tamp(k), tfreq(k), tnf(k), tear(k) !tidal species # (0: declinational; 1: diurnal; 2: semi-diurnal), amplitude constants, angular frequency, nodal factor, earth equilibrium argument (in degrees);\nend for\n\nnbfr !total # of tidal boundary forcing frequencies\n\nfor k=1, nbfr\n    alpha(k) !tidal constituent name\n    amig(k), ff(k), face(k) !angular frequency (rad/s), nodal factor, earth equilibrium argument (in degrees) for constituent\nend for\n\nnope !# of open boundary segments\nfor j=1, nope\n    neta(j), iettype(j), ifltype(j), itetype(j), isatype(j), (optional) itrtype(j) !# of nodes on the open boundary segment j (corresponding to hgrid.gr3), B.C. flags for elevation, velocity, temperature, and salinity, and (optionally) for each tracer module invoked (in the order of GEN, AGE, SED3D, EcoSim, ICM, CoSiNE, FIB, and TIMOR)\n\n    ! Elevation B.C. section\n    if (iettype(j) == 1) !time history of elevation on this boundary\n        !no input in bctides.in; time history of elevation is read in from elev.th (ASCII);\n    else if (iettype(j) == 2) !this boundary is forced by a constant elevation\n        ethconst !constant elevation value for this segment\n    else if (iettype(j) == 3) !this boundary is forced by tides\n        for k=1, nbfr\n            alpha(k) !tidal constituent name\n            for i=1, nond(j) !loop over all open boundary nodes on this segment\n                emo((j,i,k) efa (j,i,k) !amplitude and phase for each node on this open boundary\n            end for i\n        end for k\n    else if (iettype(j) == 4) !space- and time-varying input\n        !no input in this file; time history of elevation is read in from elev2D.th.nc (netcdf);\n    else if (iettype(j) == 5) !combination of \u20183\u2019 and \u20184\u2019\n        !time history of elevation is read in from elev2D.th.nc, and then added to tidal B.C. specified below\n        for k=1, nbfr\n            alpha(k) !tidal constituent name\n            for i=1, nond(j) !loop over all open boundary nodes on this segment\n                emo((j,i,k) efa(j,i,k) !amplitude and phase for each node on this open boundary\n            end for i\n        end for k\n    else if (iettype(j) == 0)\n        !elevations are not specified for this boundary (in this case the velocity must be specified).\n    end if\n\n    ! Velocity B.C. section\n    if (ifltype(j) == 0) !vel. not specified\n        ! no input needed\n    else if (ifltype(j) == 1) !time history of discharge on this boundary\n        ! no input in this file; time history of discharge is read in from flux.th (ASCII)\n    else if (ifltype(j) == 2) !this boundary is forced by a constant discharge\n        vthconst !constant discharge (note that a negative number means inflow)\n    else if (ifltype(j) == 3) !vel. (not discharge!) is forced in frequency domain\n        for k=1, nbfr\n            alpha(k) !tidal constituent name\n            for i=1, nond(j) !loop over all open boundary nodes on this segment\n                umo(j,i,k) ufa(j,i,k) vmo(j,i,k) vfa(j,i,k) !amplitude and phase for (u,v) at each node on this open boundary\n            end for i\n        end for k\n    else if (ifltype(j) == 4 or -4) !3D input\n        !time history of velocity (not discharge!) is read in from uv3D.th.nc (netcdf)\n        if ifltype(j)==-4)\n            rel1 rel2 !relaxation constants for inflow and outflow (between 0 and 1 with 1 being strongest nudging)\n        end if\n    else if (ifltype(j) == 5) !combination of \u20184\u2019 and \u20183\u2019\n        ! time history of velocity (not discharge!) is read in from uv3D.th.nc (netcdf) and then added to tidal velocity specified below\n        for k=1, nbfr\n            alpha(k) !tidal constituent name\n            for i=1, nond(j) !loop over all open boundary nodes on this segment\n                umo(j,i,k) ufa(j,i,k) vmo(j,i,k) vfa(j,i,k) !amplitude and phase for (u,v) at each node on this open boundary\n            end for i\n        end for k\n    else if (ifltype(j) == -1) !Flather type radiation b.c. (iettype must be 0 in this case)\n        'eta_mean' !comment only - mean elevation below\n        for i=1,nond(j) !loop over all nodes\n            eta_m0(i) !mean elev at each node\n        end for i\n        'vn_mean'!comment only - mean normal velocity below\n        for i=1,nond(j)\n            qthcon(1:Nz,i,j) !mean normal velocity at the node (at all levels)\n        end for i\n    end if\n\n    ! Temperature B.C. section\n    if (itetype(j) == 0) !temperature not specified\n        ! no input needed\n    else if (itetype(j) == 1) !time history of temperature on this boundary\n        tobc !nudging factor (between 0 and 1 with 1 being strongest nudging) for inflow; time history of temperature will be read in from TEM_1.th (ASCII)\n    else if (itetype(j) == 2) !this boundary is forced by a constant temperature\n        tthconst !constant temperature on this segment\n        tobc !nudging factor (between 0 and 1) for inflow\n    else if (itetype(j) == 3) !initial temperature profile for inflow\n        tobc !nudging factor (between 0 and 1) for inflow\n    else if(itetype(j) == 4) !3D input\n        tobc !nudging factor (between 0 and 1); time history of temperature is read in from TEM_3D.th.nc (netcdf)\n    end if\n\n    ! Salinity B.C. section\n    ! Similar to temperature above\n    if (isatype(j) == 0) !salinity not specified\n        .........\n    endif\n\n    ! If any tracer module is invoked, you also need the corresponding B.C. part for each tracer module, and the structure is similar to temperature. \n    !However, if the tracer module has multiple classes (which is the case for most modules; e.g.,  AGE, SED etc), \n    !you need to specify the concentration constants (under `2` etc) for all classes in 1 row. In later sections \n    !we will give examples for `.nc` inputs.\n\nend for !j: open boundary segment\n</code></pre> </p> <p>The following two samples provide more direct views on the structure of bctides.in. </p> <p>Sample 1 illustrates how to set Type 1 (Time history; uniform along bnd) and Type 2 (Constant) boundaries:  </p> <p>Sample 2 illustrates how to set a Type 3 (tidal) boundary:  </p> <p>Note on AGE module</p> <p>The number of tracers inside this module (<code>ntracer_age</code>) must be an even number, and usually you only specify the first <code>ntracer_age/2</code> tracers on some open boundaries. For example, suppose <code>ntracer_age=4</code>, you can set the B.C. flags as:</p> <pre><code>3 !nope\n88 3 0 0 0 0 !ocean \u2013 no age tracer b.c. here\n....\n5 0 1 1 3 2 !Columbia River\n1. !relax for T\n1. !relax for S\n1. 0. 0. 0. !inject age tracer #1 here\n1. !relax for AGE\n3 0 2 3 3 2 !Fraser River\n1. !relax for T\n1. !relax for S\n0. 1. 0. 0. !inject age tracer #2 here\n1. !relax for AGE\n</code></pre> <p>Note</p> <p><code>bctides.in</code> is one of the most error prone inputs for users due to its rigid formatting requirements. One useful trick to quickly find out the  error location is to deliberately crash the code by placing illegal choices along this input to help isolate the errors (think of bi-section method). For example, you can intentionally set an illegal B.C. flag of <code>6</code> at a segment to see if the code crashes before or after this point.</p> <p>Note</p> <p>The tidal amplitudes and phases can be generated using utility scripts in the <code>Tides</code>.</p>"},{"location":"input-output/friction.html","title":"Bottom friction","text":"<p>Bottom friction can be provided in three types of file - <code>drag.gr3</code>, or <code>rough.gr3</code> or <code>manning.gr3</code>. The \u2018depth\u2019 value in Gr3 file means \\(C_d\\), bottom roughness in meters, or Manning\u2019s \\(n\\), respectively. The 3 files correspond to <code>nchi=0,1,-1</code>.</p> <p>Bottom friction is a critical parameter in shallow area. Note that the bottom friction parameterizations are  very different between 2D and 3D model, and so you cannot use same input. For details please read  this article.</p> <p>Further information can be found here.</p>"},{"location":"input-output/hgrid.html","title":"Horizontal grid (hgrid.gr3)","text":"<p>The format of this file is shown below. It has 4 part.</p> <p>First part of the file is the information -  <pre><code>hgrid.gr3 ! alphanumeric description; ignored by code\n60356 31082 ! # of elements and nodes in the horizontal grid\n</code></pre></p> <p>Second part is the node info. <pre><code>1 402672.000000 282928.000000 2.0000000e+01 ! node #, x,y, depth\n2 402416.000000 283385.000000 2.0000000e+01\n3 402289.443000 282708.750000 2.0000000e+01\n4 402014.597000 283185.897000 2.0000000e+01\n.............................................\n31082 331118.598253 112401.547031 2.3000000e-01 !last node\n</code></pre></p> <p>Third part is the connectivity table. <pre><code>1 4 1 2 3 101 ! element #, element type (triangle or quad), nodes 1-4\n2 3 2 4 3\n3 3 4 5 3\n...........................................\n60356 3 26914 30943 26804 !last element\n</code></pre></p> <p>The last part is the list of open and land boundary segments. This part is needed for hgrid.gr3 only; not needed for other .gr3 files.</p> <pre><code>3 = Number of open boundaries\n95 = Total number of open boundary nodes\n3 = Number of nodes for open boundary 1\n29835 ! first node on this segment\n29834 ! 2nd node on this segment\n.\n.\n.\n30001 !last node on this segment\n90 = Number of nodes for open boundary 2\n.\n.\n.\n16 = number of land boundaries (including islands)\n1743 = Total number of land boundary nodes\n753 0 = Number of nodes for land boundary 1 ('0' means the exterior land boundary)\n30381 ! first node on this segment\n.......................................\n1 !last node on this segment\n741 0 ! Number of nodes for land boundary 2 ('0' means the exterior boundary)\n.\n.\n.\n10 1 = Number of nodes for island boundary 1 ('1' means island)\n29448 ! first node on this island\n.\n.\n.\n29449 !last node on this island (note this is different from the first node \u201829448\u2019 above)\n</code></pre> <p></p> Horizontal grid and boundary segments.. <p>Note</p> <ol> <li>Land and Ocean boundary sagment can be generated with xmgredit5 \\(\\rightarrow\\) GridDEM \\(\\rightarrow\\) Create open/land boundaries; it can also be generated with SMS;</li> <li>If you have no open boundary, you can create two land boundary segments that are linked to each other. Likewise, if you have no land boundary, you should create two open boundary segments that are connected to each other;</li> <li>Although not required, we recommend you follow the following convention when generating the boundary segments. For the exterior boundary (open+land), go in counter-clockwise direction. With xmgredit5, the island boundaries are automatically created once you have finished designating all open and land segments on the exterior boundary. At the moment xmgredit5 cannot generate open boundary segments on islands. You cna use SMS or some python tools for this;</li> <li>Note that this format is the same as fort.14 of ADCIRC; keep an eye on the land boundary sagment, where instead of 741 0 in the above example SMS will produce <code>741 10</code>. At the moment, the flags for land/island boundaries are not used in SCHISM system except for WWM (see below);</li> <li>If WWM is used, the land boundary flags (cf. bold texts above) are required, and also there must not be any open boundary segments on any island. Therefore if you use WWM, make sure the exterior land boundary flags are <code>0</code> and island boundary flags are non-zero;</li> <li>Since WWM can only handle triangles, the mixed grid needs to be converted to a pure triangular grid for WWM using a pre-processing script <code>Pre-Processing/split_quads_wwm.f90</code>.</li> </ol>"},{"location":"input-output/optional-inputs.html","title":"Optional inputs","text":"<p>This section explains the details of some options inputs triggered by <code>param.nml</code>. The list is non-exhaustive as there  are many such inputs. You can also find some example in test suite.</p>"},{"location":"input-output/optional-inputs.html#hgridll","title":"hgrid.ll","text":"<p>The format is the same as hgrid.gr3, except that the B.C. part is not necessary. The x,y of each node are replaced by lon/lat coordinates. If your model is already prepared in lon-lat, then, this file can be provided by simply making a soft-link to the hgrid.gr3 file.</p>"},{"location":"input-output/optional-inputs.html#gr3","title":".gr3","text":"<p>The format is the same as <code>hgrid.gr3</code>, except that the B.C. part is not necessary. The only difference between .gr3 files is that the \u2018depth\u2019 means different variables. We show some examples below. Some such inputs are generated by scripts (e.g. <code>shapiro.gr3</code>, <code>SAL_nudge.gr3</code>).</p> <p>diffmin.gr3 and diffmax.gr3: the \u2018depth\u2019 specifies the min/max of the viscosity or diffusivity. Needed if <code>itur=3 or 4</code>. Suggested value: \\(1.e-6 m^2/s\\) for diffmin and \\(1 m^2/s\\) (or larger) for diffmax.</p> <p>albedo.gr3 and watertype.gr3: required if <code>ihconsv=1</code>, specifying the albedo (e.g. 0.1) and water type for attenuation rate of solar radiation. E.g., '1' is Jerlov type I (clean water), '5' is Jerlov type III etc. Consult <code>schism_step.F90</code> for more details. '7' has largest attenuation rate (muddy water).</p> <p>adv.gr3: Required if <code>nadv=0</code>. The \u2018depth\u2019 is either <code>0</code>, <code>1</code> or <code>2</code> in this case, corresponding to where the momentum advection is turned off, using backward Euler, or using 2nd-order Runge-Kutta method at a node.</p> <p>krvel.gr3: Required if <code>inter_mom=-1</code>. The \u2018depth\u2019 is either <code>0</code>, <code>1</code>, corresponding to kriging ELM bring turned off/on. The generalized covariance function is specified by <code>kr_co</code>.</p> <p>bdef.gr3: Required if <code>imm=1</code>. The \u2018depth\u2019 specifies the amount of bed deformation (in meters) during time step 1 to <code>ibdef</code>, with positive values being uplift.</p>"},{"location":"input-output/optional-inputs.html#th-ascii","title":".th (ASCII)","text":"<p>This includes <code>elev.th</code>, <code>flux.th</code>, <code>TEM_1.th</code>, <code>SAL_1.th</code> etc, which share same ASCII structure. Below is a sample flux.th (note that negative values mean inflow!)</p> <pre><code>0. -1613.005 -6186.0 !time (in sec), discharge at the 1st boundary segment that has ifltype=1 (in bctides.in), discharge at the 2nd boundary segment with ifltype=1, etc\n300. -1613.05005 -6186.60156\n600. -1611.37854 -6208.62549\n900. -1609.39612 -6232.22314\n</code></pre> <p>Notes</p> <ul> <li>Note that the time must start from 0, and the (uniform) step (in sec) can be anything <code>\u2265dt</code>.</li> <li>The '1' in <code>TEM_1.th</code> refers to the 1 (and only) tracer class in the temperature module;</li> <li>In the case of wind.th (with <code>nws=1 or 4</code>), the time step specified inside must also match <code>wtiminc</code> in <code>param.nml</code>. If <code>nws=4</code>, the format of <code>wind.th</code> is different: each line specifies the wind u,v, and atmospheric pressure (in Pa) at all nodes.</li> <li>In the case of <code>msource.th</code> (invoked with <code>if_source=1</code>), the values after time stamp are tracer values at each source element (specified in <code>source_sink.in</code>), and the order of tracers is: T,S, followed by each tracer module invoked. No vertical level info is needed here as the tracers are injected at a level or all levels. If you do not have good values for some tracers, use -9999. instead and the code will inject ambient concentration values for you.</li> <li>See examples of <code>vsource.th</code>, <code>vsink.th</code> and <code>msource.th</code> in <code>sample_inputs/</code> of source code bundle.</li> </ul>"},{"location":"input-output/optional-inputs.html#thnc-netcdf4","title":".th.nc (netcdf4)","text":"<p>These include <code>elev2D.th.nc</code>, <code>uv3D.th.nc</code>, <code>TEM_3D.th.nc</code>, <code>SAL_3D.th.nc</code>, and <code>[MOD]_3D.th.nc</code> (where MOD is the tracer module name like \u2018COS\u2019). The format can be found below (also in test suite (e.g. schism_verification_tests/Test_ICM_UB/)).</p> <p>Notes</p> <ol> <li>the time always starts from 0, and the (uniform) time step can be anything <code>\u2265dt</code>. Note that the time stamp series in <code>time</code> is not needed by the code; only <code>time_step</code> (in sec) is needed;</li> <li><code>time_series</code> contains the main data at all relevant nodes;</li> <li>\u2018nOpenBndNodes\u2019 should be total number of nodes on all open boundary segments that require this input, and the values appear in same order as in bctides.in inside \u2018time_series\u2019;</li> <li><code>nLevels</code> specifies the vertical structure, and <code>nComponents</code> specifies either scalar/vector, or # of classes in the tracer module;</li> <li>Most netcdf4 libraries allow float and double to be interchangeable but it's better to be strict about data type.</li> </ol> <p>elev2D.th.nc</p> <pre><code>netcdf elev2D.th {\ndimensions:\n    time = UNLIMITED ; // (73 currently)\n    nOpenBndNodes = 748 ;\n    nLevels = 1 ;\n    nComponents = 1 ;\n    one = 1 ;\nvariables:\n    float time_series(time, nOpenBndNodes, nLevels, nComponents) ;\n    float time_step(one) ;\n    double time(time) ;\n}\n</code></pre> <p>uv3D.th.nc</p> <pre><code>netcdf uv3D.th {\ndimensions:\n    nOpenBndNodes = 748 ;\n    one = 1 ;\n    time = UNLIMITED ; // (73 currently)\n    nLevels = 44 ;\n    nComponents = 2 ;\nvariables:\n    float time_step(one) ;\n    double time(time) ;\n    float time_series(time, nOpenBndNodes, nLevels, nComponents) ;\n}\n</code></pre> <p>TEM_3D.th.nc</p> <pre><code>netcdf TEM_3D.th {\ndimensions:\n    nOpenBndNodes = 30 ;\n    nLevels = 35 ;\n    nComponents = 1 ;\n    one = 1 ;\n    time = UNLIMITED ; // (371 currently)\nvariables:\n    float time_step(one) ;\n      time_step:long_name = \"time step in seconds\" ;\n    double time(time) ;\n      time:long_name = \"simulation time in seconds\" ;\n    float time_series(time, nOpenBndNodes, nLevels, nComponents) ;\n</code></pre>"},{"location":"input-output/optional-inputs.html#prop","title":".prop","text":"<p>The element-centered inputs color each element with a \u2018property\u2019, which can be visualized with xmgredit5 (Special \\(\\rightarrow\\) properties). xmgredit5 also allows editing of this file. The format follows xmgredit5 element property format: </p> <pre><code>1 -1 !element number, element property\n2 0\n3 2\n4 5\n....\n</code></pre> <p>Currently there are 3 .prop files:</p> <p>tvd.prop: user needs to explicitly specify horizontal regions where upwind or higher-order solver (TVD or WENO) is used, based on the element property values (<code>0</code>: upwind; <code>1</code>: TVD or WENO) in <code>tvd.prop</code>.</p> <p>partition.prop: this input is required if you use static domain decomposition (NO_PARMETIS). The element property simple specifies the MPI process that owns each element. This can be generated e.g. by METIS.</p> <p>fluxflag.prop The element property flags (integers from -1,0,1,\u2026) specify the 'region number' for each element. The code will only compute the flow across a side if (1) the flags at its 2 adjacent elements differ by 1, and (2) neither flag is -1 (cf. Fig. 4.2). The output <code>flux.out</code> is a simple ASCII file with the format:</p> <pre><code>0.001389 0.1004E-01 0.1934E-01 !time (days), flow [m3/s] from region \u20181\u2019 to \u20180\u2019, flow from region \u20182\u2019 to \u20181\u2019,\u2026\n0.002778 0.8852E-02 0.2285E-01\n...\n</code></pre> <p></p> Example of `fluxflag.prop`"},{"location":"input-output/optional-inputs.html#ic","title":".ic","text":"<p>The I.C. inputs include the initial condition for elevation or tracers (<code>salt.ic</code>, <code>temp.ic</code>, and <code>ts.ic</code>). For most generic form of I.C. (variable in space and time), use <code>hotstart.nc</code>. </p> <p><code>elev.ic</code> is a <code>.gr3</code> file that specifies the initial elevation at each node. Depending on the values of <code>flag_ic(1:2)</code>, T,S I.C. inputs have different format.</p> <ul> <li>If <code>flag_ic(1:2)= 1</code>, <code>salt.ic</code> and <code>temp.ic</code> take the <code>.gr3</code> format;</li> <li>If <code>flag_ic(1:2)= 2</code>, <code>ts.ic</code> takes the following simple format:</li> </ul> <pre><code>43 !total # of vertical levels\n1 -2000. 4. 34. !level #, z-coordinates, temperature, salinity\n2 -1000. 5. 34.\n...\n</code></pre> <p>Notes on ts.ic</p> <p>The code will extrapolate above surface or below bottom for you if your z-coordinates do not cover the full depth. Since it uses cubic spline interpolate, make sure your vertical profiles are well resolved to avoid unexpected min/max due to the cubic spline method.</p> <p>Similar format is used for other tracers; e.g., <code>ICM_vvar_[1,2..].ic</code> has a similar format to <code>ts.ic</code>.</p>"},{"location":"input-output/optional-inputs.html#nc","title":".nc","text":"<p>Beside the time series inputs, we have the other types of netcdf4 input files as follows. Some sample files can be found in the test suite (e.g. schism_verification_tests/Test_ICM_UB/).</p> <p>hotstart.nc This input basically contains all major state variables defined at node/side/element.</p> <p>source.nc  Required if <code>if_source=-1</code>, this input combines all info needed for source/sink.</p> <p>source.nc</p> <pre><code>netcdf source {\ndimensions:\n    nsources = 1268 ;\n    nsinks = UNLIMITED ; // (0 currently)\n    ntracers = 23 ;\n    time_msource = 732 ;\n    time_vsource = 732 ;\n    time_vsink = UNLIMITED ; // (0 currently)\n    one = 1 ;\nvariables:\n    int source_elem(nsources) ;\n    float vsource(time_vsource, nsources) ;\n    float msource(time_msource, ntracers, nsources) ;\n    double time_msource(time_msource) ;\n    double time_vsource(time_vsource) ;\n    float time_step_vsource(one) ;\n    float time_step_msource(one) ;\n    float time_step_vsink(one) ;\n\n// global attributes:\n            :file_format = \"NETCDF4\" ;\n            :_NCProperties = \"version=2,netcdf=4.8.1,hdf5=1.12.1\" ;\n}\n</code></pre> <p>Notes</p> <ol> <li>Numbers of records for sources and sinks can be different;</li> <li><code>source_elem</code> and <code>sink_elem</code> specify the element indices for source/sinks;</li> <li>The time stamps in <code>time_msource</code> etc are not needed by the code; only <code>time_step_*</code> (in sec) are required;</li> <li><code>ntracers</code> specifies the total # of classes in all tracer modules (including T,S,..). The example above used ICM module (which has 21 classes), so together with T,S there are 23 'tracers'.</li> </ol> <p>*_nu.nc This input is used for tracer nudging (<code>inu_tr=2</code>). You only need to specify values in the nudging zone and may use junk values -9999 inside (in this case the code will not nudge to the junk value). The mapping array \u2018map_to_global_node\u2019 is used to map the array indices to the global node indices.</p> <p>ICM_nu.nc</p> <pre><code>netcdf ICM_nu {\ndimensions:\n    node = 27023 ;\n    nLevels = 40 ;\n    ntracers = 21 ;\n    time = UNLIMITED ; // (367 currently)\nvariables:\n    float time(time) ;\n    int map_to_global_node(node) ;\n    float tracer_concentration(time, node, nLevels, ntracers) ;\n}\n</code></pre> <p>Notes</p> <ol> <li><code>node</code> specifies total # of nodes in the nudging zone (i.e. with non-zero depths in <code>*_nudge.gr3</code>);</li> <li><code>ntracers</code> is the # of tracer classes in this module (1 for T,S);</li> <li><code>map_to_global_node</code> maps the local node indices to global nodes;</li> <li>The time stamps in <code>time</code> are not needed by the code, as <code>step_inu_tr</code> already specified the time step in nudging inputs.</li> <li><code>tracer_concentration</code> specifies the tarcer concentrations to nudge toward.</li> </ol>"},{"location":"input-output/optional-inputs.html#in","title":".in","text":""},{"location":"input-output/optional-inputs.html#stationin-bp-format","title":"station.in (.bp format)","text":"<p>This file is needed if <code>iout_sta=1</code> and is in a build point format (essentially.gr3 without the connectivity table):</p> <pre><code>1 1 1 1 1 1 1 1 1 !on (1)|off(0) flags for elev, air pressure, windx, windy, T, S, u, v, w\nnsta !# of stations\ndo i=1,np\n    i,xsta(i),ysta(i),zsta(i) !zsta(i) is z-coordinates (from vertical datum; &lt;0 is below)\nenddo    \n</code></pre> <p>Also see station.in.sample in the source bundle.</p>"},{"location":"input-output/optional-inputs.html#source_sinkin","title":"source_sink.in","text":"<p>This input is invoked if <code>if_source=1</code>, and specifies the element #\u2019s for each (volume and mass) source and sink. The format is:</p> <pre><code>2   ! total # of elements with sources\n100 ! element # of 1st source\n101 ! element # of 2nd source\n    !A blank line for readability; below are sinks\n3   ! total # of elements with sinks\n99  ! element # of 1st sink\n100\n105 ! element # of 3rd sink\n</code></pre>"},{"location":"input-output/optional-inputs.html#hydraulicsin","title":"hydraulics.in","text":"<p>This input is invoked if <code>ihydraulics=1</code>, and is the main input for the hydraulics module. See hydraulics module manual for details.</p>"},{"location":"input-output/optional-inputs.html#harmin","title":"harm.in","text":"<p>This file is needed if <code>iharind=1</code>. Harmonic analysis capabilities were introduced in SCHISM by Andre Fortunato, using the routines of ADCIRC. These routines were developed by R.A. Luettich and J.J. Westerink, who are hereby acknowledged, and were used with written permission by R.A. Luettich. Note that only analysis on elevations at all nodes can be done at the moment.</p> <p>The file has the following format (text adapted from the ADCIRC user's manual):</p> <pre><code>NFREQ = number of frequencies included in harmonic analysis of model results.\nfor k=1 to NFREQ\n    NAMEFR(k) = an alphanumeric descriptor (i.e. the constituent name) whose length must be &lt;=16 characters\n    HAFREQ(k), HAFF(k), HAFACE(k) = frequency (rad/s), nodal factor, equilibrium argument (degrees)\nend k loop\nTHAS, THAF, NHAINC, FMV = See detail in the notes below\nNHAGE, NHAGV = flags that indicate whether or not harmonic analysis is performed, see notes below\n</code></pre> <p>Notes</p> <ul> <li>THAS: the number of days after which data starts to be harmonically analyzed</li> <li>THAF: the number of days after which data ceases to be harmonically analyzed</li> <li>NHAINC: the number of time steps at which information is harmonically analyzed (information every NHAINC time steps after THAS is used in harmonic analysis)</li> <li>FMV: fraction of the harmonic analysis period (extending back from the end of the harmonic analysis period) to use for comparing the water elevation and velocity means and variances from the raw model time series with corresponding means and variances of a time series resynthesized from the harmonic constituents. This comparison is helpful for identifying numerical instabilities and for determining how complete the harmonic analysis was. Examples: FMV = 0. - do not compute any means and vars. FMV = 0.1 - compute means and vars. over final 10% of period used in harmonic analysis FMV = 1.0 - compute means and vars. over entire period used in harmonic analysis.</li> <li>NHAGE: NHAGE= 0 no harmonic analysis is performed for global elevations; NHAGE =1 harmonic analysis is performed for global elevations (output on harme.53);</li> <li>NHAGV: NHAGV is for velocity which is not active right now.</li> </ul>"},{"location":"input-output/optional-inputs.html#metadatanc","title":"metadata.nc","text":"<p>This optional file can contain global and variable metadata in the form of NetCDF attributes that will be copied over to the SCHISM output NetCDF files.  This file is useful for adding project- or institution-specific metadata.   In particular, you should use it to fill the contact and institution information required by CF, and to add a coordinate reference system to SCHISM output on projected coordinates (<code>ics = 1</code>) if you add a grid mapping variable called <code>crs</code> with appropriate attributes.  See the CF conventions for details on required and recommended metadata: https://cfconventions.org/.</p>"},{"location":"input-output/outputs.html","title":"Outputs","text":"<p>All SCHISM outputs (except system outputs) can be found in <code>outputs/</code> directory.</p>"},{"location":"input-output/outputs.html#run-info-output-mirrorout","title":"Run info output (mirror.out)","text":"<p>This is a mirror image of now-defunct screen output and is useful for diagnosis. Below is a sample:</p> <pre><code>Barotropic model without ST calculation\n # of tracers in each module:            1            1            0\n            0            0            0            0            0            0      0\n Total # of tracers=            2\n Index ranges of each module:            1            1            2\n            2            3            2            3            2            3\n            2            3            2            3            2            3\n            2            3            2            3            2\n # of global outputs=           27\n done reading param.in; s2_mxnbt in param.in =    3.000000000000000\n lhas_quad=  T\n mnei, mnei_p =             4            9\n lhas_quad=  T\nGlobal Grid Size (ne,np,ns,nvrt):        108       130       237         2\n\n**********Augmented Subdomain Sizes**********\n rank     nea      ne     neg     nea2     neg2     npa      np     npg     npa2     npg2     nsa      ns     nsg     nsa2     nsg2\n    0      30      14      16      40      10      43      24      19      43       0      72      37      35      72       0\n    1      28      14      14      38      10      40      23      17      40       0      67      36      31      67       0\n    2      26      13      13      32       6      38      23      15      38       0      63      35      28      63       0\n    3      23      13      10      30       7      34      22      12      34       0      56      34      22      56       0\n    4      23      13      10      30       7      34      22      12      34       0      56      34      22      56       0\n    5      28      14      14      38      10      40      23      17      40       0      67      36      31      67       0\n    6      26      13      13      32       6      38      23      15      38       0      63      35      28      63       0\n    7      30      14      16      40      10      43      24      19      43       0      72      37      35      72       0\n\n**********Global Boundary Sizes**********\n    nope    neta   nland    nvel\n       1      13       1      31\n\n**********Augmented Subdomain Boundary Sizes**********\n    rank    nope    neta   nland    nvel\n       0       0       0       1       7\n       1       0       0       1       7\n       2       0       0       1      10\n       3       0       0       1      10\n       4       1       4       1       7\n       5       1       7       0       0\n       6       1       5       1       6\n       7       1       7       0       0\nMax. &amp; min. sidelength=     19934.91537849107         7973.938973963872\n done init (1)...\n done init. tracers..\n done initializing cold start\nDone initializing variables\nDone initializing outputs\n done computing initial vgrid...\n done computing initial nodal vel...\n done computing initial density...\n time stepping begins...            1         1440\n done adjusting wind stress ...\n done flow b.c.\n done hvis...\n done backtracking\n done 1st preparation\n done 2nd preparation\n done solver; etatot=   3.1245774014922456E-002 ; average |eta|=  4.553235604713400E-005\n done solving momentum eq...\n done solving w\n done solving transport equation\n done recomputing levels...\n done density calculation...\nTIME STEP=            1;  TIME=           300.000000\n\u2026.\n</code></pre> <p>Notes</p> <p>The \u2018average |eta|\u2019 above can be used as a quick and easy way to check if the run is progressing smoothly; it is the average of the absolute value of surface elevation at all nodes. If it\u2019s too large or NaN, you have a problem.</p>"},{"location":"input-output/outputs.html#global-output","title":"Global output","text":"<p>SCHISM netcdf4 outputs are emitted in a directory called outputs/. This directory must exist or you  will get an immediate crash from the model. </p> <p>Depending on whether or not you turned on OLDIO, the global netcdf outputs will look different.</p> <p>1) Scribed I/O (OLDIO is OFF) Under this mode, the netcdf outputs are global (combined) outputs, and you can visualize or process thm  using latest FORTRAN (e.g., read_output10*), matlab or python scripts, or  the latest VisIT plugins.</p> <p>All 2D variables (e.g. <code>elevation</code>, <code>sigWaveHeight</code> etc) as well as static information such as geometry  and connectivity info are grouped into <code>out2d_*.nc</code>. On the other hand, each 3D variable has its own   output, and vector variables have X and  Y components in separate outputs (e.g. <code>horizontalVelX_*.nc</code> and  <code>horizontalVelY_*.nc</code>).</p> <p>2) Old I/O (OLDIO is ON) Under this mode, each MPI process will dump its own output and a post-processing script (<code>combin_output*.f90</code>)  will need to be used to combine these into global netcdf outputs.  </p> <p>An example output file name is <code>outputs/schout_000000_2.nc</code>. More generally, the file name is: <code>schout_[processor_no]_[time_block /stack #].nc</code></p> <p>Processor number</p> <p>The mpi_processor number starts at 0 and represents the MPI processor ID from the task that wrote the output. </p> <p>Time block</p> <p>The time blocks (\u2018stack\u2019) start from 1 and are sequential. The model buffers and writes data occasionally. Every <code>ihfskip</code> time steps it opens a new stack. For instance, if the time step is 120 seconds and <code>ihfskip = 10080</code>, each stack will be 14-day long.</p> <ul> <li>\"Neat\" time lengths that will make meaningful analysis (e.g. daily, 10 days etc) are usually easiest later when you post-process;</li> <li>Some of the post-processing scripts will run a lot better if the length of your simulation is an even multiple of ihfskip. This can be done by altering ihfskip or the simulation length - at the risk of lengthening the simulation a bit, the latter often produces a neater result.</li> <li>If your simulation length is not an even multiple of the time block length, the last time block will be truncated on the last block. This will cause some minor errors and warnings in the post-processing tools. In addition, if you then restart the run it is best to repeat and overwrite the truncated block - the post-processing tools do not work well with blocks that grow and shrink in the middle of the run.</li> <li>If the output blocks match the end of the simulation very neatly, the model (at the time of writing) will open a new block that is very small in size. This is useful for the <code>autocombine_MPI_elfe.pl</code>, as the latter always waits until a new block to come out before starting to combine the previous block (and so it'd hang if the last empty block were not written out).</li> </ul> <p>Variable names</p> <p>The variables inside .nc correspond to 3D grid and state variables info at each output time step. The state variables (arrays) may have different centerings, e.g. at node/element/side. At the moment, most variables are centered around nodes (and most post-processing FORTRAN scripts also work on node-centered variables).</p> <p>Combine outputs</p> <p>The per-processor outputs need to be gathered into combined nc4 outputs first before you can visualize or post-process them. The script that does this is called <code>combine_output11.f90</code> (a simple perl script <code>autocombine_MPI_elfe.pl</code> exists to combine all available outputs transparently; you just need to update the path to the compiled <code>combine_output11</code> inside the script, and it can be launched before or after a run is done). See the header of <code>combine_output11.f90</code> on sample compilation commands and usage. Once you are done combining, you should have nc4 files called something like <code>schout_2.nc</code> etc. Note that the stack # remains but the MPI process number is gone. There is no utility for gathering the outputs in stack/time; instead most post-processing tools are able to work with multiple stacks.</p> <p>Note that under OLDIO, SCHISM allows users to easily add more customized outputs, using the routine writeout_nc() inside schism_step. The combine scripts will automatically combine the additional outputs.</p> <p>You can visualize the combined nc4 outputs using VisIT (with SCHISM plug-ins). More info can be found in Visualization</p> <p>Special care for elevation outputs</p> <p>The elevation outputs from SCHISM are 'raw' outputs, which means users usually need to do post-processing to weed out dry instances themselves. This is a very common mistake from users. Always compare the elevation against local bottom elevation; if the total depth is less than <code>h0</code> (as specified in <code>param.nml</code>) you should not take the elevation outputs at face value - they should be instead NaN. For example, if the local depth is 2m, an elevation value of -3m or -1000m is the same: the node at this time instance is dry.</p> <p>Other global outputs</p> <p>The user may be interested in some maximum quantities. At the moment, SCHISM outputs two max files for elevation and depth-averaged velocity (<code>outputs/maxelev_*</code> and <code>outputs/maxdahv_*</code>). These files can be combined using <code>Utility/Combining_Scripts/combine_gr3.f90</code> to generate <code>maxelev.gr3</code> and <code>maxdahv.gr3</code>. However, please exercise caution with <code>maxelev.gr3</code> calculated this way because it may contain transient responses from cold start that should be disgarded. We recommend using <code>Utility/Post-Processing-Fortran/read_output10_allnodes.f90</code>, which gives you more controls. Also see above for the general comments on elevation outputs.</p> <p>Another type of global outputs are hotstart outputs, which must be combined (using <code>combine_hotstart7.f90</code>) to generate a restart input.</p>"},{"location":"input-output/outputs.html#station-outputs","title":"Station outputs","text":"<p>These outputs are invoked with <code>iout_sta=1</code>, and are found in <code>outputs/staout_[1..,9]</code>, corresponding respectively to elev, air pressure, wind u, wind v, T, S, u, v, w. Each output has a simple ASCII format:</p> <pre><code>Time(sec), variable @ station 1,2,\u2026. (specified in station.in)\n</code></pre>"},{"location":"input-output/outputs.html#warning-and-fatal-messages","title":"Warning and fatal messages","text":"<p>Warning message (<code>nonfatal_*</code>) contains non-fatal warnings, while fatal message file (<code>fatal.error</code>) contains fatal errors. In addition, you\u2019d also check the system error outputs from your parallel job.</p>"},{"location":"input-output/overview.html","title":"Overview","text":""},{"location":"input-output/overview.html#type-of-inputs-for-schism","title":"Type of inputs for SCHISM","text":"<p>Most SCHISM inputs can be visualized with ACE/xmgredit5 or xmgr5 tools; see src/Utility/ACE for instructions on how to install these tools. Other useful tools will be mentioned in the later chapters.</p> <p>SCHISM input files can be broadly categorized into following 7 groups:</p> <ol> <li><code>*.gr3</code>, <code>hgrid.ll</code>: node centered spatial data and mesh connectivity. These file can be created/visualized using <code>ACE/xmgredit5</code>;</li> <li><code>*.th</code>: time history files in ASCII format. The ASCII files can be visualized using <code>ACE/xmgr5</code>;</li> <li><code>*.ic</code>: initial condition files. Some of these files use <code>.gr3</code> format, while others have simple ASCII format;</li> <li><code>*.prop</code>: element-centered spatial data and properties; can be created/visualized using <code>ACE/xmgredit5</code>;</li> <li><code>*.nc</code>: netcdf4 inputs, including time history (<code>*.th.nc</code>), hotstart (<code>hotstart.nc</code>), and nudging inputs (<code>*_nu.nc</code>). These inputs may be created by PYSCHISM tool;</li> <li><code>*.nml</code>: main parameter input (<code>param.nml</code>);</li> <li><code>*.in</code>: role-specific input files with individual formats. ASCII inputs include vertical grid (<code>vgrid.in</code>), B.C. input (<code>bctides.in</code>), and <code>hydraulics.in</code> (for hydraulics module) etc;</li> <li><code>sflux/</code>: atmospheric and heat flux files in netcdf format (CF convention v1.0). These files can be visualized using standard tools like ncview, ferret etc;</li> <li>Inputs from modules: <code>.nml</code>, <code>.inp</code> etc.</li> </ol>"},{"location":"input-output/overview.html#mandatory-inputs","title":"Mandatory inputs","text":"<p>These inputs are required for all SCHISM simulations:</p> <ol> <li>Horizontal grid (<code>hgrid.gr3</code>)</li> <li>Vertical grid (<code>vgrid.in</code>)</li> <li>Parameter input (<code>param.nml</code>)</li> <li>B.C. input (<code>bctides.in</code>)</li> <li>Bottom friction input (<code>drag.gr3</code>, or <code>rough.gr3</code> or <code>manning.gr3</code>, depending on parameter choice in <code>param.nml</code>)</li> </ol> <p>We\u2019ll explain these inputs in detail below. Comments/explanations are usually preceded by '!'.</p>"},{"location":"input-output/param.html","title":"Model parameters (param.nml)","text":"<p>Please refer to sample param.nml in the source code directory (sample_inputs/) while you read the following.</p> <p>The file uses the FORTRAN namelist format. The order of input parameters is not important. Governing rules for this file are:</p> <ul> <li>lines beginning with <code>!</code> are comments; blank lines are ignored;</li> <li>the format for each parameter is: <code>keywords=value</code>; keywords are case sensitive; spaces allowed between <code>keywords</code> and <code>=</code> and <code>value</code>; comments starting with <code>!</code> after value are ignored;</li> <li><code>value</code> is an integer, double, or 2-char string (use ' ' (single quotes) for this); for double, any of the format is acceptable: 40 or 40. or 4.e1 but the last 2 are preferred. Use of decimal point for integers is discouraged;</li> <li>if multiple entries for a parameter are found, the last one wins - please avoid this</li> <li>array inputs follow column major (like FORTRAN) and can spill to multiple line.</li> </ul> <p>The namelist file is divided into 3 major sections: CORE, OPT and SCHOUT. CORE lists out all core parameters that must be specified by the user, i.e., no defaults are provided by the code. OPT and SCHOUT sections contain optional parameters and I/O flags, all of which have default values so the user does not have to specify any of these (the values shown in the sample are defaults unless otherwise stated). SCHISM will also echo the input values in the output file <code>outputs/param_out.nml</code>.</p> <p>Most parameters (and their keywords) are explained as follows; some are \u2018developers handles\u2019 that should  not be tweaked usually. Also the sample has suggested values for many parameters. Note that you do not  have to follow the order below. In many cases we have grouped related parameters  for easier explanation, but you should specify them on separate lines. Also you'll find additional useful  info in the comments of the sample <code>param.nml</code>. The parameters are listed out below in alphabetic order.</p>"},{"location":"input-output/param.html#core-block","title":"CORE block","text":"<p>The following parameters have to be specified by the user; otherwise you may get a fatal error. The exceptions are  those parameters required by optional modules (e.g., WWM), which do not need to be present if the modules are  not invoked.</p>"},{"location":"input-output/param.html#ipre-int","title":"ipre (int)","text":"<p>Pre-processing flag (1: on; 0: off). <code>ipre=0</code>: normal run. </p> <p>Pre-processing flag is very useful for checking integrity of the horizontal grid and some inputs. <code>ipre=1</code>: code will output centers.bp, sidecenters.bp, (centers build point, sidcenters build point), and <code>mirror.out</code> and stop. Check errors in <code>fatal.error</code> or system outputs. </p> <p>Important</p> <p><code>ipre/=0</code> only works for single CPU! If you use scribed I/O (<code>OLDIO</code> off), make sure the number of 'computes' is 1, plus extra for scribes. Also under the scribe mode, the pre-processing run will likely finish without a clean exist (as the scribe world is still initializing). Check <code>outputs/</code> (<code>mirror.out</code> and <code>fatal.error</code>) and system outputs; if the run is finished (e.g., you see 'Pre-processing completed successfully') you can manually kill the run.</p>"},{"location":"input-output/param.html#ibc-int-ibtp-int","title":"ibc (int), ibtp (int)","text":"<p>Barotropic/baroclinic flags. </p> <p>If <code>ibc=0</code>, a baroclinic model is used and regardless of the value for <code>ibtp</code>, the transport equation is solved. If <code>ibc=1</code>, a barotropic model is used, and the transport equation may (when <code>ibtp=1</code>) or may not (when <code>ibtp=0</code>) be solved; in the former case, S and T are treated as passive tracers.</p>"},{"location":"input-output/param.html#rnday-double","title":"rnday (double)","text":"<p>Total simulation time in days.</p>"},{"location":"input-output/param.html#dt-double","title":"dt (double)","text":"<p>Time step in seconds. This is the main time step in SCHISM. The transport solvers have their own adaptive time step for subcycling to satisfy the stability constraint.</p>"},{"location":"input-output/param.html#msc2-int-mdc2-int","title":"msc2 (int), mdc2 (int)","text":"<p>These two parameters are only used if the wave module WWM is invoked (<code>USE_WWM</code> is on and <code>icou_elfe_wwm=1</code>).  The values represent the spectral resolution used in WWM and must match those in  wwminput.nml;</p>"},{"location":"input-output/param.html#eco_class-ntracer_gen-ntracer_age-sed_class-int","title":"eco_class, ntracer_gen, ntracer_age, sed_class (int)","text":"<p>These parameters set the # of tracer \u2018classes\u2019 for each tracer module (EcoSim, GEN, AGE and SED), and are required if these modules are invoked in makefile. Note that other tracers modules (ICM, CoSiNE) set their own # of classes.</p>"},{"location":"input-output/param.html#nspool-ihfskip-int","title":"nspool, ihfskip (int)","text":"<p>These two flags control the global netcdf outputs. Output is done every <code>nspool</code> steps, and a new output stack is opened every <code>ihfskip</code> steps. The code requires that <code>ihfskip</code> is a multiple of <code>nspool</code>, and <code>nhot_write</code> (see SCHOUT section) is a a multiple of <code>ihfskip</code>.</p>"},{"location":"input-output/param.html#nbins_veg_vert-int","title":"nbins_veg_vert (int)","text":"<p>Number of vertical bins used in vegetation option <code>iveg=1</code>.</p>"},{"location":"input-output/param.html#nmarsh_types-int","title":"nmarsh_types (int)","text":"<p>Number of marsh types (needed by USE_MARSH).</p>"},{"location":"input-output/param.html#opt-block","title":"OPT block","text":"<p>The optional parameters below are explained in alphabetical order. The default values can be seen below and also in the sample file (sample_inputs/).</p>"},{"location":"input-output/param.html#dramp1-double-drampbc1-double","title":"dramp=1. (double), drampbc=1. (double)","text":"<p>Ramp periods in days for the tides, B.C. (boundary condition) or baroclincity.  If <code>ibc=0</code>, the ramp-up for baroclinicity is specified with <code>drampbc</code> (in days).  Turn off ramp-up by setting the ramp-up period &lt;=0.  The ramp function is a hyperbolic tangent function; e.g. \\(f(t) = \\tanh(2t/86400/\\text{drampbc})\\).</p>"},{"location":"input-output/param.html#flag_ic1-int-array","title":"flag_ic(:)=1 (int array)","text":"<p>Options for specifying initial tracer fields for cold start, where each array entry corresponds to individual tracer model (e.g. TEM, SAL, SED etc). If <code>flag_ic=1</code>, a vertically homogeneous but horizontally varying initial tracer field is specified in inputs like <code>temp.ic</code>, <code>salt.ic</code>, <code>[MOD]_hvar_[class #].ic</code> etc. If <code>flag_ic=2</code>, a horizontally homogeneous but vertically varying initial tracer field, prescribed in a series of z-levels, is specified in inputs like <code>ts.ic</code>, <code>[MOD]_vvar_[class #].ic</code>. For more general 3D initial tracer fields, use the hot start option. See <code>Optional inputs</code> section for examples of some of these inputs. Note that there is a requirement that <code>flag_ic(1)=flag_ic(2)</code>.</p>"},{"location":"input-output/param.html#h0001-double","title":"h0=0.01 (double)","text":"<p>Minimum depth (in m) for wetting and drying (recommended value: <code>1cm</code>). When the total depth is less than <code>h0</code>, the corresponding nodes/sides/elements are marked as dry. It should always be positive.</p>"},{"location":"input-output/param.html#h12_bcc50100-double-in-meters","title":"h[1,2]_bcc=50,100 (double; in meters)","text":"<p>Option on how the baroclinic gradient is calculated below bottom. The 'below-bottom' gradient is zeroed out if <code>h&gt;=h2_bcc</code> (i.e. like Z) or uses constant extrapolation (i.e. like terrain-following) if <code>h&lt;=h1_bcc(&lt;h2_bcc)</code>. A linear transition is used if the local depth <code>h1_bcc&lt;h&lt;h2_bcc</code>.</p>"},{"location":"input-output/param.html#ibcc_mean0-int","title":"ibcc_mean=0 (int)","text":"<p>Mean T,S profile option. If <code>ibcc_mean=1</code> (or <code>ihot=0</code> and <code>flag_ic(1:2)=2</code>), mean T/S profile is read in from <code>ts.ic</code>, and will be removed when calculating baroclinic force. No <code>ts.ic</code> is needed if <code>ibcc_mean=0</code>.</p>"},{"location":"input-output/param.html#ic_elev0-int-nramp_elev0-int-int","title":"ic_elev=0 (int), nramp_elev=0 (int) (int)","text":"<p>Elevation initial condition flag for cold start only (<code>ihot=0</code>). If <code>ic_elev=1</code>, <code>elev.ic</code> (in <code>*.gr3</code> format)  is needed to specify the initial condition (I.C.) Otherwise elevation is initialized to 0 everywhere (cold start only) or from the  elevation values in <code>hotstart.nc</code> (hotstart option).  If <code>ic_elev=1</code>, the user can ramp up the elevation  smoothly at the boundary starting from the specified <code>elev.ic</code> or <code>hotstart.nc</code> (if \\(ihot\\neq 0\\)) by setting <code>nramp_elev=1</code> (and the ramp-up  period in this case is <code>dramp</code>). It's usually OK to use <code>nramp_elev=1</code> under either cold or hot start.</p>"},{"location":"input-output/param.html#icou_elfe_wwm0-iwbl0-int","title":"icou_elfe_wwm=0, iwbl=0 (int)","text":"<p>Coupler flag with WWM; needed if USE_WWM pre-processor is enabled. <code>icou_elfe_wwm = 0</code>: no feedback from WWM to SCHISM (decoupled); <code>1</code>: coupled SCHISM-WWM.</p> <p><code>iwbl=1</code>: modified Grant-Madsen formulation for wave enhanced boundary layer; =2: Soulsby (1997) formulation; <code>=0</code>: off.</p> <p>If <code>icou_elfe_wwm=1</code>, additional parameters are:</p> <ul> <li><code>nstep_wwm=1</code> (int): call WWM every <code>nstep_wwm</code> time steps;</li> <li><code>hmin_radstress=1.0</code> (double): minimum total water depth in meters used only in radiation stress calculation; the radiation stress is zero if <code>local depth &lt;hmin_radstress</code>.</li> </ul> <p>In addition, there are parameters related to Vortex Formalism of Bennice and Ardhuin (2008).</p>"},{"location":"input-output/param.html#ics1-int","title":"ics=1 (int)","text":"<p>Coordinate frame flag. If <code>ics=1</code>, Cartesian coordinates are used; if <code>ics=2</code>, both <code>hgrid.ll</code> and <code>hgrid.gr3</code> use degrees latitude/longitude (and they should be identical to each other in this case).</p>"},{"location":"input-output/param.html#ielm_transport-0-max_subcyc-10-int","title":"ielm_transport = 0, max_subcyc = 10 (int)","text":"<p>Hybrid ELM-FV transport for performance. If <code>ielm_transport=1</code>,  the hybrid scheme is invoked and <code>max_subcyc</code> represents the max # of subcycling per time step in  transport allowed; if the actual # of subcycling in a prism at a time step exceeds this threshold,  more efficient ELM transport is used locally (at the expense of mass conservation and accuracy,  so make sure this option is used sparingly).</p>"},{"location":"input-output/param.html#ieos_type0-ieos_pres0-int","title":"ieos_type=0, ieos_pres=0 (int)","text":"<p>By default, use the nonlinear equation of state: <code>ieos_type=0</code>. <code>ieos_pres=0,1</code> will turn on/off hydrostatic pressure effects. If the potential temperature is used, the pressure effect has been accounted for, so <code>ieos_pres=0.</code></p>"},{"location":"input-output/param.html#if_source0-int-dramp_ss2-double-lev_tr_source-9-int-array","title":"if_source=0 (int), dramp_ss=2. (double), lev_tr_source(:)=-9 (int array)","text":"<p>Point sources/sinks option (0: no; 1: on). If <code>if_source=1</code>, needs <code>source_sink.in</code>, <code>vsource.th</code>, <code>vsink.th</code>,  and <code>msource.th</code> (see sample files in the source code directory src/ for their formats).  If <code>if_source=-1</code>, the input is <code>source.nc</code>, which includes element list inside and allows for different time  steps and # of records for volume/mass source/sinks. If <code>if_source/=0</code>, specify ramp-up period (in days) with <code>dramp_ss</code> (no  ramp-up if &lt;=0). </p> <p>The tracers are injected into an element at a particular level, as specified by <code>lev_tr_source(1:ntr)</code> (where <code>ntr</code> is total  # of tracer modules, i.e. 1 input level per module). The code will extrapolate below bottom/above surface if necessary,   so e.g., '-9' means bottom. To inject at all levels, set the level at '0'.</p> <p>AGE module</p> <p>The AGE mpdule has its own way of injecting age tracers (see below), so make sure the age concentrations from all sources are all -9999. in msource.th so as to not interfere.</p>"},{"location":"input-output/param.html#level_age-999-int-array","title":"level_age(:)=-999 (int array)","text":"<p>If <code>USE_AGE</code> is on, this array specifies the vertical level indices used to inject age tracers. You only need to   specify this for the first half of the tracer classes. Use -999 to inject the tracer at all levels.</p>"},{"location":"input-output/param.html#iflux0-int","title":"iflux=0 (int)","text":"<p>Parameter for checking volume and tracer mass conservation. If turned on (<code>=1</code> or <code>2</code>), the  conservation will be checked in regions specified by <code>fluxflag.prop</code>. <code>iflux=2</code> would produce mroe detailed volume/mass  fluxes outputs.</p>"},{"location":"input-output/param.html#iharind0-int","title":"iharind=0 (int)","text":"<p>Harmonic analysis flag. If \\(iharind \\neq 0\\), an input <code>harm.in</code> is needed.</p>"},{"location":"input-output/param.html#ihconsv0-int","title":"ihconsv=0 (int)","text":"<p>Heat budget (air-sea exchange) model flag. If <code>ihconsv=0</code>, the heat budget model is not used. If <code>ihconsv=1</code>, a heat  budget model is invoked, and a number of netcdf files for radiation flux input are read in from <code>sflux/sflux_rad*.nc</code>.  The evaporation and precipitation model is evoked by the pre-processing flag <code>PREC_EVAP</code> in makefile  (old flag <code>isconsv</code> has been removed). In this case, <code>ihconsv</code> must be <code>1</code>, and additional netcdf inputs for precipitation (<code>sflux/sflux_prc*.nc</code>) are required. The user can also turn on <code>USE_BULK_FAIRALL</code> in the makefile to use COARE algorithm  instead of the default Zeng's bulk aerodynamic module.</p> <p>If <code>ihconsv=1</code>, 2 additional inputs are: <code>albedo.gr3</code> (for surface albedo; usually ~0.1) and <code>watertype.gr3</code> (that specifies the light attenuation coefficients for different water types following Jerlov: a dimensionles ratio <code>R</code>, and two characteristic depth (<code>D1</code> and <code>D2</code>).  See <code>schism_step</code> for those values for different types 1-7. If the type is '8', user needs to specify those 3 coefficients in <code>param.nml</code>: <code>watertype_rr, watertype_d1, watertype_d2</code>.</p>"},{"location":"input-output/param.html#i_hmin_airsea_ex-int-hmin_airsea_ex-double-in-meters","title":"i_hmin_airsea_ex (int), hmin_airsea_ex (double; in meters)","text":"<p>Option to locally turn off heat exchange.</p> <ul> <li><code>i_hmin_airsea_ex=1</code>: exchange turned off if <code>local water depth&lt;hmin_airsea_ex</code></li> </ul>"},{"location":"input-output/param.html#i_hmin_salt_ex-int-hmin_salt_ex-double-in-meters","title":"i_hmin_salt_ex (int), hmin_salt_ex (double; in meters)","text":"<p>Similar to <code>i_hmin_airsea_ex</code> and <code>hmin_airsea_ex</code>.</p>"},{"location":"input-output/param.html#iprecip_off_bnd-int","title":"iprecip_off_bnd (int)","text":"<p>If <code>iprecip_off_bnd</code>/=0, preciptation will be turned off near land boundary. This is useful for islands sitting on very steep slopes.</p>"},{"location":"input-output/param.html#istemp-int","title":"istemp (int)","text":"<p>Option to add a sediment layer for the buffer effect on temperature. <code>istemp=0</code> would turn off this effect;   otherwise, needs <code>ihconsv/=0</code>, and a few additional inputs: <code>soil_conductivity.gr3</code>  which specifies the soil thermal conductivity in W/m^2/K, and <code>soil_thick.gr3</code> (soil thickness in meters; e.g. 1m).  The conductivity is on the order of 5, but can be 0 in deep depths to turn off the effect.</p>"},{"location":"input-output/param.html#ihdif0-int","title":"ihdif=0 (int)","text":"<p>Flag for applying horizontal diffusivity, implemented as a geometric filter.  If <code>ihdif=0</code>, it is not used. If \\(ihdif \\neq 0\\), input <code>hdif.gr3</code> is used to specify filter strength at each node (which  should be &lt;=0.2).</p>"},{"location":"input-output/param.html#iref_ts-0-int","title":"iref_ts =0 (int)","text":"<p>Surface restoration for T,S to a reference state (e.g., observaion, global model etc). If <code>iref_ts=1</code>, requires  <code>ref_ts_restore_depth,ref_ts_tscale,ref_ts_h1,ref_ts_h2,ref_ts_dt</code> (respectively, piston depth in meters, restoration   time scale in days, 2 ramp-down depths in meters, and time step used in <code>surface_restore.nc</code>);  the input for reference T,S is <code>surface_restore.nc</code>. The 2 ramp-down depths (<code>ref_ts_h1&gt;ref_ts_h2</code>) are used to zero out  the restoration in shallow depths (with a linear transitioni of restoration strength in between).</p>"},{"location":"input-output/param.html#ihot0-int","title":"ihot=0 (int)","text":"<p>Hot start flag. If <code>ihot=0</code>, cold start; if \\(ihot \\neq 0\\), hot start from <code>hotstart.nc</code>. If <code>ihot=1</code>, the time and time step are reset to zero, and outputs start from <code>t=0</code> accordingly (and you need to adjust other inputs like <code>.th</code> etc). If <code>ihot=2</code>, the run (and outputs) will continue from the time specified in <code>hotstart.nc</code>. </p> <p>Note</p> <ol> <li>With <code>ihot=2</code>,you do not need to adjust other inputs but you do need to make sure <code>flux.out</code> is inside <code>outputs/</code> (even if you used <code>iflux=0</code>). If you used \\(iout\\_sta \\neq 0\\), make sure <code>staout_*</code> are inside <code>outputs/</code> as well. This is because the code will try to append to these outputs upon restart, and would crash if it cannot find them. On the other hand, you don't need to have the global outputs in <code>outputs/</code> because <code>nhot_write</code> is a multiple of <code>ihfskip</code> so the new outputs will be written into a new stack. In fact, you can change the core count upon hotstart this way.</li> <li>Under <code>ihot=1</code>, beware the use of ramps. Since the time origin has been reset, the ramps need to be adjusted accordingly. For example, if the field has been fully warmed up at the hotstart, then set ramps=0.</li> </ol>"},{"location":"input-output/param.html#ihydraulics0-int","title":"ihydraulics=0 (int)","text":"<p>Hydraulic model option. If \\(ihydraulics \\neq 0\\), <code>hydraulics.in</code> is required (cf. hydraulics user manual).</p>"},{"location":"input-output/param.html#iloadtide0-int-loadtide_coef-double","title":"iloadtide=0 (int), loadtide_coef (double)","text":"<p>Option to specify Self Attraction and Loading (SAL) tide, usually used for basin- or global-scale applications.  If <code>iloadtide=0</code>, SAL is off. If <code>iloadtide=1</code>, the SAL input is interpolated values from a tide database,  e.g., FES2014, given in <code>loadtide_[FREQ].gr3</code>, where <code>[FREQ]</code> are frequency names (shared with  tidal potential, in upper cases like M2) and the two 'depths' inside are amplitude (m)  and phases (degrees behind GMT). In this option, SAL is  lumped into tidal potential so it shares some parameters with tidal potential  in <code>bctides.in</code> (cut-off depth, frequencies).</p> <p>If iloadtide=2 or 3, use a simple scaling for gravity approach (in this option,  SAL is applied everywhere and does not share parameters with tidal potential). If <code>iloadtide=2</code>, a simple scaling specified by <code>loadtide_coef</code> is used to reduce  the gravity. If <code>iloadtide=3</code>, the scaling is dependent on the local depth a la Stepanov &amp; Hughes (2004),  with a maximum value of <code>loadtide_coef</code>.</p>"},{"location":"input-output/param.html#imm0-ibdef10-int","title":"imm=0, ibdef=10 (int)","text":"<p>Bed deformation option. Default: <code>0</code> (no bed deformation); <code>1</code>: with bed deformation (needs <code>ibdef</code> (# of steps during which deformation occurs), and <code>bdef.gr3</code>); 2: 3D bottom deformation (need to interact with code).</p>"},{"location":"input-output/param.html#indvel0-int-ihorcon0-int-hvis_coef00025-double-ishapiro1-niter_shap1-int-shapiro005-double","title":"indvel=0 (int), ihorcon=0 (int), hvis_coef0=0.025 (double), ishapiro=1, niter_shap=1 (int), shapiro0=0.5 (double)","text":"<p>These parameters (and <code>inter_mom</code> below) control the numerical dissipation in momentum solver; see SCHISM paper (Zhang et al. 2016) for details.</p> <p><code>indvel</code> determines the method of converting side velocity to node velocity. If <code>indvel=0</code>, the node velocity is allowed to be discontinuous across elements and additional viscosity/filter is needed to filter out grid-scale noises (spurious 'modes'). If <code>indvel=1</code>, an inverse-distance interpolation procedure is used instead and the node velocity is continuous across elements; this method requires no additional viscosity/filter unless kriging ELM is used (<code>inter_mom &gt;0</code>). In general, <code>indvel=0</code> leads to smaller numerical dissipation and better accuracy, but does generally require a velocity B.C.</p> <p>Due to spurious modes or dispersion (oscillation), viscosity/filter should be applied. <code>ihorcon=0</code>:no horizontal viscosity;  <code>=1</code>: Laplacian (implemented as a filter); <code>=2</code>: bi-harmonic. For <code>ihorcon/=0</code>, <code>hvis_coef0</code>  specifies the non-dimensional viscosity. In addition to the viscosity, one can add the Shapiro filter,  which is specified by <code>ishapiro</code> =0,\u00b11, 2 (turn off/on Shapiro filter). If <code>ishapiro=1</code>, <code>shapiro0</code>  specifies the Shapiro filter strength. If <code>ishapiro=-1</code>, an input called <code>shapiro.gr3</code> is  required which specifies the filter strength at each node (there is a pre-proc script <code>gen_slope_filter2.f90</code>  for this). If <code>ishapiro=2</code>, a Smagorinsky-like filter is applied and <code>shapiro.gr3</code> specifies the coefficient \\((\\gamma_0)\\),  which is typically 10-\\(10^3\\):</p> \\[\\begin{equation} \\label{eq01} \\begin{aligned} \\gamma &amp;= 0.5\\tanh (\\gamma_0 \\Delta t \\hat \\mu)\\\\ \\hat\\mu &amp;= \\sqrt{u_x^2 + v_y^2 + \\frac{(u_y + v_x)^2}{2}} \\end{aligned} \\end{equation}\\] <p>If <code>ishapiro/=0</code>, <code>niter_shap</code> specifies the number of times the filter is applied. </p> <p>For non-eddying regime applications (nearshore, estuary, river), an easiest option is: <code>indvel=0</code>, <code>ishapiro=1</code> (<code>shapiro0=0.5</code>), <code>ihorcon= inter_mom=0</code>.</p> <p>For applications that include the eddying regime, grid resolution in the eddying regime needs to vary smoothly (Zhang et al. 2016), and the user needs to tweak dissipation carefully. A starting point can be: <code>indvel=ishapiro=inter_mom=0</code>, <code>ihorcon=2</code>, <code>hvis_coef0=0.025</code>. If the amount of dissipation is insufficient in the non-eddying regime, consider using <code>ishapiro=-1</code>, with an appropriate <code>shapiro.gr3</code> to turn on Shapiro filter locally to add dissipation, or use <code>ishapiro=2</code> and <code>shapiro.gr3</code> with \\((\\gamma_0)\\) set to 1000 everywhere.</p>"},{"location":"input-output/param.html#inter_mom0-kr_co1-int","title":"inter_mom=0, kr_co=1 (int)","text":"<p>Interpolation method at foot of characteristic line during ELM. <code>inter_mom=0</code>: default linear interpolation; <code>=1</code>: dual kriging method. If <code>inter_mom=-1</code>, the depth in <code>krvel.gr3</code> (0 or 1) will determine the order of interpolation (linear or kriging). If the kriging ELM is used, the general covariance function is specified in <code>kr_co</code>: 1: linear \\(f(h)=-h\\); 2: \\((h^2*log(h))\\); 3: cubic \\((h^3)\\); 4: \\((-h^5)\\).</p> <p>In general, <code>indvel=0</code> should be used with <code>inter_mom=0</code> or <code>inter_mom=1, kr_co=1,2</code> to avoid large dispersion (with additional viscosity/filter also). <code>indvel=1</code> can be used with any covariance function without viscosity/filter.</p>"},{"location":"input-output/param.html#inu_elev0-inu_uv0-int","title":"inu_elev=0, inu_uv=0 (int)","text":"<p>Sponge layer for elevation and velocity (which is rarely used in SCHISM). Relaxation/nudging of a generic variable is implemented as:</p> \\[\\begin{equation} \\label{eq02} \\widetilde \\varphi = (1-\\gamma)\\varphi + \\gamma\\varphi_{target} \\end{equation}\\] <p>which is a discrete analogue of the restoration equation:</p> \\[\\begin{equation} \\label{eq03} \\frac{\\partial \\varphi}{\\partial t} = \\frac{\\gamma}{\\Delta t} \\left( \\varphi_{target} - \\varphi \\right) \\end{equation}\\] <p>If <code>inu_elev=0</code>, no relaxation is applied to elevation. If <code>inu_elev=1</code>, relaxation constants are specified in <code>elev_nudge.gr3</code> (depth=0 means no relaxation, depth=1 means strongest nudging) and the elevations are relaxed toward 0. Similarly for <code>inu_uv</code> (with input <code>uv_nudge.gr3</code>).</p>"},{"location":"input-output/param.html#inu_tr0-int-array-nu_sum_multint-step_nu_tr86400-double","title":"inu_tr(:)=0 (int array), nu_sum_mult(int), step_nu_tr=86400. (double)","text":"<p>Nudging flag for tracer models (e.g. temperature), and nudging step (in sec). When <code>inu_tr=0</code>, no nudging is done.</p> <p>When <code>inu_tr=1</code>, relax back to initial conditions.</p> <p>When <code>inu_tr=2</code>, nudge to values specified in <code>[MOD]_nu.nc</code>, which has a time step of <code>step_nu_tr</code> (in sec).</p> <p>If <code>inu_tr\u22600</code>, the horizontal relaxation factors are specified in <code>[MOD]_nudge.gr3</code> (as depths info),   and the vertical relaxation factors are specified as a linear function of depths with: <code>vnh[1,2]</code>  (transitional depths) and <code>vnf[1,2]</code> (relaxation constants at the 2 depths). The final relaxation  constant is either the sum (if <code>nu_sum_mult=1</code>) or product (if <code>nu_sum_mult=2</code>) of the two,  i.e. (horizontal <code>+ or *</code> vertical relaxation factors) times <code>dt</code>.</p>"},{"location":"input-output/param.html#inunfl0-int","title":"inunfl=0 (int)","text":"<p>Choice of inundation algorithm. <code>inunfl=1</code> can be used if the horizontal resolution is fine enough, and this is critical for tsunami simulations. Otherwise use <code>inunfl=0</code>.</p>"},{"location":"input-output/param.html#iveg0-int","title":"iveg=0 (int)","text":"<p>Parameters for submerged or emergent vegetation. If <code>iveg/=0</code>, you need to supply 4 extra inputs:  <code>veg_cd.gr3</code> (form drag coefficient), <code>veg_D.gr3</code> (depth is stem diameter in meters);  <code>veg_N.gr3</code> (depth is # of stems per m2); and <code>veg_h.gr3</code> (height of canopy in meters). These are original, unbent   values for the vegetation.</p> <p>The vertical variation/scalings for these parameters are specified for <code>nbins_veg_vert</code> vertical bins, with  <code>veg_vert_z(1:nbins_veg_vert+1)</code> specifying the distance from bed (in meters) for each bin   (ascending order starting from 0; const extrapolation is done above max).  The vertical scalings are given by <code>veg_vert_scale_[cd,N,D](1:nbins_veg_vert+1)</code>.</p> <p>If <code>iveg=1</code>, rigid cylinder option is used. If <code>iveg=2</code>, flexible vegetation formulation of Ganthy is used.  Additional parameter needed for flex case is:   <code>veg_cw</code> (a non-dimensional calibration coefficient for bending).</p>"},{"location":"input-output/param.html#itr_met3-int-h_tvd5-double","title":"itr_met=3 (int), h_tvd=5. (double)","text":"<p>Transport option for all tracers. <code>itr_met=3</code> for TVD, and <code>itr_met=4</code> for 3rd order WENO. <code>h_tvd</code> specifies the transition depth (in meters) between upwind and higher-order schemes; i.e. more efficient upwind is used when the <code>local depth &lt; h_tvd</code>.  Also in this case, you can additionally toggle between upwind and TVD by specifying regions in <code>tvd.prop</code>. The TVD limiter function is specified in <code>TVD_LIM</code> in <code>mk/include_modules</code> (for code efficiency purpose). </p> <p>If <code>itr_met=3</code>, 2 tolerances are also required (use recommended values). If <code>itr_met=4</code> (WENO), there are several additional parameters. The most important ones are <code>epsilon[12]</code>, which controls the  numerical dispersion for the 2nd and 3rd-order WENO respectively (note that the code will decide which order is used at each prism based on geometric constraints).</p>"},{"location":"input-output/param.html#itur0-int","title":"itur=0 (int)","text":"<p>Turbulence closure model selection.</p> <p>If <code>itur=0</code>, constant diffusivities are used for momentum and transport, and the diffusivities are specified in <code>dfv0</code>, <code>dfh0</code>.</p> <p>If <code>itur=-2</code>, vertically homogeneous but horizontally varying diffusivities are used, which are read in from <code>hvd.mom</code> and <code>hvd.tran</code>.</p> <p>If <code>itur=-1</code>, horizontally homogeneous but vertically varying diffusivities are used, which are read in from <code>vvd.dat</code>.</p> <p>If <code>itur=2</code>, the zero-equation Pacanowski and Philander closure is used. In this case, a few extra parameters are required: <code>h1_pp</code>, <code>vdmax_pp1</code>, <code>vdmin_pp1</code>, <code>tdmin_pp1</code>, <code>h2_pp</code>, <code>vdmax_pp2</code>, <code>vdmin_pp2</code>, <code>tdmin_pp2</code>. Eddy viscosity is computed as: \\(\\text{vdiff}=\\text{vdiff_max}/(1+\\text{rich})^2+\\text{vdiff_min}\\), and diffusivity \\(\\text{tdiff}=\\text{vdiff_max}/(1+\\text{rich})^2+\\text{tdiff_min}\\), where \\(\\text{rich}\\) is a Richardson number. The limits (<code>vdiff_max</code>, <code>vdiff_min</code> and <code>tdiff_min</code>) vary linearly with depth between depths <code>h1_pp</code> and <code>h2_pp</code>.</p> <p>If <code>itur=3</code>, then the two-equation closure schemes from the GLS model of Umlauf and Burchard (2003) are used.  In this case, 2 additional parameters are required: <code>mid</code>, <code>stab</code>, which specify the closure scheme and stability  function used: <code>mid=</code> <code>MY</code> is Mellor &amp; Yamada; <code>KL</code> is GLS as k-kl; <code>KE</code> is GLS as \\(k-\\varepsilon\\);  <code>KW</code> is GLS as \\(k-\\omega\\); <code>UB</code> is Umlauf &amp; Burchard's optimal. <code>stab=GA</code> is Galperin's clipping (only for MY);  <code>KC</code> is Kantha &amp; Clayson's stability function). Also the user needs to specify max/min diffusivity/viscosity  in <code>diffmax.gr3</code> and <code>diffmin.gr3</code>, as well as a surface mixing length scale constant <code>xlsc0</code>. Additional parameters  can be used to compute the coefficient <code>c_psi3</code> in the GOTM equations: if <code>icompute_cpsi3/=0</code>, <code>iscnd_coeff=1 to 7</code> specifies   2nd-order stability function coefficient options (e.g., 5 for Canuto A; 6 for Canuto B). <code>ri_st</code> specifies  steady-state critical Richarson number.</p> <p>If <code>itur=4</code>, GOTM turbulence model is invoked; the user needs to turn on pre-processing flag <code>USE_GOTM</code> in makefile  and recompile (GOTM5.2 uses cmake, so does not need to be pre-compiled). In this case, the minimum and maximum  viscosity/diffusivity are still specified in <code>diffmin.gr3</code>  and <code>diffmax.gr3</code>. There are some  ready-made samples for this input in the source code bundle.  A key parameter is the steady state Richardson number. If you wish to tune some parameters  inside, you may consult gotm.net for more details.</p> <p>Note</p> <ol> <li>GOTM has only been tested up to v5.2, not newer versions of GOTM. Using <code>itur=3</code> generally gave similar results, but GOTM can produce substantially better stratification in some cases.</li> </ol>"},{"location":"input-output/param.html#nadv1-int-dtb_min10-dtb_max30-double","title":"nadv=1 (int), dtb_min=10, dtb_max=30 (double)","text":"<p>Advection on/off option. If <code>nadv=0</code>, advection is selectively turned off based on the input file <code>adv.gr3</code>.  If <code>nadv=1</code> or <code>2</code>, advection is on for the whole domain, and backtracking is done using either  Euler or 2nd-order Runge-Kutta scheme. <code>dtb_[min,max]</code> are min/max sub-steps allowed in btrack; actual sub-steps are calculated based on local flow gradients.</p>"},{"location":"input-output/param.html#nchi0-int","title":"nchi=0 (int)","text":"<p>Bottom friction option. If <code>nchi=-1</code>, and Manning's \\(n\\) is specified in <code>manning.gr3</code>. If <code>nchi=0</code>, spatially varying drag coefficients are read in from <code>drag.gr3</code> (as depth info). For <code>nchi=1</code>, bottom roughnesses (in meters) are read in from <code>rough.gr3</code>.</p> <p>If <code>nchi=-1</code>, an additional parameter is required: <code>hmin_man</code> (in meters) which sets the minimum depth used in the Manning formulation.</p> <p>If <code>nchi=1</code>, one additional parameter is required: <code>dzb_min</code> (in meters). In this case the drag coefficients are calculated using the log drag law when the bottom cell thickness \\(\\delta_b&gt;=\\text{dzb_min}\\); when \\(\\delta_b&lt;\\text{dzb_min}\\), \\(\\text{Cd}=\\text{Cdmax}\\), where \\(\\text{Cdmax}=\\text{Cd}(\\delta_b=\\text{dzb_min})\\). This is to avoid exaggeration of \\(\\text{Cd}\\) in very shallow water.</p>"},{"location":"input-output/param.html#ncor0-int","title":"ncor=0 (int)","text":"<p>Coriolis option. If <code>ncor=0</code> or <code>-1</code>, a constant Coriolis parameter is specified. If <code>ncor=0</code>, <code>coricoef</code> specifies the Coriolis factor. If <code>ncor=-1</code>, <code>rlatitude</code> specifies the mean latitude used to calculate the Coriolis factor.</p> <p>If <code>ncor=1</code>, a variable Coriolis parameter, based either on a beta-plane approximation (<code>ics=1</code>) or on the latitude-dependent Coriolis (<code>ics=2</code>), is used, with the lat/lon coordinates read in from <code>hgrid.ll</code>. For <code>ics=1</code>, the center of beta-plane approximation must be correctly specified in <code>sfea0</code>.</p>"},{"location":"input-output/param.html#nws0-int-drampwind1-double-iwind_form1-int-iwindoffint-wtimincdt-double","title":"nws=0 (int), drampwind=1. (double), iwind_form=1 (int), iwindoff(int), wtiminc=dt (double)","text":"<p>Wind forcing options and the interval (in seconds) with which the wind input is read in. If <code>nws=0</code>, no  wind is applied (and <code>wtiminc</code> becomes unused). If <code>nws=1</code>, constant wind is applied to the whole domain  at any given time, and the time history of wind is read in from <code>wind.th</code>. If <code>nws=2</code>, spatially  and temporally variable wind is applied and the input consists of a number of netcdf files in the directory  sflux/. The option <code>nws=3</code> is reserved for coupling with atmospheric model via ESMF caps. If <code>nws=4</code>,  the required input <code>atmos.nc</code> specifies wind and pressure at each node and at time of multiple of <code>wtiminc</code>.  Additional inputs (e.g. heat fluxes) are needed if heat/salt exchange module is invoked. If <code>nws=-1</code> (requires USE_PAHM), use Holland parametric wind model (barotropic only with wind and atmos. pressure).  In this case, the Holland model is called every step so wtiminc is not used. An extra  input is needed: <code>hurricane-track.dat</code>.</p> <p>If <code>nws&gt;0</code>, the ramp-up period (in days) is specified with <code>drampwind</code>. Also  the user has the option to scale the wind speed using <code>iwindoff</code>=1 (which requires an additional input <code>windfactor.gr3</code>).</p> <p>The wind stress formulation is selected with <code>iwind_form</code>. </p> <ul> <li>If <code>nws=2, ihconsv=1 &amp;&amp; iwind_form=0</code>, the stress is calculated from heat exchange routine. </li> <li>If <code>nws=1</code> or <code>4</code>, or <code>nws=2 &amp;&amp; ihconsv=0</code>, or <code>nws=2 &amp;&amp; iwind_form\u2260 0</code>, the stress is calculated from Pond &amp; Pichard formulation (originally from Garret) if <code>iwind_form=-1</code>, or from Hwang (2018) if <code>iwind_form=1</code>.</li> <li>If <code>WWM</code> is enabled and <code>icou_elfe_wwm &gt; 0</code> and <code>iwind_form=-2</code>, stress is calculated by WWM.</li> </ul>"},{"location":"input-output/param.html#rho01000-shw4184-double","title":"rho0=1000, shw=4184. (double)","text":"<p>Reference water density for Boussinesq approximation and specific heat of water in J/kg/K.</p>"},{"location":"input-output/param.html#rmaxvel10-double","title":"rmaxvel=10. (double)","text":"<p>Maximum velocity. This is needed mainly for the air-water exchange as the latter may blow up if the water velocity is above 20m/s.</p>"},{"location":"input-output/param.html#s1_mxbnt05-s2_mxnbnt35-double","title":"s1_mxbnt=0.5, s2_mxnbnt=3.5 (double)","text":"<p>Dimensioning parameters used in inter-subdomain backtracking. Start from <code>s[12]_mxnbt=0.53</code>, and increase them (gradually) if you get a fatal error like \u201cbtrack: overflow\u201d. Accuracy is not affected by the choice of these two parameters; these only affect memory consumption.</p>"},{"location":"input-output/param.html#slam0-124-sfea045-double","title":"slam0=-124, sfea0=45 (double)","text":"<p>Centers of projection used to convert lat/lon to Cartesian coordinates. These are used if a variable Coriolis parameter is employed (ncor=1).</p>"},{"location":"input-output/param.html#start_year2000-start_month1-start_day1-int-start_hour0-utc_start8-double","title":"start_year=2000, start_month=1, start_day=1 (int), start_hour=0, utc_start=8 (double)","text":"<p>Starting time for simulation. <code>utc_start</code> is hours behind the GMT, and is used to adjust time zone. For example, <code>utc_start=5</code> is US Eastern Time, and <code>utc_start= -8</code> is Beijing Time.</p> <p>Note</p> <ol> <li>SCHISM's view of the time origin is relatively simple. The code starts from t=0 and marches with time step <code>dt</code> under cold start. It starts from a specified time upon hot start. </li> <li>There are only 2 exceptions: (1) in air-sea exchange (<code>ihconsv=1</code>), the origin info (including <code>utc_start</code>) specified in these parameters will be compared against the time origins in each <code>sflux</code> file to determine the starting stack; (2) WWM manages its own time origins in <code>wwminput.nml</code>; it's advisable to align the latter with SCHISM's origin.</li> </ol>"},{"location":"input-output/param.html#thetai06-double","title":"thetai=0.6 (double)","text":"<p>Implicitness parameter (between 0.5 and 1). Recommended value: 0.6. Use '1' to get maximum stability for strong wet/dry.</p>"},{"location":"input-output/param.html#vclose_surf_frac01-double","title":"vclose_surf_frac0=1 (double)","text":"<p>Coefficient to adjust the vertical velocity. <code>1</code> would keep the orignal value, while &lt;1 would reduce the surface value,   keeping the conservation. If <code>vclose_surf_frac0&lt;0</code>, needs vclose.gr3 (depth in [0,1]).</p>"},{"location":"input-output/param.html#schout-block","title":"SCHOUT block","text":""},{"location":"input-output/param.html#iout_sta0-nspool_sta10-int","title":"iout_sta=0, nspool_sta=10 (int)","text":"<p>Station output flag. If <code>iout_sta\u22600</code>, an input station.in is needed. In addition, <code>nspool_sta</code> specifies the spool for station output. In this case, make sure <code>nhot_write</code> is a multiple of <code>nspool_sta</code>. If <code>iout_sta=1</code>, each line of outputs <code>staout_[1-]</code> represents time series of the variable at each station location (and vertical   location for 3D variables). If <code>iout_sta=2</code>, 2 lines of outputs are produced at each time step: the odd lines are same as <code>iout_sta=1</code>,  and the even lines are 3D profiles - see <code>Utility/Post-Processing-Fortran/read_staout.f90</code> for the profile format.</p>"},{"location":"input-output/param.html#iof_ugrid-0-int","title":"iof_ugrid = 0 (int)","text":"<p>UGRID option for 3D outputs under scribed IO (<code>out2d_*.nc</code> always has metadata info). If <code>iof_ugrid &gt; 0</code>, 3D outputs will contain UGRID and CF metadata. if <code>iof_ugrid == 1</code>,  3D output contains UGRID mesh data at the expense of file size; if <code>iof_ugrid == 2</code>, 3D output references mesh data in the 2D output.</p>"},{"location":"input-output/param.html#nc_out-1int","title":"nc_out =1(int)","text":"<p>Main switch to turn on/off netcdf outputs, useful for other programs (e.g., ESMF) to control outputs.</p>"},{"location":"input-output/param.html#nhot0-nhot_write8640-int","title":"nhot=0, nhot_write=8640 (int)","text":"<p>Hot start output control parameters. If <code>nhot=0</code>, no hot start output is generated. If <code>nhot=1</code>,  hotstart output is named <code>outputs/hotstart_[process_id]_[it].nc</code> every <code>nhot_write</code>  steps, where <code>it</code> is the corresponding time iteration number. <code>nhot_write</code> must be a multiple of  <code>ihfskip</code> and <code>nspool_sta</code>. If you want to hotstart a run from step <code>it</code>, you need to combine all process-specific  hotstart outputs into a <code>hotstart.nc</code> using <code>combine_hotstart7.f90</code> (<code>./combine_hotstart7 -h</code> for help).</p>"},{"location":"input-output/param.html#iof_-int","title":"iof_* (int)","text":"<p>Global output (in netcdf4 format) options, where <code>*</code> stands for module name (e.g. \"hydro\", \"wwm\" etc).  The frequency of global outputs is controlled by 2 parameters in CORE:  <code>nspool</code> and <code>ihfskip</code>. Output is done every  <code>nspool</code> steps, and a new output stack is created every <code>ihfskip</code> steps. </p> <p>Under OLDIO, the outputs are named as <code>outputs/schout_[MPI process id]_[1,2,3,...].nc</code> etc. The combine scripts  are then used to gather each output variable across all MPI processes into a single output, e.g., <code>schout_[1,2,3\u2026].nc</code>.</p> <p>With new scribed I/O, outputs look like <code>out2d_1,2,3\u2026].nc</code> etc (and no combining is necessary). In this mode,  all 2D outputs are found in <code>out2d*</code> and each 3D output (note that vector output like horizontal velocity counts as 2  outputs) has its own netcdf files, e.g. <code>salinity_[1,2..].nc</code>, <code>horizontalVelX_[1,2..].nc</code> etc.</p> <p>Each output variable is controlled by an I/O flag in <code>param.nml</code>. We only show a few examples below;  the rest are similar. Note that variables may be centered at nodes/sides/elements horizontally and  whole/half levels vertically. However, at the moment most variables are centered at nodes and whole levels,  and most post-processing FORTRAN scripts can only handle this type of outputs (while VisIT can handle other types).</p> <pre><code>iof_hydro(1) = 1 !global elevation output control. If iof_hydro(1)=0, no global elevation is recorded. \n                 !If iof_hydro(1)= 1, global elevation for each node is recorded.\n                 !The output is either starting from scratch or appended to existing ones depending\n                 !on ihot.\n</code></pre> <p>Some outputs are conditional upon you turn on certain module; e.g. <code>iof_sed(7) = 1</code> won\u2019t output  the bottom depth change unless you turn on <code>USE_SED</code> in makefile.</p> <p>Some \u2018native\u2019 variables (e.g., element- or side-centered) are:</p> <pre><code>iof_hydro(27) = 1 !horizontal velocity defined at side [m/s]. These are the original velocity inside SCHISM\n</code></pre>"},{"location":"input-output/sflux.html","title":"Atmospheric flux (/sflux)","text":"<p>The <code>sflux/</code> dir is required if <code>nws=2</code>. In this case, atmoserpic forcings include wind, air pressure and temperature, precipitation, humidity and longwave and shortwave fluxes. These are specified in the netcdf files inside <code>sflux/</code> dir, and conform to the NetCDF Climate and Forecast (CF) Metadata Convention 1.0.</p> <p>There are 4 types of files in sflux/dir; see this site for sample files.</p> <ol> <li>sflux_inputs.txt: This asci file is a namelist</li> <li>sflux_air_1.X.nc: netcdf files that have time (in days), wind speed at 10m above MSL (u,v), air temperature and pressure and specific humidity;</li> <li>sflux_prc_1.X.nc: netcdf files that time (in days), have precipitation data;</li> <li>sflux_rad_1.X.nc: netcdf files that have time (in days), downward long and short (solar) wave radiation fluxes.</li> </ol> <p>Note that X denotes the time stack number (1,2,3,...). There is no limit on max.</p> <p>sflux_input.txt</p> <p>sflux_input.txt has the following basic structure - </p> <p><pre><code>&amp;sflux_inputs ! file name\n/\n</code></pre> All parameters inside this input are optional. Advanced users may consult the source code for a complete list of parameters. Additionally, see sample_input for a detailed example file.</p> <p>sflux_air</p> <pre><code>netcdf sflux_air_1.10 {\ndimensions:\n        nx_grid = 349 ;\n        ny_grid = 277 ;\n        time = UNLIMITED ; // (8 currently)\nvariables:\n        float time(time) ;\n                time:long_name = \"Time\" ;\n                time:standard_name = \"time\" ;\n                time:units = \"days since 2001-01-01\" ;\n                time:base_date = 2001, 1, 1, 0 ;\n        float lon(ny_grid, nx_grid) ;\n                lon:long_name = \"Longitude\" ;\n                lon:standard_name = \"longitude\" ;\n                lon:units = \"degrees_east\" ;\n        float lat(ny_grid, nx_grid) ;\n                lat:long_name = \"Latitude\" ;\n                lat:standard_name = \"latitude\" ;\n                lat:units = \"degrees_north\" ;\n        float uwind(time, ny_grid, nx_grid) ;\n                uwind:long_name = \"Surface Eastward Air Velocity (10m AGL)\" ;\n                uwind:standard_name = \"eastward_wind\" ;\n                uwind:units = \"m/s\" ;\n        float vwind(time, ny_grid, nx_grid) ;\n                vwind:long_name = \"Surface Northward Air Velocity (10m AGL)\" ;\n                vwind:standard_name = \"northward_wind\" ;\n                vwind:units = \"m/s\" ;\n        float prmsl(time, ny_grid, nx_grid) ;\n                prmsl:long_name = \"Pressure reduced to MSL\" ;\n                prmsl:standard_name = \"air_pressure_at_sea_level\" ;\n                prmsl:units = \"Pa\" ;\n        float stmp(time, ny_grid, nx_grid) ;\n                stmp:long_name = \"Surface Air Temperature (2m AGL)\" ;\n                stmp:standard_name = \"air_temperature\" ;\n                stmp:units = \"K\" ;\n        float spfh(time, ny_grid, nx_grid) ;\n                spfh:long_name = \"Surface Specific Humidity (2m AGL)\" ;\n                spfh:standard_name = \"specific_humidity\" ;\n                spfh:units = \"1\" ;\n\n// global attributes:\n                :Conventions = \"CF-1.0\" ;\n}\n</code></pre> <p>sflux_prc</p> <pre><code>netcdf sflux_prc_1.10 {\ndimensions:\n        nx_grid = 349 ;\n        ny_grid = 277 ;\n        time = UNLIMITED ; // (8 currently)\nvariables:\n        float time(time) ;\n                time:long_name = \"Time\" ;\n                time:standard_name = \"time\" ;\n                time:units = \"days since 2001-01-01\" ;\n                time:base_date = 2001, 1, 1, 0 ;\n        float lon(ny_grid, nx_grid) ;\n                lon:long_name = \"Longitude\" ;\n                lon:standard_name = \"longitude\" ;\n                lon:units = \"degrees_east\" ;\n        float lat(ny_grid, nx_grid) ;\n                lat:long_name = \"Latitude\" ;\n                lat:standard_name = \"latitude\" ;\n                lat:units = \"degrees_north\" ;\n        float prate(time, ny_grid, nx_grid) ;\n                prate:long_name = \"Surface Precipitation Rate\" ;\n                prate:standard_name = \"precipitation_flux\" ;\n                prate:units = \"kg/m^2/s\" ;\n\n// global attributes:\n                :Conventions = \"CF-1.0\" ;\n}\n</code></pre> <p>sflux_rad</p> <pre><code>netcdf sflux_rad_1.10 {\ndimensions:\n        nx_grid = 349 ;\n        ny_grid = 277 ;\n        time = UNLIMITED ; // (8 currently)\nvariables:\n        float time(time) ;\n                time:long_name = \"Time\" ;\n                time:standard_name = \"time\" ;\n                time:units = \"days since 2001-01-01\" ;\n                time:base_date = 2001, 1, 1, 0 ;\n        float lon(ny_grid, nx_grid) ;\n                lon:long_name = \"Longitude\" ;\n                lon:standard_name = \"longitude\" ;\n                lon:units = \"degrees_east\" ;\n        float lat(ny_grid, nx_grid) ;\n                lat:long_name = \"Latitude\" ;\n                lat:standard_name = \"latitude\" ;\n                lat:units = \"degrees_north\" ;\n        float dlwrf(time, ny_grid, nx_grid) ;\n                dlwrf:long_name = \"Downward Long Wave Radiation Flux\" ;\n                dlwrf:standard_name = \"surface_downwelling_longwave_flux_in_air\" ;\n                dlwrf:units = \"W/m^2\" ;\n        float dswrf(time, ny_grid, nx_grid) ;\n                dswrf:long_name = \"Downward Short Wave Radiation Flux\" ;\n                dswrf:standard_name = \"surface_downwelling_shortwave_flux_in_air\" ;\n                dswrf:units = \"W/m^2\" ;\n\n// global attributes:\n                :Conventions = \"CF-1.0\" ;\n}\n</code></pre> <p>Note that <code>sflux_rad</code> is only required if the heat exchange module is invoked via <code>ihconsv=1</code>, and <code>sflux_prc</code> is only required if the salt exchange module is invoked via <code>isconsv=1</code>. Since a barotropic model cannot do heat/salt exchange properly, these two types of sflux inputs should not be used there. To impose rainfall in a  barotropic model,  you may use the source/sink option <code>if_source</code> by converting rainfall rate into sources.</p> <p>We have NARR sflux files from 1979-present, but cannot upload all of them to the web due to disk space limitation. You can find some samples at http://ccrm.vims.edu/yinglong/wiki_files/NARR/.</p> <p>Two sources of data are allowed for each type of <code>.nc</code> files, and the relative priority is fixed by the file name. For instance <code>sflux_air_1.3.nc</code> might be blended with a file called <code>sflux_air_2.3.nc</code>. The \".3\" component of the name represents the order of the file within the stack of provided input files. For instance, there might be a new file (<code>1</code>, <code>2</code>, <code>3</code>) produced every 12 hours in a forecast cycle.</p>"},{"location":"input-output/sflux.html#interpolation-and-prioritization","title":"Interpolation and prioritization","text":"<p>Using air as an example, it is assumed that the file <code>sflux_air_2.1.nc</code> is more resolved or accurate than sflux_air_1.1.nc. The two will be blended in the model in a way that favors the \u2018_2\u2019 file. This blending of the fields is only adjustable in the code as described in notes below. The default in sflux_9c.F90 is a 99:1 blend of the \u2018_2\u2019 file to the \u2018_1\u2019 file.</p> <p>As was remarked above, the files are arranged temporally in a stack of files starting with \".1\". Given the sequence of forecasting and analysis, it is common for atmospheric files to overlap. A file might begin with a brief period of data assimilation plus a few days of forecast. SCHISM assumes that a new file indicates the injection of information, so when it encounters overlap, it advances to the later file.</p>"},{"location":"input-output/sflux.html#using-narr-files-for-your-simulation-north-america-only","title":"Using NARR files for your simulation (North America only)","text":"<p>First, make sure the NARR grid covers your <code>hgrid.ll</code> to ensure proper sptatial interpolation.</p> <p>In your run directory, <code>mkdir sflux</code> and inside it, create symbolic links to the NARR files. e.g., if you run starts from June 10, 2004 and ends June 20, 2004, then</p> <pre><code>sflux_air_1.1.nc --&gt; narr_air.2004_06_10.nc\nsflux_air_1.2.nc --&gt; narr_air.2004_06_11.nc\n...\nsflux_air_1.11.nc --&gt; narr_air.2004_06_20.nc\nsflux_air_1.12.nc --&gt; narr_air.2004_06_21.nc # (extra day to account for time zone difference)\n</code></pre> <p>Similarly for <code>sflux_rad_*.nc</code> and <code>sflux_prc_*.nc</code>. As described above, the number \"1\" after \"air_\" denotes the first data set used, with the second set taking priority; you can use up to 2 sets in SCHISM (which combines them with some given weights set in sflux_subs.F90); we only use 1 set in this example.</p>"},{"location":"input-output/sflux.html#global-sflux-ncep-cfsr","title":"Global sflux - NCEP CFSR","text":"<p>This web site has many global atmospheric model files, and a very useful source is the NCEP's CFSR. Note that you need to register yourself at the site first.</p> <p>Simply select 'NCEP Climate Forecast System Reanalysis (CFSR)', and then CFSRv2. Under 'Data Access' you can get a sub-set (instead of global files). Then select all variable required by SCHISM:</p> <ul> <li>Wind u,v at 10m</li> <li>(Air) pressure reduced to MSL</li> <li>(Air) temperature at 2m AGL</li> <li>Specific humidity at 2m AGL</li> <li>Downward longwave radiation flux at ground level</li> <li>Downward shortwave radiation flux at ground level</li> <li>Precipitation rate at ground level</li> </ul> <p>In the new window, select output format as netcdf, and remember to restrict the vertical heights for each variable. Note that pressure is given at a different grid than other variables and so you'd do it separately. You can select a region and computational grid and temporal resolution etc and then submit the request.</p> <p>Once you have downloaded the (compressed) netcdf files, you can use these 3 matlab scripts to process them into <code>sflux_[air,rad,prc]*.nc</code>. Note that the files are bundled differently for difference period (e.g. before and after Oct. 1, 2011) and so you may need to modify those scripts slightly.</p>"},{"location":"input-output/sflux.html#preparing-your-own-sflux-inputs","title":"Preparing your own sflux inputs","text":"<p>After familiarize yourself with the NARR files and their format, you may embark on creating your own nc files. The best way is to modify existing matlab scripts (<code>src/Utility/Sflux_nc/readnc*.m</code>) included in the source code bundle, which have extensively in-line comments to guide you along the way.</p> <p>Since the time and space interpolation will be used to interpolate sflux info onto hgrid.ll at runtime, you need to make sure that the lon/lat grid in <code>sflux_*_1.*</code> covers <code>hgrid.ll</code>, and the union of time records in <code>sflux*.nc</code> covers the entire simulation period. The time zone info is given by <code>utc_start</code>, and you may pre-pend some records if this value is negative (eastern hemisphere) or append if it is positive. Even if <code>utc_start=0</code>, the code will need at least one time record beyond <code>rnday</code> for interpolation; simply duplicate the record at <code>rnday</code> if you do not have such info.</p> <p>Wind convention</p> <p>u-component is eastward, v-comp. is northward (normal math convention, not compass convention)</p> <p>Additional files</p> <ul> <li><code>windrot_geo2proj.gr3</code>: rotates winds in case they do not align with coordinate axes, i.e. lat/lon </li> </ul> <p>Some details from sflux_9c.F90</p> <ul> <li>Of all attributes in nc file, only 'base_date' is required. This is the time origin used in each file and the \u2018time\u2019 is then the offset (in days) from this origin. Note that the last number (hour) is NOT used and UTC is always assumed in each file. Use <code>utc_start</code> in <code>param.nml</code> to adjust time zone;</li> <li>The grids for air, rad and prc can be different (but must be the same within each type and each source). Additional requirements for the structured grid in .nc: lon,lat give x,y coord., nx is # of pts in x. Suppose a node in the grid is given by (i,j) (1&lt;=i&lt;=nx), then the quad (i,j), (i+1,j), (i+1,j+1,i,j+1) can be in either counter-clockwise or clockwise direction (but must be self consistent within each set - no mix-and-match);</li> <li>Search for \"relative_weight\" (inside <code>netcdf_io</code>) to change relative weights of the 2 sources for air, rad and prc if needed. All weights must &gt; 0!</li> <li>in case of 2 sources/grids for a variable, use \"1\" as larger grid (i.e. encompassing hgrid.ll) and \"2\" as smaller grid. The code will calculate weights associated with the 2 grids, and if some nodes in hgrid.ll fall outside grid \"2\" the interpolation will be done on grid \"1\" only (see combine_sflux_data, in particular, bad_node_ based on area coordinates outside [0,1]). Both grids must start from stack 1 but may have different # of stacks for each variable. Within each nc file # of time steps can vary. The cumulative time window of '2' does not need to cover the entire simulation (code will use values from '1' only if '2' time is missing), but window of '1' must;</li> <li><code>air_1_max_window_hours</code> (etc) are set in netcdf_io to define the max time stamp (offset from time origin) within each nc file. Besides those in netcdf_io, max_file_times (max. #of time records in each nc file) in routine get_times_etc() may need to be adjusted as well.</li> </ul>"},{"location":"input-output/vgrid.html","title":"Vertical grid (vgrid.in)","text":"<p>See Numetical Formulation chapter for details of different types of vgrid supported in SCHISM. Following are a few example <code>vgrid.in</code>.</p>"},{"location":"input-output/vgrid.html#an-example-of-sz-grid","title":"An example of SZ grid","text":"<pre><code>2 !ivcor (1: LSC2; 2: SZ)\n54 18 100. !nvrt(=Nz); kz (# of Z-levels); hs (transition depth between S and Z)\nZ levels !Z-levels in the lower portion\n1 -5000. !level index, z-coordinates\n2 -2300.\n3 -1800.\n4 -1400.\n5 -1000.\n6 -770.\n7 -570.\n8 -470.\n9 -390.\n10 -340.\n11 -290.\n12 -240.\n13 -190.\n14 -140.\n15 -120.\n16 -110.\n17 -105.\n18 -100. !z-coordinate of the last Z-level must match -h_s\nS levels !S-levels below\n30. 0.7 10. ! constants used in S-transformation: hc, theta_b, theta_f\n18 -1.\n !first S-level (sigma-coordinate must be -1)\n19 -0.972222\n !levels index, sigma-coordinate\n20 -0.944444\n.\n.\n.\n54 0.\n !last sigma-coordinate must be 0\n</code></pre> <p>Notes:  - The water column is from the bottom (<code>kbp</code>, variable in space) to surface (level <code>nvrt</code>) at each node;  - The code will crash if the surface elevation falls below \\(\u2013h_c\\) so make sure \\(h_c\\) is sufficiently large (there is a hardwired lower bound for this around 5m in the code).</p>"},{"location":"input-output/vgrid.html#an-example-of-pure-s-grid","title":"An example of pure S grid","text":"<p>If a \"pure S\" model is desired, use only 1 Z-level and set hs to a very large number (e.g., 1.e6) above. For example, using vgrid.in below leads to a 2D model.</p> <pre><code>2 !ivcor\n2 1 1.e6\nZ levels\n1 -1.e6\nS levels\n40. 1. 1.e-4\n1 -1.\n2 0.\n</code></pre>"},{"location":"input-output/vgrid.html#an-example-of-lsc2-grid","title":"An example of \\(LSC^2\\) grid","text":"<p>This type of grid requires some user experience and can be generated using scripts (e.g., <code>Utility/Pre-Processing/gen_vqs*.f90</code>).  There is no limit such as \\(h_c\\) mentioned above, so \\(LSC^2\\) is more robust.</p> <pre><code>1 !ivcor (1: LSC2; 2: SZ)\n39 !nvrt(=Nz)\n10 4 4 4 4 10 4 10 10 ...  !bottom level indces at all nodes\n1 -1. -1. -1. -1. -9. -9. -9. ... !level #, sigma coordinates $\\in [-1,0]$ at level 1 for all nodes. '-9' means level 1 is below the bottom of this node\n2 -0.884251  -0.874424  -0.888763 -0.884930 -1. ... \n</code></pre> <p>Also see illustrations below:</p> <p> </p>"},{"location":"mesh-generation/cross_regime.html","title":"Meshing for cross-scale regimes","text":"<p>Mesh generation is most challenging in applications that include eddying (open deep ocean), non-eddying,   and the transitional regimes between the previous two regimes. The challenge here is mostly related to    the different physics requirements rather than numerics between eddying and non-eddying regimes. Danilov &amp; Wang (2015)   demonstrated that the mesh in the eddying regime should vary smoothly to not distort eddying processes. This  is understandable also because the bathymetric variations in the deep ocean do not play as an important role  as in non-eddying regime, so there is no compelling reason to drastically vary mesh resolution there. </p> <p>One common mistake users make is to over-refine in eddying and transitional regimes. This actually  violate the hydrostatic assumption (the horizontal scale &gt;&gt; vertical scale). For example,   setting mesh resolution at 500m at 500m depth would likely lead to spurious 'upwelling' (Figure 2). </p> <p>To get a good SCHISM baroclinic setup for this type of applications, one needs to pay attention to </p> <ol> <li>Horizontal mesh</li> <li>Vertical grid: use \\(\\text{LSC}^2\\), and at least resolve the surface layer</li> <li>Parameterization: especially important are parameters that control momentum dissipation (<code>indvel</code>, <code>ihorcon</code>, <code>ishapiro</code>, <code>dt</code>)</li> </ol> <p>The example of South China Sea (SCS) shown below illustrates this type of mistakes made by users (Figure 1). A particularly severe challenge is a transitional regime (between eddying and non-eddying regimes) with steep slopes that tend to excite parasitic noises (if the mesh resolution is too fine), and a common symptom for this manifests itself as spurious upwelling of cold water (Figure 2).</p> <p></p> (a) \u2018Wrong\u2019 map for SCS, showing multiple issues with grid design. Steep slopes are prevalent in this region, near small islands and continental shelf breaks. (b) grid near Spratly, showing excessively high resolution in deep water (0.01 degree ~ 1 km). <p></p> Surface temperature (SST) resulted from the grid generated from Figure 1, showing the excessive spurious upwelling of cold water. <p>For meshgen, always start with modest and quasi-uniform resolution for eddying regime. In SMS,  this can be achieved with fewer constraints in the form of arcs. High resolution (&lt;=2km) in deep water (h&gt;=1km) should be avoided (Figure 1). At steep slopes, this means that an \u2018outer arc\u2019 (in SMS map) may be needed. With the corrected mesh, the noise is greatly reduced: the remaining noise in southern Philippines can be rectified by adding outer arcs there (Figure 4).</p> <p></p> A corrected SMS map file. Outer arcs are added near shelf break of west coast of Luzon and Spratly Islands, but are missing in the southern Philippines. <p></p> SST calculated from the corrected grid. The remaining \u2018upwelling\u2019 in the circled area is due to the missing outer arcs in that area (cf. Figure 3). <p>Parameters <code>dt=100s</code> (slightly larger values like 120 s should also work), <code>indvel=0</code>, <code>ihorcon=2</code>, <code>ishapiro= -1</code>. <code>shapiro.gr3</code> is then generated using <code>gen_slope_filter2.f90</code> by using larger filter strengths near steep slopes (and small elsewhere). Figure 5a shows the resultant input. In general, the momentum needs to be stabilized with larger viscosity near steep slopes, as bi-harmonic viscosity alone is not sufficient there. Other pre-processing is same as before: the I.C. and B.C. can be derived from HYCOM and FES 2014 (i.e. use type \u20185\u2019 for both elevation and velocity B.C.). In addition, tracers are relaxed to HYCOM values near open boundaries (Figure 5b). Required pro-processing scripts can be found in <code>Utility/</code>.</p> <p>Starting from v5.9, users can also try the new Smagorinsky\u2013like filter option (<code>ishapiro=2</code>) with a proper <code>shapiro0</code>.</p> <p></p> (a) Filter strength input (shapiro.gr3). Larger values are used near steep slopes. (b) Nudging strength input (TEM_nudge.gr3, SAL_nudge.gr3), generated from gen_slope_filter2.f90, with maximum time scale of 1 day. <p>The meshing challenge is particularly acute when one deals with islands sitting on top of steep slopes. Figure 6 shows 3 attempts to add high resolution near Guam in the Pacific basin mesh. The mesh resolution in the surrounding deep ocean is about 5km, and we need to refine the mesh to about 30m around Guam. The Apra Harbor jetty that requires higher resolution happens to be located close to a steep slope. Combination of wet/dry and forced sharp transition in \u2018new14\u2019 and \u2018new15\u2019 led to spread of upwelled water there. Removing an inner arc in \u2018new15\u2019 helped smoother transition from the outer arc to the inner arc and thus alleviated the upwelling issue. In \u2018new16\u2019, we made more \u2018room\u2019 for transition by moving the inner arc away from the outer arc and coarsening it a little (to match the resolution of the outer arc), thus further reducing the upwelling. However, we had to add more internal arcs to provide adequate resolution nearshore (otherwise the nearshore area would be represented by a few skew elements that have side lengths of a few km\u2019s on the outside and 30m on the inside). Figure 7 shows the details of \u2018new16\u2019 and final mesh. Note that in all three maps, we used 500m isobaths for the outer arc (as representation of start of eddying regime) but the arc veered to 1km isobaths near the harbor as a way to make more room for transition there.</p> <p></p> Three SMS maps (top) and corresponding results for SST. <p></p> Details for map \u2018new16\u2019 and the final mesh around Apra Harbor. Skew elements nearshore are fine. <p>Sub-mesoscale</p> <p>If sub-mesoscale processes are of interest, one may need to reduce time step below 100 sec or apply some special parameterization such as <code>niter_shap</code> etc.</p>"},{"location":"mesh-generation/cross_regime.html#references","title":"References","text":"<p>Danilov, Sergey &amp; Wang, Qiang. (2015). Resolving eddies by local mesh refinement. Ocean Modelling. 93. 10.1016/j.ocemod.2015.07.006. </p>"},{"location":"mesh-generation/overview.html","title":"Overview","text":"<p>This chapter discusses best practice of mesh generation for complex projects and provides tutorials for different mesh generation tools/procedures.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/extract-thalweg.html","title":"Extract thalwegs from DEM","text":""},{"location":"mesh-generation/meshing-for-compound-floods/extract-thalweg.html#background","title":"Background","text":"<p>Extracting channel networks from grid digital elevation models (DEMs) follows these precedures: (1) fill depressions/sinks in the original DEM; (2) calcuate flow direction and flow accumulation based on eight-direciton method (D8); (3) determine the flow accumulation threshold to derive a digital stream network.</p> <p>Flow accumulation threshold is a parameter that identifies grids with flow accumulation greater than the threshold as a stream network. It varies with DEM resolution, raster size and geomorphic complexity. The optimal threshold is a trial and error based on user's goal. The smaller threhold will generate denser network. Below are river network extracted with three different threshold: 1e5, 1e6, and 1e7, respectively:  </p> <p> </p>"},{"location":"mesh-generation/meshing-for-compound-floods/extract-thalweg.html#scripts","title":"Scripts","text":"<p>pyDEM  can be downloaded from the RiverMeshTools repository.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/extract-thalweg.html#dependencies","title":"Dependencies","text":"<p>numpy GDAL geopandas shapely richdem </p>"},{"location":"mesh-generation/meshing-for-compound-floods/extract-thalweg.html#workflow","title":"Workflow","text":"<ol> <li> <p>Pre-processing DEM (optional) 1.1 Split large files  Sometimes, it is necessary to split large tif files into smaller ones to avoid memory issues. Script split2tiles.py serves for this purpose: <pre><code>import os, sys\nfrom osgeo import gdal\n\ndset = gdal.Open(sys.argv[1])\n\nwidth = dset.RasterXSize\nheight = dset.RasterYSize\n\ntilesize = 8100\n\nfor i in range(0, width, tilesize):\n    for j in range(0, height, tilesize):\n        w = min(i+tilesize, width) - i\n        h = min(j+tilesize, height) - j\n        gdaltranString = \"gdal_translate -ot Float32 -of GTIFF -srcwin \"+str(i)+\", \"+str(j)+\", \"+str(w)+\", \" \\\n            +str(h)+\" \" + sys.argv[1] + \" \" + sys.argv[2] + \"_\"+str(i)+\"_\"+str(j)+\".tif\"\n        os.system(gdaltranString)\n</code></pre> Run the script with this command: <pre><code>python split2tiles.py japan_dem_with_ocean.tif tiles/japan_tile\n</code></pre> Create tileindex shapefile, which will be used in the next step: <pre><code>gdaltindex tileindex_japan_dem.shp tiles/*.tif\n</code></pre> 1.2 Merge tiles This process is needed when Each tile and its 8-connected rasters are mereged into one raster file, which will be used in the next step.  <pre><code>import subprocess\nimport multiprocessing as mp\n\nimport numpy as np\nimport geopandas as gpd\nfrom osgeo import gdal\n\ndef merge_tiles(itile, df, maps, locations):\n    dx = [-8100, 0,     8100,  -8100,  0, 8100, -8100, 0,    8100]\n    dy = [-8100, -8100, -8100, 0,      0, 0,    8100,  8100, 8100]\n\n    ullon, ullat = int(df.location.split('_')[2]), int(df.location.split('_')[3].split('.')[0])\n\n    tiles = []\n    for j in np.arange(9):\n        try:\n            ilon = ullon + dx[j]\n            ilat = ullat + dy[j]\n\n            key2 = f'{ilon}_{ilat}'\n            tile_idx = tilemaps[key2]\n            tiles.append(locations[tile_idx])\n        except:\n            print(f'No tile')\n\n    cmd = f'gdal_merge.py -n -9999 -o Merged/JAPAN_merged_{str(itile).zfill(3)}.tif'\n    subprocess.call(cmd.split()+tiles)\n\nif __name__ == '__main__':\n\n    gdf = gpd.read_file('tileindex_japan_dem.shp')\n    tilemaps = dict()\n    for i, p in enumerate(gdf['location']):\n        x = gdf.iloc[i].location.split('_')[2]\n        y = gdf.iloc[i].location.split('_')[3].split('.')[0]\n        key = f'{x}_{y}'\n        tilemaps[key] = i\n\n    npool = 15\n    pool = mp.Pool(npool)\n    pool.starmap(merge_tiles, [(i, gdf.iloc[i], tilemaps, gdf['location']) for i in np.arange(len(gdf))])\n    pool.close()\n    del pool\n</code></pre></p> </li> <li> <p>Extract channel networks  </p> </li> </ol> <p>Extracting channel networks consists of three steps:  </p> <ul> <li> <p>Fill or breach depressions  </p> <p>Algorithm \"Priority-Flood + \\(\\epsilon\\)\" (Barnes et al., 2014) is used to fill depressions. </p> </li> <li> <p>Calculate flow directions based on the given flow coordinate system. In pyDEM, flow directions use a D8 flow coordinate system that appears as follow: </p> </li> </ul> D8 flow coordinate system consisted of 9 raster cells. The numbers are local indices that correpond to each neighbor of the center cell.  <ul> <li> <p>Calculate flow accumulation  </p> <p>Flow accumulation is the total number of cells passing through each (raster) cell. With flow accumulations, we can apply a presccribed  threshold to determine which cells should be included in the final digital stream network. </p> </li> </ul> <p>The details of the algorithm can be found in Ye et al. (2023).</p>"},{"location":"mesh-generation/meshing-for-compound-floods/extract-thalweg.html#sample-applications","title":"Sample applications","text":"<p>Two example applications can be found under subdirectories from pyDEM_Samples.tar. The subdirectory \"Serial\" contains a Python script <code>run_serial.py</code> and an input file <code>tiff/Savannah_river.tif</code>. This can be used for a small domain.  The script reads: </p> <p><pre><code>import glob\nimport time\nfrom pylib import *\nfrom pyDEM.dem import *\nimport numpy as np\n\nnp.seterr(all='raise')\n\nif __name__ == '__main__':\n    #input tiff files\n    files = glob.glob('tiff/Savannah_river.tif')\n    files.sort()\n\n    acc_limit = 1e7\n    t0 = time.time()\n\n    for fname in files:\n        names = [fname]\n\n        #output filename\n        sname = f\"./{fname.split('.')[0].split('/')[-1]}_{acc_limit}\"\n        print(sname)\n\n        #declare a dem object\n        S=dem()\n\n        #read data\n        if not os.path.exists('{}.npz'.format(sname)):\n            S.proc_demfile(names,sname=sname,depth_limit=[-100,1000],subdomain_size=2e10)\n        S.read_data('{}.npz'.format(sname))\n\n        #compuate watershed information\n        S.compute_watershed()\n\n        #extract river network (area_limit: catchment area)\n        S.compute_river(acc_limit=acc_limit)\n\n        #write shapefile for river network\n        gdf = S.write_shapefile(npt_smooth=None)\n        gdf.to_file(f'{sname}.shp')\n        print(f'It took {(time.time() - t0)/60} mins!')\n</code></pre> For a large domain, a parallel dirver is preferred to speed up the process. A sample script is under Parallel/, named <code>run_mpi_vortex.py</code>,  which can run with multiple nodes/cpus with <code>mpi4py</code>.</p> <p>References</p> <p>C. Barnes, R., Lehman, C., Mulla (2014). Priority-flood: An optimal depression-filling and watershed-labeling algorithm for digital elevation models. Computers &amp; Geosciences 62, 117\u2013127. doi:10.1016/j.cageo.2013.04.024.</p> <p>Barnes, Richard. 2016. RichDEM: Terrain Analysis Software. http://github.com/r-barnes/richdem. </p> <p> Ye, F., Cui, L., Zhang, Y., Wang, Z., Moghimi, S., Myers, E., Seroka, G., Zundel, A., Mani, S., Kelley, J.G.W.  A parallel Python-based tool for meshing watershed rivers at continental scale, Environmental Modelling &amp; Software, 166. https://doi.org/10.1016/j.envsoft.2023.105731.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html","title":"Generate river map","text":""},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#scripts","title":"Scripts","text":"<p>RiverMapper is available in the RiverMeshTools repository maintained by schism-dev.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#usage","title":"Usage","text":"<p>RiverMapper requires two inputs:</p> <ol> <li> <p>*.tif files \u2014 DEM tiles in lon/lat coordinates, from one or more sources.</p> </li> <li> <p>A shapefile of 'LineString' type, representing a 1D river network.</p> </li> </ol> <p>Note</p> <p>The 1D river network can be any reasonable approximation of the thalwegs. It may be: <ul> <li>Extracted from DEMs using the method described in the previous section</li> <li>Copied from the river network of a hydrological model, such as the National Water Model</li> <li>Manually drawn for quick local touch-ups</li> </ul></p> <p>The outputs include:</p> <ul> <li> <p><code>total_river_arcs.map</code> \u2014 river arcs used for final meshing in SMS.</p> </li> <li> <p>Additional *.map files for diagnostic purposes.</p> </li> </ul> <p>A sample output looks like this:</p> <p></p>"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#sample-applications","title":"Sample applications","text":"<p>To test the RiverMapper tool, begin by extracting the \"RiverMapper_Samples/\" directory from RiverMapper_Samples.tar.</p> <p>Inside, you\u2019ll find two subdirectories: \"Serial\" and \"Parallel\", which demonstrate sample applications for meshing watershed rivers in small and large domains, respectively. Each subdirectory contains a sample Python script along with the required input files.</p> <p>These two samples use default settings tailored for small watershed rivers typically narrower than a few hundred meters. Similar configurations are employed in the latest version of NOAA's operational forecast system, STOFS3D Atlantic.</p> <p>If you're interested in meshing rivers with a broader range of widths, see additional parameterized examples below.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#meshing-watershed-rivers-in-a-small-domain-serial-mode","title":"Meshing watershed rivers in a small domain (Serial mode)","text":"<p>For a small domain (covering one or two states), a direct function call to the serial \"make_river_map\" suffices. See the sample script: <pre><code>RiverMapper_Samples/Serial/sample_serial.py\n</code></pre> , which reads: <pre><code>from RiverMapper.make_river_map import make_river_map\n\n\nif __name__ == \"__main__\":\n    '''\n    A sample serial application of RiverMapper\n    '''\n    make_river_map(\n        tif_fnames = ['./Inputs/DEMs/GA_dem_merged_ll.tif'],\n        thalweg_shp_fname = './Inputs/Shapefiles/GA_local.shp',\n        output_dir = './Outputs/',\n    )\n</code></pre></p> <p>Under the  directory \"RiverMapper_Samples/Serial/\", execute the serial script like this: <pre><code>./sample_serial.py\n</code></pre></p> <p>Note</p> <ul> <li>Although only one DEM tile is used in this example, but multiple DEM tiles are allowed.</li> <li>If the tiles are from different DEM sources, they should be arranged from high to low priority in the list.     Tiles from the high priority DEM source should have high fidelity and high resolution.</li> <li>The script allows DEM tiles of different sizes and shapes.</li> </ul>"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#meshing-rivers-in-a-large-domain-parallel-mode","title":"Meshing rivers in a large domain (Parallel mode)","text":"<p>For a large domain such as STOFS3D Atlantic, a parallel driver is provided to automatically group thalwegs based on their parent tiles, then distribute the groups to parallel processors.</p> <p>The sample parallel script is: <pre><code>RiverMapper_Samples/Parallel/sample_parallel.py\n</code></pre> , which reads: <pre><code>from mpi4py import MPI\nimport os\nfrom RiverMapper.river_map_mpi_driver import river_map_mpi_driver\n\nif __name__ == \"__main__\":\n    comm=MPI.COMM_WORLD\n    # ------------------------- sample input ---------------------------\n    dems_json_file = './Inputs/DEMs/dems.json'  # specifying files for all DEM tiles\n    thalweg_shp_fname='./Inputs/Shapefiles/LA_local.shp'\n    output_dir = './Outputs/' +  f'{os.path.basename(thalweg_shp_fname).split(\".\")[0]}_{comm.Get_size()}-core/'\n    # ------------------------- end input section ---------------------------\n    river_map_mpi_driver(\n        dems_json_file=dems_json_file,\n        thalweg_shp_fname=thalweg_shp_fname,\n        output_dir=output_dir,\n        comm=comm\n    )\n</code></pre></p> <p>In stead of specifying a file list for the DEM tiles as in the serial example, the first argument takes a *.json file that specifies multiple sets of DEMs, for example: <pre><code>{\n    \"CuDEM\": {\n        \"name\": \"CuDEM\",\n        \"glob_pattern\": \"./Inputs/DEMs/CuDEM/*.tif\",\n        \"file_list\": [],\n        \"boxes\": []\n    },\n    \"CRM\": {\n        \"name\": \"CRM\",\n        \"glob_pattern\": \"./Inputs/DEMs/CRM/*.tif\",\n        \"file_list\": [],\n        \"boxes\": []\n    }\n}\n</code></pre></p> <p>Note</p> <ul> <li> <p>For each DEM source, specify a glob pattern and/or a list of file names; if both are specified, the script will pool all files together and take the unique files.</p> </li> <li> <p>No need to manually specify the bounding \"boxes\", just leave them empty.</p> </li> <li> <p>Different DEM products should be arranged from high priority to low priority. The order of the dictionary key (\"CuDEM\" and \"CRM\") is preserved as long as you are using Python 3.7 or a later version. We may replace the regular dictionary to OrderedDict if there is a need.</p> </li> </ul> <p>Under the directory \"RiverMapper_Samples/Parallel/\", execute the parallel script like this:</p> <pre><code>mpirun -n 20 ./sample_parallel.py\n</code></pre> <p>The exact mpi command may vary based on your system.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#advanced-parameterization","title":"Advanced Parameterization","text":""},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#mandatory-input-parameters","title":"Mandatory input parameters","text":"<p>In the \"Serial\" and \"Parallel\" examples above, you may have noticed there are 3 mandatory Inputs:</p> parameter explanation tif_fnames (or a *.json file if there are many tiles) a list of TIF file names. These TIFs should cover the area of interest and be arranged by priority (higher priority ones in front) thalweg_shp_fname name of a polyline shapefile containing the thalwegs output_dir must specify one."},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#optional-input-parameters","title":"Optional input parameters","text":"<p>In addition to the mandatory inpouts, RiverMapper provides a few parameters to fine tune the output polylines or generate special features like levees or pseudo-channels.</p> parameter type explanation selected_thalweg integer numpy array Indices of a subset of thalwegs for which the river arcs will be sought; mainly used by the parallel driver output_prefix string a prefix of the output files, mainly used by the caller of this script; can be empty mpi_print_prefix string a prefix string to identify the calling mpi processe in the output messages; can be empty river_threshold float minimum and maximum river widths (in meters) to be resolved min_arcs integer minimum number of arcs to resolve a channel (including bank arcs, inner arcs and outer arcs) width2narcs_option string or callable pre-defined options ('regular', 'sensitive', 'insensitve') or  'custom' if a user-defined function is specified custom_width2narcs a user-defined function a function that takes one parameter 'width' and returns 'narcs', i.e., the number of arcs in the cross-channel direction elev_scale float scaling factor for elevations; a number of -1 (invert elevations) is useful for finding ridges (e.g., of a barrier island) outer_arc_positions a tuple of floats relative position of outer arcs, e.g., (0.1, 0.2) will add 2 outer arcs on each side of the river (4 in total), 0.1 * riverwidth and 0.2 * riverwidth from the banks. R_coef float coef controlling the along-channel resolutions at river bends (with a radius of R), a larger number leads to coarser resolutions (R*R_coef) length_width_ratio float the ratio between along-channel resolution and cross-channel resolution along_channel_reso_thres a tuple of 2 floats the minimum and maximum along-channel resolution (in meters) snap_point_reso_ratio float scaling the threshold of the point snapping; a negtive number means absolute distance value snap_arc_reso_ratio float scaling the threshold of the arc snapping; a negtive number means absolute distance value n_clean_iter int number of iterations for cleaning; more iterations produce cleaner intersections and better channel connectivity i_close_poly bool whether to add cross-channel arcs to enclose river arcs into a polygon i_smooth_banks bool whether to smooth the river banks at abrupt changes of the curvature i_DEM_cache bool Whether or not to read DEM info from cache.  Reading from original *.tif files can be slow, so the default option is True i_OCSMesh bool Whether or not to generate polygon-based outputs to be used as inputs to OCSMesh i_DiagnosticsOutput bool whether to output diagnostic information i_pseudo_channel int 0:  default, no pseudo channel, nrow_pseudo_channel and pseudo_channel_width are ignored; 1: fixed-width channel with nrow elements in the cross-channel direction, it can also be used to generate a fixed-width levee for a given levee centerline; 2: implement a pseudo channel when the river is poorly defined in DEM pseudo_channel_width float width of the pseudo channel (in meters) nrow_pseudo_channel int number of rows of elements in the cross-channel direction in the pseudo channel <p>You can change the values of these parameters so that the output river map better fits your application (otherwise default values are used). For example, if you want to add two pairs of outer arcs that flank the main river channel, you can do: <pre><code>    make_river_map(\n        tif_fnames = ['./Inputs/DEMs/GA_dem_merged_ll.tif'],\n        thalweg_shp_fname = './Inputs/Shapefiles/GA_local.shp',\n        output_dir = './Outputs/',\n        outer_arc_positions = (0.1, 0.2),\n    )\n</code></pre> , where the last argument specifies the relative distances of the outer arcs to the main channel. In this case two outer arcs will be placed to the left of the channel at distances of \"\\(0.1 \\times\\) channel width\" and \"\\(0.2 \\times\\) channel width\" from the left bank; the same goes for the right bank, so 4 outer arcs in total.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#parameter-presets","title":"Parameter presets","text":"<p>Tuning the parameters may not be easy at first because there are many of them. To simplify the parameter configuration, RiverMapper offers a class called \"ConfigRiverMap\", which provides commonly used parameter presets. These presets are \"class methods\" in config_river_map.py, and each preset (class method, or factory method) comes with a short description in the code.</p> <p>For example, the preset \"LooselyFollowRivers\" means that \"Small-scale river curvatures may not be exactly followed, but channel connectivity is still preserved\", and this is the sample code: <pre><code>    from RiverMapper.config_river_map import ConfigRiverMap\n\n    river_map_config = ConfigRiverMap.LooselyFollowRivers()\n    make_river_map(\n        tif_fnames = ['./Inputs/DEMs/GA_dem_merged_ll.tif'],\n        thalweg_shp_fname = './Inputs/Shapefiles/GA_local.shp',\n        output_dir = './Outputs/',\n        **river_map_config.optional,\n    )\n</code></pre> and the operator \"**\" unpacks the optional parameters from the configuration.</p> <p>Another utility of the \"ConfigRiverMap\" class is to facilitate the parameter transfer from the parallel driver to the core routine. The stardard way of setting the parameters in the parallel mode is as follows:</p> <pre><code>from mpi4py import MPI\nimport os\nfrom RiverMapper.river_map_mpi_driver import river_map_mpi_driver\nfrom RiverMapper.config_river_map import ConfigRiverMap\n\nif __name__ == \"__main__\":\n    comm=MPI.COMM_WORLD\n# ------------------------- sample input ---------------------------\n    dems_json_file = '/sciclone/schism10/Hgrid_projects/STOFS3D-V6/v16/Inputs/dems.json'  # specifying files for all DEM tiles\n    thalweg_shp_fname='/sciclone/schism10/Hgrid_projects/STOFS3D-V6/v16/Shapefiles/CUDEM_Merged_for_v16.shp'\n    output_dir = './Outputs/' +  f'{os.path.basename(thalweg_shp_fname).split(\".\")[0]}_{comm.Get_size()}-core/'\n    river_map_config = ConfigRiverMap()\n# ------------------------- end input section ---------------------------\n    river_map_mpi_driver(\n        dems_json_file=dems_json_file,\n        thalweg_shp_fname=thalweg_shp_fname,\n        output_dir=output_dir,\n        river_map_config=river_map_config,\n        comm=comm\n    )\n</code></pre> <p>Comparing with the parallel example in the previous section, the above example adds a few lines of code that does the following:</p> <ul> <li>importing the \"ConfigRiverMap\" class</li> <li>creating a default configuration \"river_map_config\",</li> <li>passing the configration to the parallel driver.</li> </ul> <p>Since the default configuration is used, this example is essentially the same as the previous parallel example. But it facilitates further parameter tweaking, e.g.: <pre><code>    river_map_config = ConfigRiverMap.LooselyFollowRivers()\n    river_map_config.optional['outer_arc_positions'] = (0.1, 0.2)\n    river_map_config.optional['i_real_clean'] = True\n</code></pre> , without changing other parts of the code.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#more-parameterization","title":"More parameterization","text":"<p>By tweaking the parameters, RiverMapper can also aid in the meshing of a wider range of river sizes or other channel-like features.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#hudson-river-and-tributaries","title":"Hudson River and tributaries","text":"<p>This example shows how to customize cross-channel divisions for a main channel that is a few kilometers wide and smaller tributaries.</p> <pre><code>from mpi4py import MPI\nimport os\nfrom RiverMapper.river_map_mpi_driver import river_map_mpi_driver\nfrom RiverMapper.config_river_map import ConfigRiverMap\n\nif __name__ == \"__main__\":\n    comm=MPI.COMM_WORLD\n    # ------------------------- sample input ---------------------------\n    dems_json_file = '/sciclone/schism10/Hgrid_projects/Shared_with_KM/Inputs/dems.json'  # specifying files for all DEM tiles\n    thalweg_shp_fname='/sciclone/schism10/Hgrid_projects/Shared_with_KM/Inputs/Thalwegs/thalweg_v16_subset_Hudson2.shp'\n    output_dir = './Outputs/' +  f'{os.path.basename(thalweg_shp_fname).split(\".\")[0]}_{comm.Get_size()}-core/'\n\n    river_map_config = ConfigRiverMap()  # initialize a default configuration\n    river_map_config.optional['river_threshold'] = (2, 5000)  # change the search range of river banks to accomodate for Hudson River\n    river_map_config.optional['along_channel_reso_thres'] = (5, 1200)  # change the maximum element length from 300 (default for small rivers) to 1200\n    river_map_config.optional['length_width_ratio'] = 4.0  # set element aspect ratio as needed\n\n    # Customize a width-to-narcs function and pass it to the configuration.\n    def width2narcs(width):  # do not change this line even if width is not used\n        narcs = 5  # you can specify more sophisticated configurations here as needed\n        return narcs  # narcs is the number of rows in the cross-channel direction.\n    # pass the customized function to the configuration\n    river_map_config.optional['custom_width2narcs'] = width2narcs\n    # ------------------------- end input section ---------------------------\n\n    river_map_mpi_driver(\n        dems_json_file=dems_json_file,\n        thalweg_shp_fname=thalweg_shp_fname,\n        output_dir=output_dir,\n        river_map_config=river_map_config,\n        comm=comm\n    )\n</code></pre> <p>The above code adds more customization to the parallel example. Please read the comments which explain each piece of customization. In particular, note how to pass a customized width-to-narcs function to the configuration. This function takes the width of a river and returns the number of rows in the cross-channel directions.</p> <p>Note</p> <p>The option 'river_threshold' specifies the min and max river width to be resolved, which affects the search range of river banks. A large value like 5000 m used here can slow down the execution compared to the default value (600 m, for small watershed rivers). In the future, we will allow users to select rivers and specify different values for this option.</p> <p>Here, a simplest function is used that specifies five rows of arcs regardless of river width, and the result is shown below:</p> <p></p> <p>Of course you can specify  more sophisticated functions depending on your needs, e.g.,</p> <pre><code>nrow = int(min_arcs + np.ceil(width / 100))  # add one arc for every increase of 100 m\n</code></pre> <p>or</p> <pre><code>nrow = int(min_arcs + np.floor(0.35*width**0.25))  # add one arc for every increase of one order of magnitude\n</code></pre> <p>or even make a master plan (similar to the master grid for SCHISM's vgrid) of how many arcs should be used for a given river width.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#levees","title":"Levees","text":"<p>In the STOFS-3D-Atlantic domain, levees are important features to be incorporated in the model mesh. Instead of parameterizing them as hydraulic structures, the levees are explicitly represented by meter-scale elements, with two rows of nodes resolving the feet of the levee and another two rows resolving the top of the levee:</p> <p> </p> <p>With the levee centerlines available from National Levee Database, the levee map can be easily made by invoking the pseudo channel option of RiverMapper:</p> <pre><code>river_map_config = ConfigRiverMap.Levees()\n</code></pre> <p>Notice that the along-channel (in this case along-levee) resolution also adapts for bends, just like for rivers.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#barrier-islands","title":"Barrier islands","text":"<p>Barrier islands are long and narrow topographical features similar to river channels. In fact, the map of a barrier island can be made in the same way as river channels if the sign of the DEM's elevation values is inverted.</p> <p> </p> <p>This can be done by setting the optional parameter \"elev_scale\" to \"-1\", or directly invoking the preset \"BarrierIsland\":</p> <pre><code>river_map_config = ConfigRiverMap.BarrierIsland()\n</code></pre> <p>Note</p> <p>The above two sample applications can also be found in  RiverMapper_Samples.tar</p>"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#experimental-features","title":"Experimental Features","text":""},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#global-arc-cleaning","title":"Global arc cleaning","text":"<p>The experimental option \"i_real_clean\" has been removed from the parameter list, because it has superseded all other options for river confluence cleaning. It is the only cleaning option in the latest code and enabled by default.</p> <p>The idea is simple: arc vertices that are too close to any vertex or arc segment are snapped to the closest vertices.</p> <p>A critical step is defining how close is close. Setting a global threshold value would not work well because a larger value tends to over-simplify small rivers thus not ensuring channel connectivity and a smaller value causes insufficient cleaning for larger rivers. As a result, a spatially varying threshold is specified for each vertex based on the cross-channel resolution at that location. This ensures a sufficent level of cleaning while maintaining channel connectivity. For example, the resolution around a confluence is largely determined by the smallest branch:  </p> <p>For a continental application like STOFS-3D-Atlantic that includes about 30,000 rivers, the cleaning takes about 10 minutes. Since the algorithm is fairly efficient, several iterations of cleaning are implemented allowing the threshold gradually increasing from a small value to the target value; in other words, the most close-by vertices are snapped first, which prevents overly aggressive snapping and slightly improve the quality of the end product.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#outputs-for-ocsmesh","title":"Outputs for OCSMesh","text":"<p>The \"i_OCSMesh\" option leads to an extra shapefile output containing river polygons, which serves as an input to OCSMesh. The option is enabled by default because the polygon-based output may be useful for other mesh generators too.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/generate-river-map.html#outputting-river-mesh-elements","title":"Outputting river mesh elements","text":"<p>It may be desirable in some circumstances to directly discretize river polygons into elements (quadrangles and triangles). However, this is not the intended function of the tool at least by its original design but rather a task for mesh generators. In addition, the accuracy and efficiency of SCHISM are not sensitive to how mesh generators decide to form the elements (as quads or triangles), as long as they adhere to the given river arcs or polygons. We can implement this option if there is a need.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html","title":"Overview","text":"<p>Here we provide three sample projects to illustrate the procedure of meshing for compound flood simulations. These examples use SMS to merge the automatic arcs with existing manual arcs and generate the final mesh. The projects are organized in order of increasing complexity.</p> <p>Note</p> <p>The main purpose is to illustrate the necessary steps to get a clean map coverage for meshing, and you're welcome to employ any tools or methods that suit your preference. The key is to organize different map features (such as coastal water bodies, watershed rivers, hydraulic structures) in individual SMS map coverages and merge them properly to avoid unwanted intersections.</p> <p></p>"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#calcasieu-lake","title":"Calcasieu Lake","text":"<p>The first example illustrates how you may extend an existing coastal model mesh to include higher-grounds and small rivers in the watershed.</p> <p>Step 1. Start from an existing map coverage.</p> <p>Assume you have a manually made SMS map for a traditional coastal simulation like this:</p> <p> </p> <p>The spatial domain (orange color) covers everything below the sea level in the study area.</p> <p>Step 2. Include more upland areas of interest:</p> <p>Define a boundary that delineates the landward limit of the new domain of interest, for example:</p> <p> </p> <p>Step 3. Clip the automatic arcs so that they are only present in the areas of interest.</p> <p>Typically, we want to put the automatic arcs (watershed rivers) only in the extended region. This can be done in various ways, e.g., using GIS tools or scripts.</p> <p>For this simple project, using SMS or GIS tools is straightforward, and here is an example using the clipping tool (similar to that in ArcGIS or QGIS) inside SMS:</p> <ul> <li> <p>Duplicate the full domain map coverage (from Step 2) and name it as \"extended\"</p> </li> <li> <p>Select the polygon that corresponds to the extended region, remove other polygons by invert selection and delete:</p> </li> </ul> <p> </p> <ul> <li>Use the clipping tool in the toolbox, and clip the automatic arcs inside the extended region.</li> </ul> <p> </p> <ul> <li>The results look like:</li> </ul> <p> </p> <p>Step 4. Merge the clipped automatic arcs and generate the mesh.</p> <p>Note</p> <p>If you want to set a uniform mesh resolution in the extended region, you should do it before merging, because the polygon of the extended region will be split into many parts afterwards, making it labor intensive to set attributes for them manually.</p> <p>Set the element size as:</p> <p> </p> <p>After merging, you should clean the final coverage and build polygons again. The element size set in the extended region will be inherited (as of SMS 13.3.5) even though it has been split into many parts by river arcs:</p> <p> </p> <p>Note</p> <p>Sometimes a few parts split from the original extended region may not inherit the polygon attributes and default to \"paving\", in this case you may need to manually set the polygon attributes or design another map coverage to facilitate the selection. This is elaborated below.</p> <p>And here is the final mesh:</p> <p> </p> <p></p> <p></p>"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#coastal-areas-in-texas","title":"Coastal areas in Texas","text":"<p>This example is similar to the first one, but the existing map is more complex.</p> <p>Step 1. Start from an existing map coverage.</p> <p>This manual map consists of many polygons and some of them are islands (empty polygons, not meshed).</p> <p> </p> <p>Step 2. Include more upland areas of interest:</p> <ul> <li> <p>Include islands of interest. For example, the yellow polygons in the figure above are islands, which have a mesh type of \"None\". Set them to \"Paving\" so that they will be meshed. If many islands need to be set to \"paving\" in the existing map coverage, you can directly edit the *.map file and replace all occurrences of the string \"NOMESH\" to \"PAVE 0.3\".</p> </li> <li> <p>Define a boundary that delineates the landward limit of the new domain, for example:</p> </li> </ul> <p> </p> <p>Step 3. Clip the automatic arcs so that they are only present in the areas of interest.</p> <p>Similar to the first example, the extended region is the difference between the newly defined full domain and the original domain (which also includes any islands of interest):</p> <p> </p> <p>The clipped arcs look like:</p> <p> </p> <p>Depending on your needs, you may want the automatic arcs to intersect with the existing arcs (set buffer=0 in this case) or leave a buffer distance between the two groups of arcs. We typically don't let automatic arcs intersect with existing arcs, but this requires some further considerations (see below) to ensure channel connectivity.</p> <p>Here, we provide an example using Python scripting:</p> <ul> <li>Merge the newly defined the land boundary with the existing coverage:</li> </ul> <p></p> <p>, clean the merged coverage and rebuild polygons in SMS.</p> <ul> <li> <p>Save the original coverage and the merged coverage (full domain) as polygon shapefiles.</p> </li> <li> <p>Use the Python script below to clip the automatic arcs:</p> </li> </ul> <pre><code>import geopandas as gpd\n\n# ------------------------- inputs ---------------------------\nwdir = '/sciclone/schism10/Hgrid_projects/GoM/'\noriginal = gpd.read_file(f'{wdir}/original.shp')\nfull_domain = gpd.read_file(f'{wdir}/full.shp')\nislands = gpd.read_file(f'{wdir}/islands.shp')\nbuffer_distance = 50e-5   # set to 0 if no buffer is needed\n# ------------------------- end inputs ---------------------------\n\n# buffer the original domain so that the clipped arcs don't intersect with the original domain\noriginal_buf = gpd.GeoDataFrame(geometry=original.buffer(buffer_distance))\n# the extended region is the \"watershed\" region where the auto arcs are placed\nextended_region = full_domain.overlay(original_buf, how='difference').dissolve()\n\n# add any islands back\nislands_buf = gpd.GeoDataFrame(geometry=islands.buffer(-buffer_distance))  # \"minus\" because we want the river arcs contained in the islands\nextended_region = extended_region.append(islands_buf)\n\n# clip the auto arcs to the extended region\ntotal_arcs = gpd.read_file(f'{wdir}/total_arcs.shp')\ntotal_arcs_clipped = total_arcs.clip(extended_region)\ntotal_arcs_clipped.to_file(f'{wdir}/total_arcs_clipped.shp')\n</code></pre> <p>The usage of this simple script is self-evident and you can use it as a starting point for your own project. Scripting is recommended for more complex projects with many individual map coverages.</p> <p>Step 4. Merge the clipped automatic arcs and generate the mesh.</p> <p>See details in the SECOFS example.</p> <p></p> <p></p>"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#secofs-south-east-coastal-forecast-system","title":"SECOFS (South-east Coastal Forecast System)","text":"<p>This example is based on the SECOFS domain.</p> <p> </p> <p>This project has an additional component in the map module, i.e., the levee and dam system from the National Levee Database. In a more complex project like this one, it is recommended to use a script to clip the automatic arcs inside the extended (watershed) region. The SCHISM Git repo provides a clipping script for SECOFS:</p> <pre><code>$your_schism_dir/src/Utility/Pre-Processing/SECOFS/Grid/clip_autoarcs.py\n</code></pre> <p>This script is similar to the one shown in the Texas example above, but it has more steps.</p> <p>The rest of the procedures of automatic arcs preperation is similar to what have been shown in the previous examples and not repeated here.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#preparation","title":"Preparation","text":"<p>The SECOFS SMS project has the following components:</p> <p> </p> <p>For a complex meshing project, it is imperative to keep different features in seperate maps. Merging individual maps should be done as the last step.</p> <p>In this project, the purpose of each SMS map coverage is as follows:</p> <ul> <li> <p>lbnd: land boundary roughly along the 10-m contour.</p> </li> <li> <p>levee*: Levees from National Levee Database.</p> </li> <li> <p>auto*arcs: Automatically generated river arcs, clipped inside the watershed region (see clipping the river   arcs)</p> </li> <li> <p>coast: This map includes all manually made polygons (including quad patches) and the coastline.</p> </li> <li> <p>merge coverge: Merged map of all individual maps above.</p> </li> </ul> <p>Attention</p> <p>Never edit the merged map directly, unless you are willing to take the time to exactly reproduce the changes in all individual maps (which is more time consuming in most cases, so don't do it).</p> <p>For a complex project, breaking the consistency between the merged map and the individual maps makes it practically impossible for any significant changes in the future.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#clean-the-merged-map","title":"Clean the merged map","text":"<p>Since SMS 13.3, the cleaning is very efficient even for a map with tens of thousands of arcs. However, you may need to clean the merged map multiple times until there is no more warning messages. For STOFS3D or SECOFS, use with the following parameters:\u00a0</p> <p></p>"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#build-polygons","title":"Build polygons","text":"<p>Make sure there is no warning message after the polygons are built; otherwise, go back to the cleaning step and try again.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#finalize-the-mesh","title":"Finalize the mesh","text":"<p>Delete the disjoint nodes:</p> <p></p> <p>Renumber nodes:</p> <p></p> <p>Save the mesh as *.2dm:</p> <p></p>"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#mesh-quality-and-skew-elements","title":"** Mesh quality and skew elements **","text":"<p>Although the script tries to optimize the convergence of river arcs at river intersections , skew elements may occasionally occur. </p> <p>Normally these small 'bad' elements do not affect the efficiency or stability of SCHISM simulations.  However, it's advisable to edit out extremely small/skew elements. You may remedy them using the following script provided in RiverMapper: <pre><code>RiverMeshTools/RiverMapper/RiverMapper/improve_hgrid.py\n</code></pre> The script automatically checks for small and skew elements, then improve the mesh by merging, removing, or relaxing the problematic elements. As a general rule of thumb, SCHISM can comfortably handle elements &gt;= \\(1m^2\\) (\\(10^{-10}\\) in lon/lat), and skewness&lt;=60.  You can specify these parameters in the script; see the \"main\" section of the script for usage.</p> <p>Alternatively, you can use <code>ACE/xmgredit5</code> or SMS to check and fix mesh quality manually.</p> <p>Attention</p> <p>Avoid overly depending on mesh adjustments in the final stage, as the underlying issue often originates from the SMS coverages or the merging process. In these instances, it is best to address the problems directly within the SMS coverages.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#additional-notes-for-stofssecofs-developers","title":"Additional notes for STOFS/SECOFS developers","text":"<p>These notes are primarily intended as a reference for developers, although other users might also find parts of the content beneficial.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#strategy-for-editing-the-coastal-coverage","title":"Strategy for editing the coastal coverage","text":"<p>Edit the coastal coverage when local refinements are needed in an area of interest.</p> <p>Rules to follow (for consistency among STOFS3D/SECOFS developers):</p> <ul> <li>The model boundary, which includes both the land boundary and the ocean boundary, must fully encompass all other coverages, particularly the coastal coverage. In other words, the coastal coverage should not extend beyond the land boundary (see figure below). This can cause issues in subsequent procedures if feeder channels are needed.</li> </ul> <p></p> <ul> <li>The manual arcs should at least be better than the auto arcs; use the shapefile of the auto arcs as a background in SMS to help you decide.   In particular, this means you need to accommodate for tributaries when placing a manual polygon for a main channel, lake, or estuary:</li> </ul> <p></p> <ul> <li>No need to create buffers for manual polygons; the clipping procedure automatically creates a 50-meter buffer zone around all manual polygons.</li> </ul> <p>Attention</p> <p>Unless you have a clear plan, avoid mixing other coverages (e.g., levees and auto arcs) or portions of other coverages with the coastal coverage, which is reserved for manual editing. Doing so requires you to maintain manual edits in sync with external changes, which may be easier to manage within their respective coverages. For instance, the National Levee Database may periodically add or remove features; requirements for auto arcs may evolve, or there may be improvements in the RiverMapper tool. Additionally, including auto arcs in this coverage means you will need to spend extra time ensuring connectivity with tributaries (see the above figure).</p>"},{"location":"mesh-generation/meshing-for-compound-floods/meshing-in-SMS.html#set-watershed-resolution","title":"Set watershed resolution","text":"<p>To avoid over-refinement, most watershed polygons should have a specified mesh resolution, which can be set via the \"constant paving\" or \"scalar paving density\" option in each polygon's attributes.</p> <p>Selecting the watershed polygons may involve much labor because many small polygons are generated after the river arcs are merged into the final map. Instead of manual selection, use the \"select*\" map coverage to select all polygons more efficiently.</p> <p>Activate the \"select*\" coverage:</p> <p></p> <p>Select the big polygon, right click on it, and click \"Select intersecting objects\":</p> <p></p> <p>Intersect it with \"merge coverage\" with the following parameters:</p> <p></p> <p>It will take about 10 minutes to do the selection for the STOFS3D domain.</p> <ul> <li>For STOFS3D, right click on the selected polygons\u00a0and set \"mesh type\" in \"polygon attributes\" to scalar paving density:\u00a0</li> </ul> <p></p> <p>Set scalar options using the watershed_resolution scatter dataset from the preparation step:</p> <p></p> <p>In addition, set the polygon attribute of the \"island\" between Chesapeake Bay and Delaware Bay as \"None\":</p> <p></p> <ul> <li>For SECOFS, \"Constant paving\" with the following parameters is used:</li> </ul> <p></p>"},{"location":"mesh-generation/meshing-for-compound-floods/overview.html","title":"Overview","text":"<p>Meshing for a compound flood simulation can be very challenging. It is crucial to accurately and economically resolve the small rivers in the watershed to ensure hydraulic connectivity while minimizing the mesh size. Additionally, flood risk reduction structures such as levees and dams also need to be represented in the mesh.</p> <p>The mesh of STOFS3D has gone through major upgrades from STOFS3D v4 to v6, which serves as a good illustration of different meshing techniques:</p> <p></p> <p>In the v4 mesh, small watershed rivers are resolved by a 1D representation, using 1D river segments from the National Water Model as feature arcs to guide the meshing.</p> <p>In the v5 mesh, characteristic contours of the DEM are extracted and used to represent river banks and thalwegs. However, extensive manual cleaning is required due to the potential messiness of these contours.</p> <p>In the v6 mesh, the river arcs are automatically generated by using pyDEM and  RiverMapper, both of which are included in SCHISM's GitHub repo. Here is another sample v6 mesh that is zoomed in on the complex river network in South Carolina: </p> <p>The meshing procedure used in v6 is preferred due to its minimal need for manual labor and its ability to produce the best mesh quality out of the three versions. The procedure includes three steps:</p> <ol> <li> <p>Extracting thalwegs from DEM tiles</p> </li> <li> <p>Generate an SMS map that contains river arcs</p> </li> <li> <p>Meshing in SMS</p> </li> </ol>"},{"location":"mesh-generation/meshing-for-compound-floods/overview.html#publication","title":"Publication","text":"<p>A parallel Python-based tool for meshing watershed rivers at continental scale</p>"},{"location":"mesh-generation/meshing-for-compound-floods/special-case-utilizing-nhd.html","title":"Special case utilizing NHD (National Hydrography Dataset)","text":""},{"location":"mesh-generation/meshing-for-compound-floods/special-case-utilizing-nhd.html#introduction","title":"Introduction","text":"<p>Previously, we discussed how to extract thalwegs from a Digital Elevation Model (DEM) for use as input to RiverMapper. We also mentioned other 1D river network datasets can be used intead of the extracted thalwegs, provided they reasonably represent the true thalwegs or channel centerlines. In this section, we illustrate the usage of an alternative data sources, National Hydrography Dataset (NHD), and outline the workflow for pre-processing NHD products as RiverMapper inputs.</p> <p>NHD is a comprehensive set of digital spatial data that represents the surface water features of the United States, including rivers, streams, lakes, and ponds. Developed by the U.S. Geological Survey (USGS), NHD provides detailed vector representations of flowlines, water bodies, and associated attributes.</p> <p> </p> <p>It is widely used for hydrologic analysis, watershed modeling, and mapping, and can serve as an alternative source of 1D river networks for RiverMapper inputs.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/special-case-utilizing-nhd.html#download","title":"Download","text":"<p>The NHD products can be downloaded from the EPA website. Notably, NHDPlus v2 is used in the National Water Model. Here, we will use NHDPlus High Resolution EPA Snapshot 2022, which provides finer detail suitable for accurate river network extraction and modeling.</p> <p>Scroll to the bottom of the page, select state(s), and download the GeoPackage data:</p> <p></p>"},{"location":"mesh-generation/meshing-for-compound-floods/special-case-utilizing-nhd.html#pre-processing-flowlines","title":"Pre-processing flowlines","text":"<p>The <code>nhdflowline</code> layer in the GeoPackage typically contains many more rivers than are needed for a compound flood simulation.  To reduce processing time, select only the flowlines within your region of interest and export them to a shapefile.</p> <p>Then, apply the following pre-processing steps to the shapefile:</p> <ul> <li>Subset flowlines based on specific criteria (e.g., valid <code>gnis_id</code>).</li> <li>Dissolve flowlines sharing the same <code>gnis_id</code> to minimize segmentation.</li> <li>For segments that are partially inside (outside) nhdarea polygons, split them into parts that are inside and outside the nhdarea.</li> <li>Split long flowlines into shorter segments based on a maximum length threshold.</li> <li>Densify vertices along each flowline to enhance accuracy for use in RiverMapper.</li> <li>Add an integer attribute to all linestrings \"keep\" = 1, which invokes optinal processing steps (taliored for NHD) inside RiverMapper.</li> </ul> <p>These steps can be performed manually using GIS tools such as QGIS. Alternatively, the following script is provided to automate the process:</p> <pre><code>RiverMeshTools/RiverMapper/Scripts/pre_proc_nhd_flowline.py\n</code></pre> <p>The usage of the script is self-explanatory in the main() function. An example of the processed nhdflowline around Wilmington, NC, USA is shown below:</p> <p></p>"},{"location":"mesh-generation/meshing-for-compound-floods/special-case-utilizing-nhd.html#pre-processing-nhd-area-optional","title":"Pre-processing NHD Area (Optional)","text":"<p>The <code>nhdarea</code> layer from the downloaded GeoPackage can serve as a surrogate for a DEM after the following post-processing steps:</p> <ul> <li>(Optional) Split the entire domain into tiles if the domain is large.</li> <li>Rasterize each tile into a <code>.tif</code> file, assigning -1 to areas inside the polygons (water) and 0 to areas outside (land).</li> <li>Generate a dummy tile covering the full domain with only 0 values. This is used as the lowest-priority tile to ensure all rivers are within *.tif coverage.</li> </ul> <p>Tiling facilitates parallel processing with MPI.  Rasterization simplifies and accelerates geometric queries, at the cost of increased memory usage \u2014 a trade-off that is manageable with MPI. These post-processing steps make the tiles directly usable as inputs to RiverMapper.</p> <p>The following scripts are provided to automate the process:</p> <pre><code>RiverMeshTools/RiverMapper/RiverMapper/river_map_tif_preproc.py\n</code></pre> <p>The usage of the script is self-explanatory in the main() function.</p>"},{"location":"mesh-generation/meshing-for-compound-floods/special-case-utilizing-nhd.html#sample-applications","title":"Sample applications","text":"<p>Two sample applications \u2014 one for the Pee Dee River, SC, and one for Wilmington, NC \u2014 are provided here.</p> <p>Each application includes:</p> <ul> <li>A shapefile containing pre-processed NHD layer <code>nhdflowline</code>;</li> <li>A shapefile containing <code>nhdarea</code> clipped to the regions of interest, but it still needs to be processed as described above;</li> <li>A sample script demonstrating how to call RiverMapper;</li> <li>Example outputs generated by RiverMapper.</li> </ul> <p>In these two examples, the rivers selected for feature extraction are those with a valid <code>gnis_id</code>.  Different strategies can be used to choose the rivers as needed.  Additional rivers can also be added as needed. In the Pee Dee River case, a stretch of the Intracoastal Waterway was added to the initial selection. In the Wilmington case, additional rivers (orange lines) in the urban area are copied from the original nhdflowline:</p> <p></p> <p>Note</p> <p>In the Wilmington example (above figure), a few lines are also added in the main stem of the Cape Fear River. This is to improve the arcs around the islands. However, it is recommended to draw major rivers and estuaries manually without using RiverMapper.</p> <p>An example of the final product is shown below, where rivers inside the <code>nhdarea</code> polygons are resolved with higher resolution, while small creeks outside the polygons are represented by uniform-width channels.</p> <p></p>"},{"location":"modules/age.html","title":"AGE","text":"<p>AGE module is different from other tracer modules in that it works with even number of tracers, with the 1st half being the age tracer concentration and the 2nd half being the corresponding \u2018ages\u2019 (Shen and Haas 2004). The code hardwires the I.C. flag for this module to be \u20181\u2019, i.e. horizontally variable conditions for all tracers specified in <code>AGE_hvar_*.ic</code>. Inside each <code>.ic</code> for the 2nd half of tracers, set a uniform 0 at all nodes. For tracers in the 1st half, the user specifies the age concentration to be either 0 or 1, the latter in specific regions where the age tracers will be continuously injected into the domain. For this reason, we suggest setting all B.C. flags for this module to be \u20180\u2019 in <code>bctides.in</code>.</p> <p>The vertical positions where the age tracers are injected are specified in <code>param.nml</code> in the array <code>level_age(1: ntracer_age/2)</code>; e.g. for <code>ntracer_age=4</code>, we may specify: <code>level_age = 9, -999</code> to inject the 1st age tracer at level 9, and the 2nd tracer at all levels (and the code will reset the tracer concentrations to 1 at the same \u2018injection\u2019 elements and level(s) at each time step). The output flags for the water \u2018age\u2019 in days are specified for half of the total number; e.g., <code>iof_age(1:2)=1, 0</code>.</p>"},{"location":"modules/analysis-mode.html","title":"Analysis mode","text":"<p>Under this module the user can output several internal arrays inside the code, and this is useful for detailed analysis like momentum and tracer budget etc. We have implemented some commonly requested terms in the momentum and transport equations, which can be found in the code by searching for <code>_ANALYSIS</code> and also in <code>param.nml</code> under <code>iof_ana</code>. The user can also use this module to output additional terms if they are familiar with the source code. Note that invoking this module may slow down the code.</p>"},{"location":"modules/cosine.html","title":"CoSiNe","text":"<p>A complete manual for this module can be found here.</p>"},{"location":"modules/dvd.html","title":"DVD","text":"<p>Klingbeil et al. (2014) proposed a theory of estimating numerically induced mixing coefficients. At the moment we have only implemented this module for 1 tracer (salinity).</p> <p>The I.C. for this module is hardwired to be 0 and the code will set it automatically. The B.C. flags should also be 0 in general, so is the nudging flag. The main output is <code>iof_dvd(1)</code> which corresponds to numerical mixing for salinity in \\(\\text{PSU}^2/s\\).</p> <p>References</p> <p>Klingbeil, K., Mohammadi-Aragh, M., Gr\u00e4we, U., Burchard, H. (2014) Quantification of spurious dissipation and mixing \u2013 Discrete variance decay in a Finite-Volume framework, Ocean Modelling, https://doi.org/10.1016/j.ocemod.2014.06.001.</p>"},{"location":"modules/fabm.html","title":"FABM","text":"<p>The <code>fabm</code> module is the SCHISM host implementation for the separatly available Framework for Aquatic Biogeochemical models (FABM).  Within the FABM framework, a number of host-agnostic ecosystem models have been implemented, such that they work within many different hydrodynamic host models, including a <code>python</code> host and <code>Fortran</code> hosts from zero to three-dimensional, and now including SCHISM.  For these hosts, FABM's internal loops are arranged for optimal numerical performance. </p>"},{"location":"modules/fabm.html#obtaining-the-fabm-framework-code","title":"Obtaining the FABM framework code","text":"<p>The FABM framework code is hosted separately, as are some of the ecosystem model codes. The SCHISM host provided here is compatible with both the deprecated <code>version 0</code> of the FABM framework and the current versions <code>version 1</code> and <code>version 2</code>. </p> <p>The required FABM code can be downloaded from  1. the official repository https://github.com/fabm-model/fabm  2. our development fork that closely follows the official repository, and includes modularization of some the existing SCHISM modules refactored within FABM. 3. any fork of FABM as of their  <code>SHA:048673</code> (2017-09-15).</p>"},{"location":"modules/fabm.html#compiling-with-fabm","title":"Compiling with FABM","text":"<p>The FABM framework and its contained models are compiled within the SCHISM build when using <code>cmake</code></p> <pre><code>cmake  [...] -DUSE_FABM=ON -DFABM_BASE=/your/path/to/fabm/ \n</code></pre>"},{"location":"modules/fabm.html#developing-a-fabm-biogeochemical-model","title":"Developing a FABM biogeochemical model","text":"<p>Documentation on how to implement an ecosystem model in FABM is provided on the FABM wiki page https://github.com/fabm-model/fabm/wiki/Developing-a-new-biogeochemical-model</p>"},{"location":"modules/fabm.html#implementation-of-schism-as-a-fabm-host","title":"Implementation of SCHISM as a FABM host","text":""},{"location":"modules/fabm.html#calls-to-fabm-infrastructure-from-hydroschism_initf90","title":"Calls to FABM infrastructure from Hydro/schism_init.F90","text":"<ol> <li>Initialization of FABM <code>schism_init.F90</code> calls <code>fabm_schism_init_model</code> and gets back the number of tracers to be transported. This step reads the FABM configuration, specifically the files <code>fabm.yaml</code> and <code>fabm_schism.in</code>. The FABM package is initialized, which builds up its infrastructure tree. Now, FABM knows how many state variables, surface state variables, bottom state variables and diagnostic variables are required. |</li> <li>Post-Initialization of FABM     At this stage, the necessary arrays are allocated within SCHISM by the routine <code>fabm_schism_init_stage2</code>. Pointers to the state variables and forcings are set for FABM, further arrays are allocated based on the grid layout.  An output netcdf file is created by <code>fabm_schism_create_output_netcdf</code> to store diagnostics and bottom state variables. This netcdf file can also used for hotstart, however this step can be merged into SCHISM's netcdf infrastructure now. |</li> <li>Initialize concentrations <code>fabm_schism_init_concentrations</code> is called to set the initial concentrations from the FABM configuration.</li> <li>Read 2D hotstart data from netcdf     With <code>fabm_schism_read_horizontal_state_from_netcdf</code>, the 2d hotstart information, e.g. for bottom state variable concentrations on elements, is read from a global netcdf. |</li> </ol>"},{"location":"modules/fabm.html#calls-to-fabm-infrastructure-from-hydroschism_stepf90","title":"Calls to FABM infrastructure from Hydro/schism_step.F90","text":"<p>During the integration, SCHISM calls FABM to get the rates of change of the state variables and the swimming and sinking speeds of moving state variables at each timestep based on the current environmental conditions. Most of the forcing (e.g. temperature) can be linked during the initialization. Currently, the bottom stress in the element center is calculated exclusively for FABM within <code>schism_step.F90</code>.</p> <ol> <li> <p>timestep call The major call to FABMs ecosystem models within <code>schism_step.F90</code> using <code>fabm_schism_do</code>. Within this call, the light conditions are calculated, further forcing is updated in FABM, diagnostic variables are updated, the rates of change of state variables are collected from FABM and put into the <code>bdy_frc</code>, <code>flux_bt</code>, and <code>flux_sf</code> arrays. The current swimming and sinking speeds are taken from FABM and put into the <code>wsett</code> array. The changes of bottom and surface state variables are calculated with a simple Euler integration step, which is a potentially weak feature. The temporal integration of bottom and surface state variables can potentially improved, e.g. iterated if necessary. |</p> </li> <li> <p>write output by SCHISM All state variables are written by <code>writeout_nc</code> at each output time step by SCHISM's output infrastructure.</p> </li> <li> <p>write specific output The routine <code>fabm_schism_write_output_netcdf</code> is called for the output timesteps. The diagnostic variables to be written are collected before, which includes temporal averaging, if required. This step can be merged into the SCHISM output infrastructure.</p> </li> </ol>"},{"location":"modules/generic-tracer.html","title":"Generic tracer module","text":"<p>We provide this module to users as template for potential addition of behavior etc. As is, the module simulates multiple classes of passive tracers with constant settling velocity gen_wsett (<code>gen_wsett</code> &lt;0 =&gt;swimming velocity), with no body forces and zero fluxes at surface and bottom. The number of generic tracers is specified as <code>ntracer_gen</code>. I.C. flag is <code>flag_ic(3)</code>, and nudging flag is <code>inu_tr(3)</code> in <code>param.nml</code>. The output flags are <code>iof_gen(1:ntracer_gen)</code>.</p>"},{"location":"modules/hydraulics.html","title":"Hydraulics","text":"<p>The manual for this module can be found here.</p>"},{"location":"modules/icm.html","title":"ICM","text":""},{"location":"modules/icm.html#state-variables-and-sub-modules-in-icm","title":"State variables and sub-modules in ICM","text":"<pre>\nCore Module\n     1  PB1   :  Diatom                                     g/m^3\n     2  PB2   :  Green Algae                                g/m^3\n     3  PB3   :  Cyanobacteria                              g/m^3\n     4  RPOC  :  Refractory Particulate Organic Carbon      g/m^3\n     5  LPOC  :  Labile Particulate Organic Carbon          g/m^3\n     6  DOC   :  Dissolved Orgnaic Carbon                   g/m^3\n     7  RPON  :  Refractory Particulate Organic Nitrogen    g/m^3\n     8  LPON  :  Labile Particulate Organic Nitrogen        g/m^3\n     9  DON   :  Dissolved Orgnaic Nitrogen                 g/m^3\n     10 NH4   :  Ammonium Nitrogen                          g/m^3\n     11 NO3   :  Nitrate Nitrogen                           g/m^3\n     12 RPOP  :  Refractory Particulate Organic Phosphorus  g/m^3\n     13 LPOP  :  Labile Particulate Organic Phosphorus      g/m^3\n     14 DOP   :  Dissolved Orgnaic Phosphorus               g/m^3\n     15 PO4   :  Total Phosphate                            g/m^3\n     16 COD   :  Chemical Oxygen Demand                     g/m^3\n     17 DOX   :  Dissolved Oxygen                           g/m^3\nSilica Module\n     1  SU    :  Particulate Biogenic Silica                g/m^3\n     2  SA    :  Available Silica                           g/m^3\nZooplankton Module\n     1  ZB1   :  1st zooplankton                            g/m^3\n     2  ZB2   :  2nd zooplankton                            g/m^3\npH Module\n     1  TIC   :  Total Inorganic Carbon                     g/m^3\n     2  ALK   :  Alkalinity                                 g[CaCO3]/m^3\n     3  CA    :  Dissolved Calcium                          g[CaCO3]/m^3\n     4  CACO3 :  Calcium Carbonate                          g[CaCO3]/m^3\nCBP Module\n     1  SRPOC :  Slow Refractory Particulate Organic Carbon g/m^3\n     2  SRPON :  Slow Refractory Particulate Organic Nitro. g/m^3\n     3  SRPOP :  Slow Refractory Particulate Organic Phosp. g/m^3\n     4  PIP   :  Particulate Inorganic Phosphate            g/m^3\nSAV Module (no transport variables)\nVEG Module (no transport variables)\nSFM Module (no transport variables)\n</pre>"},{"location":"modules/icm.html#1-core-module","title":"1. Core Module","text":""},{"location":"modules/icm.html#11-mass-balance-equations-of-state-variables-in-icm","title":"1.1 Mass Balance Equations of State Variables in ICM","text":"<p>**Note: ** </p> <p>a). settling of variables are addressed in separate section, and not included in the equations below   b). When iCBP=0, equations of (\\(\\text{SRPOC},\\text{SRPON},\\text{SRPOP},\\text{PIP}\\)) are omiited,  and \\((FCP_4^m,FCM_4^m,FNP_5^m,FNM_5^m,FPP_5^m,FPM_5^m)=0, (KC_S,KN_S,KP_S,KP_P)=0\\) </p> <p>Phytoplankton (PB1, PB2, PB3):</p> \\[\\begin{flalign}   &amp; d\\text{PB}^i = \\text{GP}^i-\\text{MT}^i-\\text{PR}^i \\text{ ,   i=1,3}  \\\\ \\end{flalign}\\] <p>Carbon (RPOC, LPOC, DOC):</p> \\[\\begin{flalign}   &amp; d\\text{RPOC} = -KC_1 \\cdot \\text{RPOC}+ \\sum_{m=1,3} \\left( FCP_1^m \\cdot \\text{PR}^m + FCM_1^m \\cdot \\text{MT}^m \\right)\\\\   &amp; d\\text{LPOC} = -KC_2 \\cdot \\text{LPOC}+ \\sum_{m=1,3} \\left( FCP_2^m \\cdot \\text{PR}^m + FCM_2^m \\cdot \\text{MT}^m \\right) \\\\   &amp; \\begin{split}     &amp; d\\text{DOC}=KC_1 \\cdot \\text{RPOC}+ KC_2 \\cdot \\text{LPOC} + KC_S \\cdot \\text{SRPOC} -K_{HR} \\cdot \\text{DOC} -Denit \\cdot \\text{DOC} \\\\     &amp; + \\sum_{m=1,3} FCP_3^m \\cdot \\text{PR}^m + \\sum_{m=1,3} \\left[FCM_3^m+ \\left(1-\\sum_{i=1,4} FCM_i^m \\right) \\cdot \\frac{KhDO^m}{DO+KhDO^m} \\right] \\cdot \\text{MT}^m \\\\   &amp; \\end{split} \\\\   &amp; d\\text{SRPOC} = -KC_S \\cdot \\text{SRPOC}+ \\sum_{m=1,3} \\left( FCP_4^m \\cdot \\text{PR}^m + FCM_4^m \\cdot \\text{MT}^m \\right)\\\\ \\end{flalign}\\] <p>Nitrogen (RPON, LPON, DON, NH4, NO3):</p> \\[\\begin{flalign}   &amp; d\\text{RPON} = -KN_1 \\cdot \\text{RPON}+ \\sum_{m=1,3} n2c^m \\cdot \\left( FNP_1^m \\cdot \\text{PR}^m + FNM_1^m \\cdot \\text{MT}^m \\right) \\\\   &amp; d\\text{LPON} = -KN_2 \\cdot \\text{LPON}+ \\sum_{m=1,3} n2c^m \\cdot \\left( FNP_2^m \\cdot \\text{PR}^m + FNM_2^m \\cdot \\text{MT}^m \\right) \\\\   &amp; \\begin{split}       &amp; d\\text{DON} = KN_1 \\cdot \\text{RPON} + KN_2 \\cdot \\text{LPON} + KN_S \\cdot \\text{SRPON} -KN_3 \\cdot \\text{DON} \\\\      &amp; + \\sum_{m=1,3} n2c^m \\cdot \\left( FNP_3^m \\cdot \\text{PR}^m + FNM_3^m \\cdot \\text{MT}^m \\right)    &amp; \\end{split} \\\\   &amp; d\\text{NH4} = KN_3 \\cdot \\text{DON}-Nit \\cdot \\text{NH4}+ \\sum_{m=1,3} n2c^m \\cdot \\left( FNP_4^m \\cdot \\text{PR}^m + FNM_4^m \\cdot \\text{MT}^m -fPN^m \\cdot \\text{GP}^m \\right) \\\\   &amp; d\\text{NO3} = Nit \\cdot \\text{NH4}-dn2c \\cdot Denit \\cdot \\text{DOC}-\\sum_{m=1,3} n2c^m \\cdot \\left( 1-fPN^m \\right) \\cdot \\text{GP}^m  \\\\   &amp; d\\text{SRPON} = -KN_S \\cdot \\text{SRPON}+ \\sum_{m=1,3} n2c^m \\cdot \\left( FNP_5^m \\cdot \\text{PR}^m + FNM_5^m \\cdot \\text{MT}^m \\right)\\\\ \\end{flalign}\\] <p>Phosphorus (RPOP, LPOP, DOP, PO4):</p> \\[\\begin{flalign}   &amp; d\\text{RPOP}= -KP_1 \\cdot \\text{RPOP}+ \\sum_{m=1,3} p2c^m \\cdot \\left( FPP_1^m \\cdot \\text{PR}^m + FPM_1^m \\cdot \\text{MT}^m \\right) \\\\   &amp; d\\text{LPOP}= -KP_2 \\cdot \\text{LPOP}+ \\sum_{m=1,3} p2c^m \\cdot \\left( FPP_2^m \\cdot \\text{PR}^m + FPM_2^m \\cdot \\text{MT}^m \\right) \\\\   &amp; \\begin{split}       &amp; d\\text{DOP} = KP_1 \\cdot \\text{RPOP} + KP_2 \\cdot \\text{LPOP} + KP_S \\cdot \\text{SRPOP} -KP_3 \\cdot \\text{DOP}  \\\\      &amp; + \\sum_{m=1,3} p2c^m \\cdot \\left( FPP_3^m \\cdot \\text{PR}^m + FPM_3^m \\cdot \\text{MT}^m \\right)    &amp; \\end{split} \\\\   &amp; d\\text{PO4} = KP_3 \\cdot \\text{DOP} + KP_P \\cdot \\text{PIP} + \\sum_{m=1,3} p2c^m \\cdot \\left( FPP_4^m \\cdot \\text{PR}^m + FPM_4^m \\cdot \\text{MT}^m - \\text{GP}^m \\right) \\\\   &amp; d\\text{SRPOP} = -KP_S \\cdot \\text{SRPOP}+ \\sum_{m=1,3} p2c^m \\cdot \\left( FPP_5^m \\cdot \\text{PR}^m + FPM_5^m \\cdot \\text{MT}^m \\right)\\\\   &amp; d\\text{PIP} = -KP_P \\cdot \\text{PIP} \\\\ \\end{flalign}\\] <p>Oxygen (COD, DO):</p> \\[\\begin{flalign}  &amp; d\\text{COD} = -K_{COD} \\cdot \\text{COD}  \\\\  &amp; \\begin{split} \\\\    &amp; d\\text{DO} = -o2n \\cdot Nit \\cdot \\text{NH4} -o2c \\cdot K_{HR} \\cdot \\text{DOC} -K_{COD} \\cdot \\text{COD} \\\\    &amp; + \\sum_{m=1,3} o2c \\cdot \\left[ \\left(1.3-0.3 \\cdot fPN^m \\right) \\cdot \\text{GP}^m -\\left(1- \\sum_{i=1,4} FCM_i^m \\right) \\cdot \\frac{DO}{DO+KhDO^m} \\cdot \\text{MT}^m \\right] \\\\    &amp; \\end{split} \\\\ \\end{flalign}\\]"},{"location":"modules/icm.html#12-pre-calculation","title":"1.2. Pre-Calculation","text":""},{"location":"modules/icm.html#121-growth-metabolism-predation","title":"1.2.1. Growth, metabolism, predation","text":"\\[\\begin{flalign}   &amp; \\text{GP}^i = \\text{GPM}^i \\cdot f(T) \\cdot f(Sal) \\cdot f(I) \\cdot \\text{min} \\left[ f(N),f(P),f(S) \\right] \\cdot \\text{PB}^i \\\\   &amp; \\text{MT}^i = \\text{MTR}^i \\cdot \\text{GP} +\\text{MTB}^i \\cdot \\text{exp} \\left[ KT_{MT}^i \\cdot \\left( T-T_{MT}^i \\right) \\right] \\cdot \\text{PB}^i \\\\   &amp; \\text{PR}^i = \\begin{cases}    &amp; \\text{PRR}^i \\cdot \\text{exp} \\left[ KT_{MT}^i \\cdot \\left( T-T_{MT}^i \\right) \\right] \\cdot \\text{PB}^i \\text{,        iPR=0} \\\\    &amp; \\text{PRR}^i \\cdot \\text{exp} \\left[ KT_{MT}^i \\cdot \\left( T-T_{MT}^i \\right) \\right] \\cdot \\left( \\text{PB}^i \\right)^2 \\text{,   iPR=1} \\\\  \\end{cases} \\\\  \\end{flalign}\\] \\[\\begin{flalign}   &amp; f(I)= \\frac{\\text{mLight}}{\\sqrt{\\text{mLight}^2+IK^2}}   \\\\   &amp; f(T)=  \\begin{cases}     \\text{exp}\\left[-KTGP_1^i \\cdot \\left( T-TGP^i \\right)^2 \\right] \\text{, if }T &lt; TGP^i \\\\    \\text{exp}\\left[-KTGP_2^i \\cdot \\left( T-TGP^i \\right)^2 \\right] \\text{, if }T \\geq TGP^i \\\\ \\end{cases} \\\\    &amp; f(N)= \\frac{\\text{DIN}}{\\text{DIN}+KhN^i} \\\\   &amp; f(P)= \\frac{\\text{PO4d}}{\\text{PO4d}+KhP^i} \\\\   &amp; f(Sal)= \\frac{KhSal_i^2}{KhSal_i^2+Sal^2} \\\\ \\end{flalign}\\]"},{"location":"modules/icm.html#122-decay-rates-of-orgnaic-matter","title":"1.2.2. Decay rates of orgnaic matter","text":"\\[\\begin{flalign}   &amp; KC_i = \\left( KC_i^0+KC_i^{alg} \\cdot APB \\right) \\cdot KT_M \\\\   &amp; KN_i = \\left( KN_i^0+KN_i^{alg} \\cdot APB \\cdot \\frac{mKhN}{mKhN+DIN} \\right) \\cdot KT_M \\\\   &amp; KP_i = \\left( KP_i^0+KP_i^{alg} \\cdot APB \\cdot \\frac{mKhP}{mKhP+PO4_d} \\right) \\cdot KT_M \\\\ \\end{flalign}\\] \\[\\begin{flalign}   KT_M=\\text{exp} \\left[ KT_{RM}^i \\cdot \\left( T-T_{RM}^i \\right) \\right] \\end{flalign}\\]"},{"location":"modules/icm.html#123-respiration-denitrification-decay-of-cod-nitrification","title":"1.2.3. Respiration, denitrification, decay of COD, nitrification","text":"\\[\\begin{flalign}   &amp; K_{HR} = KC_3 \\cdot \\frac{DO}{KhDO_{OX}+DO} \\\\    &amp; K_{COD}= \\frac{DO}{KhCOD+DO} \\cdot KCD \\cdot \\text{exp}[KT_{RCOD} \\cdot (T-T_{RCOD})] \\\\   &amp; Denit = an2c \\cdot KC_3 \\cdot \\frac{KhDO_{OX}}{KhDO_{OX}+DO} \\cdot \\frac{NO3}{KhNO3_{dn}+NO3} \\\\   &amp; Nit = Nit^{max} \\cdot \\frac{DO}{KhDO_n+DO} \\cdot \\frac{KhNH4_n}{KhNH4_n+NH4} \\cdot  \\begin{cases}   \\text{exp}[-KT_{Nit}^1 \\cdot (T_{Nit}-T)] \\text{, if } T&lt;T_{Nit} \\\\   \\text{exp}[-KT_{Nit}^2 \\cdot (T-T_{Nit})] \\text{, if } T \\geq T_{Nit}\\\\ \\end{cases} \\end{flalign}\\]"},{"location":"modules/icm.html#13-light","title":"1.3 Light","text":""},{"location":"modules/icm.html#14-surfacebottom-fluxes","title":"1.4 Surface/bottom fluxes","text":""},{"location":"modules/icm.html#do-reareation","title":"DO reareation","text":""},{"location":"modules/icm.html#14-2d-spatially-varying-parameters","title":"1.4 2D spatially varying parameters","text":""},{"location":"modules/icm.html#16-tss","title":"1.6 TSS","text":""},{"location":"modules/icm.html#old-user-guide-of-icm","title":"Old User Guide of ICM.","text":""},{"location":"modules/marsh-migration.html","title":"Marsh migration","text":"<p>This module (<code>USE_MARSH</code>) is not a tracer module and simulates the long-term migration of marshes under sea level rise. It is usually invoked together with SED (with optional morphological acceleration) and optionally with WWM; cf. Nunez et al. (2020).</p> <p>The only parameter for this module is <code>slr_rate</code> (sea-level rise rate in mm/yr). The output flag is <code>iof_marsh</code>, which is an integer of either 0 (no marsh) or 1 (has marsh) at an element. Optionally, the user might also consider invoking the vegetation option in the code <code>isav</code> in conjunction with the marsh module to simulate the form drag and turbulence induced by the marsh vegetation.</p> <p>Additional inputs are required to specify the I.C. for marsh extent (<code>marsh_init.prop</code>) as well as migration barrier info (<code>marsh_barrier.prop</code>); both use 0 or 1 to specify \u2018on/off\u2019.</p> <p>References</p> <p>Nunez, K., Zhang, Y., Herman, J., Reay, W. and Hershner, C. (2020) A multi-scale approach for simulating tidal marsh evolution, Ocean Dynamics, https://doi.org/10.1007/s10236-020-01380-6</p>"},{"location":"modules/multi-class-ice.html","title":"Theory","text":"<p>The column physics package of the Los Alamos sea ice model (CICE), the Icepack (v1.3.4) has been couple with SCHISM. Besides the zero-layer thermodynamics, two more sophisticated thermodynamic formulations, the Bitz and Lipscomb (1999; BL99) thermodynamics formulation for constant salinity profiles, and the mushy layer thermodynamics formulation for evolving salinity (Turner et al., 2013), are also implemented. At the sub-grid scale, thin ice and thick ice coexist, and therefore an ice thickness distribution (ITD; Lipscomb, 2001; Bitz et al., 2001) has been implemented in order to describe the unresolved spatial heterogeneity of the thickness field. The ITD offers a prognostic statistical description of the sea ice thickness, which it divides into multiple categories, along with the ice area fraction corresponding to each category \u2013 a more detailed approach than the single fraction used in the previous implementation. More tracers and more ice processes are added in this coupled model by Icepack, including multiple melt pond parameterizations (Hunke et al., 2013) and a mechanical redistribution parameterization (Lipscomb et al., 2007) that responds to sea ice convergence by piling up thin sea ice and therefore mimicking ridging and rafting events. The interaction between the shortwave radiation and the sea ice in Icepack is addressed using two formulations: the Community Climate System Model (CCSM3) formulation, which relates the surface albedo to the surface sea ice temperature, and the delta\u2013Eddington formulation (Briegleb et al., 2007), which relates the albedo to inherent optical properties of sea ice and snow. The dynamic solver is not included in Icepack and we used two approaches: (1) the classic elastic\u2013viscous\u2013plastic method (EVP; Hunke and Dukowicz, 1997) and (2) the modified elastic\u2013viscous\u2013plastic method (mEVP; Kimmritz et al., 2015). Both methods are inherited from the previous single-class ice and snow formulation (Zhang et al., 2023).</p>"},{"location":"modules/multi-class-ice.html#usage","title":"Usage","text":"<ol> <li>Compile with USE_MICE and USE_EVAP on;</li> <li>Provide snow flux data in sflux/sflux_prc* files (named as srate), the format is the same as rainfall data (prate);</li> <li>The main parameter input for this module is mice.nml and namelist.icepack (you can find a sample in sample_input/);</li> <li>For the parameters in the mice.nml, ice_advection=6 (hybrid TVD-upwind) is recommended. For the parameters in namelist.icepack, you can find them all in the Icepack manual.</li> <li>For the output, all variables for iof_mice in param.nml are enabled under new scribe IO, but only the variables in namelist.icepack are enabled under OLDIO; this needs to be updated in newer versions.</li> <li>Optional ihot_mice in mice.nml to allow different hotstart modes between ice and hydro. In general, ihot_mice works like ihot. ihot_mice=0 is the cold start. Under ihot_mice=1 the initial file (hotstart.nc) should contain ice concentration, thickness and velocity and from external model like HYCOM (scripts is gen_hot_from_hycom_ice.f90). ihot_mice=2 is a restart function like ihot=2, where the ice variables are stored in outputs/hotstart*. The routine for this is inside icedrv_io.f90 (restart_icepack), but this mode is not stable if there are too many variables, like floe size distribution (tr_fsd).</li> </ol>"},{"location":"modules/multi-class-ice.html#references","title":"References","text":"<p>Bitz, C. M. and Lipscomb, W. H.: An energy-conserving thermodynamic model of sea ice, J. Geophys. Res.-Oceans, 104, 15669\u201315677, https://doi.org/10.1029/1999JC900100, 1999.\u2002</p> <p>Bitz, C. M., Holland, M. M., Weaver, A. J., and Eby, M.: Simulating the ice-thickness distribution in a coupled climate model, J. Geophys. Res.-Oceans, 106, 2441\u20132463, https://doi.org/10.1029/1999JC000113, 2001.\u2002</p> <p>Briegleb, B. P. and Light, B.: A Delta-Eddington multiple scattering parameterization for solar radiation in the sea ice component of the Community Climate System Model, Tech. Rep. NCAR/TN 472+STR, National Center for Atmospheric Research, Boulder, Colorado USA, https://doi.org/10.5065/D6B27S71, 2007.\u2002</p> <p>Hunke, E., Allard, R., Bailey, D. A., Blain, P., Craig, A., Dupont, F., DuVivier, A., Grumbine, R., Hebert, D., Holland, M., Jeffery, N., Lemieux, J.-F., Osinski, R., Rasmussen, T., Ribergaard, M., Roach, L., Roberts, A., Turner, M., and Winton, M.: CICE-Consortium/Icepack: Icepack 1.3.4 (1.3.4), Zenodo [code], https://doi.org/10.5281/zenodo.8336034, 2023.\u2002</p> <p>Hunke, E. C. and Dukowicz, J. K.: An elasticviscous-plastic model for sea ice dynamics, J. Phys. Oceanogr., 27, 1849\u20131867, https://doi.org/10.1175/1520-0485(1997)027&lt;1849:AEVPMF&gt;2.0.CO;2, 1997.\u2002</p> <p>Kimmritz, M., Danilov, S., and Losch, M.: On the convergence of the modified elastic-viscous-plastic method for solving the sea ice momentum equation, J. Comput. Phys., 296, 90\u2013100, https://doi.org/10.1016/j.jcp.2015.04.051, 2015.\u2002</p> <p>Lipscomb, W. H.: Remapping the thickness distribution in sea ice models, J. Geophys. Res., 106, 13989\u201314000, https://doi.org/10.1029/2000JC000518, 2001.\u2002</p> <p>Lipscomb, W. H. and Hunke, E. C.: Modeling sea ice transport using incremental remapping, Mon. Weather Rev., 132, 1341\u20131354, https://doi.org/10.1175/1520-0493(2004)132&lt;1341:MSITUI&gt;2.0.CO;2, 2004.\u2002</p> <p>Turner, A. K., Hunke, E. C., and Bitz, C. M.: Two modes of sea-ice gravity drainage: A parameterization for largescale modeling, J. Geophys. Res.-Oceans, 118, 2279\u20132294, https://doi.org/10.1002/jgrc.20171, 2013.\u2002</p> <p>Zhang, Y. J., Wu, C., Anderson, J., Danilov, S., Wang, Q., Liu, Y., and Wang, Q.: Lake ice simulation using a 3D unstructured grid model, Ocean Dynam., 73, 219\u2013230, https://doi.org/10.1007/s10236-023-01549-9, 2023.\u2002</p>"},{"location":"modules/overview.html","title":"Overview","text":"<p>Attention</p> <p>Note that some modules are under active development and we will update the info as it becomes available.</p> <p>SCHISM modules can be broadly divided into two categories: tracer and non-tracer modules. The main difference is that tracer modules share more infrastructure with the main hydro code base, e.g. using the transport solver, with I.C. and B.C.\u2019s that resemble those for the temperature and salinity, and sharing the source inputs (<code>msource.th</code>). Most modules also require additional inputs of their own (e.g. <code>wwminput.nml</code> for WWM).</p> <p>There are 12 tracer modules and they are (in order of appearance and precedence in <code>bctides.in</code>; the names in brackets are used in input names; e.g. <code>TEM_1.th</code> etc) - </p> <ol> <li>Temperature [<code>TEM</code>]</li> <li>Salinity [<code>SAL</code>]</li> <li>Generic tracer [<code>GEN</code>]: generic tracer module with a settle velocity <code>gen_wsett</code> in <code>param.nml</code>). The user can use this module as a template to add their own tracer behavior etc (by modifying the code sections bounded by <code>USE_GEN</code>);</li> <li>AGE [<code>AGE</code>]: water age module of Delhez &amp; Deleersnijder (2002) and Shen and Haas (2004);</li> <li>SED3D [<code>SED</code>]: 3D non-cohesive sediment transport module;</li> <li>EcoSim [<code>ECO</code>]: EcoSim of Paul Bissett;</li> <li>ICM [<code>ICM</code>]: USACE\u2019s water quality model of CE-QUAL-ICM</li> <li>CoSINE [<code>COS</code>]: Carbon, Silicate, Nitrogen Ecosystem model of Prof. Fei Chai (U. of Maine)</li> <li>Fecalbacteria [<code>FIB</code>]: fecal indicating bacteria model;</li> <li>TIMOR: not active at the moment</li> <li>FABM [<code>FBM</code>]: Framework for Aquatic Biogeochemical Models, a flexible biogeochemical model framework;</li> <li>DVD [<code>DVD</code>]: numerical mixing analysis of Klingbeit et al. (2014)</li> </ol> <p>The B.C. flags for each invoked tracer module are specified in <code>bctides.in</code>. For example, if you invoked <code>GEN</code> (1 class), <code>SED</code> (1 class), and <code>ICM</code> (21 state variables inside), the boundary condition at an open segment may look like - </p> <pre><code>39 2 0 3 4 1 2 2 ![# of nodes], elev, vel, T,S, GEN, SED, ICM\n0.5 !constant elev\n0.1 !relax for T\n0.1 !relax for S\n0.5 !relax for GEN\n0. !constant SED concentration\n1.e-3 !relax for SED\n0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. !ICM concentrations\n1.e-3  !relax for ICM\n[next segment...]\n</code></pre> <p>And in addition, you\u2019ll need to prepare inputs: <code>SAL_3D.th.nc</code> and <code>GEN_*.th</code>. </p> <p>Similarly, msource.th should also include the tracer concentrations for all invoked modules; for the example shown above, a line in the msource.th should look like this (assuming 2 sources in source_sink.in):</p> <pre><code>86400. 10. 10. 0. 0. -9999. -9999. 0. 0. -9999. ...-9999. !time (sec), T, S, GEN, SED, ICM\n\n                                         &lt;-------------&gt;\n                                       21x2 values for ICM\n</code></pre> <p>For some tracer modules the user also needs to specify number of tracer classes inside the module in <code>param.nml</code>:</p> <pre><code>ntracer_gen = 2 !user defined module (USE_GEN)\nntracer_age = 4 !age calculation (USE_AGE). Must be =2*N where N is # of age tracers\nsed_class = 5 !SED3D (USE_SED)\neco_class = 27 !EcoSim\n</code></pre> <p>The output flags for all modules are <code>iof_[name]</code>, where name is the lower case of the module name; e.g. <code>iof_wwm()</code>. See the sample <code>param.nml</code> for a complete list of output flags as well as the variable names that appear in the netcdf outputs. Some modules have additional parameters specified in <code>param.nml</code>; e.g., <code>gen_wsett</code>, <code>flag_fib</code> etc. See the sample <code>param.nml</code> for explanation.</p>"},{"location":"modules/pahm.html","title":"PaHM","text":"<p>The manual for Parametric Hurricane Modeling System (PaHM) can be found here</p>"},{"location":"modules/particle-tracking.html","title":"Particle tracking","text":"<p>This is not a module per se; rather the stand-alone code <code>Utility/Particle_Tracking/ptrack*.f90</code> takes the outputs from SCHISM.</p> <p>SCHISM supports a 3D particle tracking, which can also be used for simple oil spill simulation. The code can do forward/backward tracking and has simple dispersion and beach retention processes for oil spill.</p> <p>The inputs to this code are: <code>hgrid.gr3</code>, <code>vgrid.in</code>, <code>particle.bp</code>, and <code>schout*.nc</code>. The main parameters are set in <code>particle.bp</code>. Below is a sample:</p> <pre><code>1 !screen outputs\n0 !mod_part (0: passive; 1: oil spill)\n1 !ibf (forward (=1) or backward (=-1) tracking)\n1 !istiff (1: fixed distance from free surface)\n1 -124 46.25 !ics slam0 sfea0 (see param.nml)\n0.1 8. 90. 10 960 9 ! h0, rnday, dt, nspool, ihfskip, ndeltp (same as param.nml except for the last one, which is # of sub-divisions within each step)\n16 !# number of particles\n1 84600. 385000 510000 -5. !particle id, start time (s), starting x,y, and z relative to the instant surface (&lt;=0)\n2 84610. 300000 450000 0.\n...\n</code></pre> <p>The main output is <code>particle.pth</code>, which uses the drogue format that can be visualized with ACE/xmvis6. Figure 1 shows an example.</p> <p></p> Particle tracking with SCHISM."},{"location":"modules/pdaf.html","title":"Data assimilation (PDAF)","text":"<p>We are working on a user manual; meanwhile this paper serves as interim manual. </p>"},{"location":"modules/sed2d.html","title":"2D Sediment model","text":"<p>The manual for this module can be found here. This module may be eventualy  removed as users can use SED3D under polymorphism.</p>"},{"location":"modules/sed3d.html","title":"3D Sediment model","text":"<p>The 3D sediment model inside SCHISM (USE_SED, also referred to as \u2018SED3D\u2019 sometimes to differentiate it from the 2D sediment module \u2018SED2D\u2019) is adapted from Community Sediment Transport Model (Warner et al. 2008). The algorithm is implemented on UGs and we have also reworked several components and added a morphological module (Exner equation). Detailed are reported in Pinto et al. (2012). Also note that for best results this module should be run in conjunction with the wave model (WWM) to account for the wave-enhanced bottom stress.</p> <p>The main parameter input is <code>sediment.nml</code>, which is a namelist file.  The sample file has comments /explanations for each parameter; a few important ones are explained below:</p> <ul> <li><code>sed_morph</code>: This parameter controls active morphology.</li> <li><code>Nbed</code>: The # of bed layers affects the stability of the sorting, and <code>Nbed=1</code> works robustly with <code>sed_morph&gt;0</code>.</li> </ul> <p>Other inputs include <code>sed_class</code> and output flags in <code>param.nml</code>, and a few <code>.ic</code> files: <code>bedthick.ic</code>, <code>bed_frac_[1,2..].ic</code>, and I.C. for concentrations of all classes (<code>*_[hvar]_[1,2\u2026].ic</code> or (<code>*_[vvar]_[1,2\u2026].ic</code>). The B.C. inputs may include <code>SED_[1,2..].th</code>, <code>SED_3D.th.nc</code>. The nudging inputs may be <code>SED_nudge.gr3</code> and <code>SED_nu.nc</code>.</p> <p>The outputs from SED3D can be combined and visualized just as other SCHISM outputs.</p> <p>A common crash occurs when the active morphology is on. At a river inflow boundary, often the depths will decrease over time due to deposition there and eventually the boundary will become dry/blocked. A work-around is to use a combination of \u2018bare-rock\u2019 bed around the boundary (specified in <code>bedthick.ic</code>), and \u2018clear-water\u2019 inflow as B.C. (sediment concentration =0 in <code>bctides.in</code>) , and then input the incoming sediment concentration as point sources (<code>msource.th</code>) a distance away from the boundary.</p> <p>References</p> <p>Pinto, L., Fortunato, A.B., Zhang, Y., Oliveira, A. and Sancho, F.E.P. (2012) Development and validation of a three-dimensional morphodynamic modelling system, Ocean Mod., 57-58, 1-14.</p> <p>Warner, J.C., Sherwood, C.R., Signell, R.P., Harris, C.K., Arango, H.G. 2008. Development of a three-dimensional, regional, coupled wave, current, and sediment-transport model. Comput. Geosci. 34 (10), 1284\u20131306. doi: 10.1016/j.cageo.2008.02.012</p>"},{"location":"modules/single-class-ice.html","title":"Theory","text":"<p>The single-class ice/snow module is taken from FESOM2, courtesy of Dr. Sergey Danilov's group. The info below is from the FESOM2 manual with minor modifications   to show some new additions.</p> <p>Dynamical part solves the ice motion equation:</p> \\[\\begin{equation} \\label{ice01}  m(\\partial_t + \\pmb{f} \\times) \\pmb{u}=a\\tau - aC_d\\rho_o (\\pmb{u}-\\pmb{u}_o)|\\pmb{u}-\\pmb{u}_o| +\\pmb{F} -mg\\nabla H \\end{equation}\\] <p>Here \\(m\\) is the ice plus snow mass per unit area, \\(C_d\\) the ice-ocean drag coefficient, \\(\\rho_o\\) the water density, \\(a\\) the ice compactness, \\(\\pmb{u}\\) and \\(\\pmb{u}_o\\) the ice and ocean velocities, \\(\\tau\\) the wind stress, \\(H\\) the sea surface elevation, \\(g\\) the acceleration due to gravity and \\(F_j = \\partial_i \\sigma_{ij}\\) is the force from stresses within the ice. Here we use Cartesian coordinates for brevity, with \\(i, j = 1, 2\\) implying \\(x\\) and \\(y\\) directions, and the implementation of spherical coordinates will be discussed further. Summation over repeating coordinate indices is implied. The stress tensor is symmetric. The mass \\(m\\) is the combination of ice and snow contributions</p> \\[\\begin{equation}  m=\\rho_{ice}h_{ice}+\\rho_sh_s \\end{equation}\\] <p>with \\(\\rho_{ice}\\) and \\(\\rho_s\\), respectively, the densities of ice and snow and \\(h_{ice}\\) and \\(h_s\\) their mean thicknesses (volumes per unit area).</p> <p>For the visco-plastic (VP) rheology (Hibler, 1979) one writes</p> \\[\\begin{equation} \\label{ice02} \\sigma_{ij}=2\\eta (\\dot{\\epsilon}_{ij} -0.5 \\delta_{ij} \\dot{\\epsilon}_{kk}) + \\zeta \\delta_{ij} \\dot{\\epsilon}_{kk} -0.5\\delta_{ij} P \\end{equation}\\] <p>where</p> \\[\\begin{equation}  \\dot{\\epsilon}_{ij}=0.5(\\partial u_i / \\partial x_j + \\partial u_j / \\partial x_i) \\end{equation}\\] <p>is the deformation rate tensor, \\(\\eta\\) and \\(\\zeta\\) are the moduli (\u2018viscosities\u2019) and \\(P\\) the pressure. Both the stress and deformation rate tensors are symmetric, so they are characterized by three independent components. The standard VP rheology adopts the following scheme of computing pressure \\(P\\) and moduli \\(\\eta\\) and \\(\\zeta\\): </p> \\[\\begin{equation}  P_0=h_{ice}p^* exp[-C(1-a)], P=P_0\\frac{\\Delta}{(\\Delta+\\Delta_{min}}, \\zeta=\\frac{0.5P_0}{\\Delta+\\Delta_{min}}, \\eta=\\frac{\\zeta}{e^2} \\end{equation}\\] <p>\\(e=2\\)  (the ellipticity parameter), \\(C=20\\), \\(\\Delta_{min}=2.e-9 s^{-1}\\), and \\(p^*=15000 Pa\\)  are default values, they are adjusted in practice. In this scheme,  \\(\\Delta_{min}\\) serves for viscous regularization of plastic behavior in areas where \\(\\Delta t\\) is very small. We note that recent multi-category ice implementations (such as CICE, see Hunke and Lipscomb 2008) use different parameterization for \\(P_0\\), which takes into account the distribution of ice over thickness categories. This does not change the basic equations (\\(\\ref{ice01}\\), \\(\\ref{ice02}\\)).</p> <p>In our case we deal with three tracers, the area coverage \\(a\\), ice volume \\(h_{ice}\\) and snow volume \\(h_s\\). They are advected with ice velocities and modified through thermodynamical forcing</p> \\[\\begin{equation} \\label{ice03} \\partial_t a+\\nabla(a\\pmb{u})=S_a, \\partial_t h_{ice}+\\nabla(h_{ice}\\pmb{u})=S_{ice}, \\partial_t h_s+\\nabla(h_s\\pmb{u})=S_s \\end{equation}\\] <p>with \\(S_a\\), \\(S_{ice}\\) and \\(S_s\\) the sources due to the exchange with atmosphere and ocean.</p> <p>The system (\\(\\ref{ice01}, \\ref{ice02}, \\ref{ice03}\\)), augmented with appropriate model of sources and boundary conditions, defines the sea ice model. We use the boundary conditions of no slip for momentum and no flux for tracers at lateral walls. The well known difficulty in solving these equation is related to the rheology term in the momentum equation, which makes this equation very stiff and would require time steps of fractions of second if stepped explicitly. There are two ways of handling this difficulty. The first one treats the rheology part in an implicit way, with linearization for the moduli, as suggested by Zhang and Hibler (1997). As mentioned elsewhere (see, e. g., Lemieux and Tremblay, 2009), it does not warrant full convergence, which requires a full nonlinear solver (for example, a Jacobian-free Newton-Krylov one, see Lemieux et al. 2012). The latter is still too expensive computationally, so the VP option used by us is similar in spirit to that of Zhang and Hibler (see section 2.4). The second way is to reformulate the VP approach by adding pseudo-elasticity. It raises the time order of the system \\(\\ref{ice01}, \\ref{ice02}\\) to the second, which makes the CFL limitation on the explicit time step much less severe than in the original VP framework.</p> <p>Below is the formulation for a modified elastic-visco-plastic (mEVP) due to Bouillon et al. (2013). It can be considered as a pseudo-time solver for VP rheology. In this case one writes</p> \\[\\begin{equation} \\begin{aligned}  \\alpha (\\sigma_1^{p+1} - \\sigma_1^{p})=\\frac{P_0}{\\Delta^p+\\Delta_{min}} (\\dot{\\epsilon}_1^p -\\Delta^p)-\\sigma_1^{p} \\\\  \\alpha (\\sigma_2^{p+1} - \\sigma_2^{p})=\\frac{P_0}{(\\Delta^p+\\Delta_{min})e^2} \\dot{\\epsilon}_2p -\\sigma_2^{p} \\\\  \\alpha (\\sigma_{12}^{p+1} - \\sigma_{12}^{p})=\\frac{P_0}{(\\Delta^p+\\Delta_{min})e^2} \\dot{\\epsilon}_{12}^p -\\sigma_{12}^{p}  \\end{aligned} \\end{equation}\\] <p>for stresses and</p> \\[\\begin{equation} \\beta(\\pmb{u}^{p+1}-\\pmb{u}^p)=-\\pmb{u}^{p+1}+\\pmb{u}^n-\\Delta t \\pmb{f}\\times \\pmb{u}^{p+1}+\\frac{\\Delta t}{m}[\\pmb{F}^{p+1}+a\\tau+C_da\\rho_o(\\pmb{u}_o^n-\\pmb{u}^{p+1})|\\pmb{u}_o^n-\\pmb{u}^p| -mg\\nabla H^n] \\end{equation}\\] <p>for velocity. We define:</p> \\[\\begin{equation}   \\sigma_1=\\sigma_{11}+\\sigma_{22},  \\sigma_2=\\sigma_{11}-\\sigma_{22} \\end{equation}\\] <p>and similarly for deformation:</p> \\[\\begin{equation}   \\dot{\\epsilon}_1=\\dot{\\epsilon}_{11}+\\dot{\\epsilon}_{22},  \\dot{\\epsilon}_2=\\dot{\\epsilon}_{11}-\\dot{\\epsilon}_{22} \\end{equation}\\] <p>Here \\(\\alpha\\) and \\(\\beta\\) are some large constants. The subscript \\(p\\) is related to pseudotime iterations, replacing subcycling of the standard EVP, and \\(n\\) is the previous time step. Fields are initialized with values at time step \\(n\\) for \\(p = 1\\), and their values for the last iteration \\(p = N_{EVP}\\) are taken as solutions for time step \\(n+ 1\\). Clearly, if \\(N_{EVP}\\) is sufficiently large, the VP solutions have to be recovered. In order that CFL limitations be satisfied, the product \\(\\alpha\\beta\\) should be sufficiently large (see Bouillon et al. (2013)). The regime of the standard EVP scheme (\\(N_{EVP} = 120\\) and \\(T_{EVP} = \\Delta t/3\\)) will be approximately recovered for \\(\\alpha =\\beta  = 40\\) and \\(N_{EVP} = 120\\), but much larger values have to be used on fine meshes to warrant absence of noise. For this reason, in SCHISM we have added a new option where \\(\\alpha\\) and \\(\\beta\\) are functions  of the mesh size:</p> \\[\\begin{equation}   \\alpha =\\beta=\\frac{C}{tanh(BA/\\Delta t_{ice})} \\end{equation}\\] <p>where \\(A\\) is element area, \\(C\\) is the minimum, and \\(B\\) is an adjustable coefficient that controls how quickly \\(\\alpha\\) and  \\(\\beta\\) depart from their minimum, \\(\\Delta t_{ice}\\) is the time step used in the ice model. </p> <p>One expects that if this scheme is stable and converged, it should produce solutions identical to those of converging VP solver. In reality, it will not be run for full convergence, which is still too expensive, and some difference will be preserved. The sea-ice model described here implements the three approaches mentioned above, which will be referred further as VP, EVP and mEVP. The reason of keeping all them is two-fold. First, it facilitates the comparison of results with other models which may be using one of these approaches. Second, their numerical efficiency and performance depend on applications, and one may wish to select the most appropriate approach.</p> <p>The tracer transport equation (\\(\\ref{ice03}\\)) is solved using a FCT scheme. </p>"},{"location":"modules/single-class-ice.html#usage","title":"Usage","text":"<ol> <li>Compile with USE_ICE on;</li> <li>The time step for this moule is controlled by <code>nstep_ice</code> in <code>param.nml</code>. In addition, the output handles are found in <code>SCHOUT</code> section. The code will compute the ice-ocean stress at cells covered by ice;</li> <li>The main parameter input for this module is <code>ice.nml</code> (you can find a sample in <code>sample_inputs/</code>), where you specify the ice thermodynamic constants etc. You can specify the new mEVP option with <code>mevp_coef</code>.</li> <li>Control dispersion/diffusion in transport by using the parameters in <code>ice.nml</code> and <code>ice_fct.gr3</code>. This is important for very fine mesh size.</li> </ol>"},{"location":"modules/single-class-ice.html#references","title":"References","text":"<ol> <li>Bouillon, S., Fichefet, T., Legat, V., Madec, G., 2013. The elastic-viscous-plastic method revisited, Ocean Modelling 71, 2\u201312.</li> <li>Lemieux, J.-F., Knoll, D., Tremblay, B., Holland, D., Losch, M., 2012. A comparison of the Jacobian-free Newton\u2013Krylov method and the EVP model for solving the sea ice momentum equation with a viscous-plastic formulation: a serial algorithm study. Journal of Computational Physics 231 (17), 5926\u20135944.</li> <li>Lemieux, J.-F., Tremblay, B., 2009. Numerical convergence of viscousplastic sea ice models. Journal of Geophysical Research 114, C05009.</li> <li>Zhang, J., Hibler, W.D, On an efficient numerical method for modeling sea ice dynamics, J. Geophys. Res., 102, 8691\u20138702, 1997.</li> </ol>"},{"location":"modules/wwm.html","title":"WWM (waves)","text":"<p>A preliminary (but outdated) manual for this module can be found in: <code>src/WWMIII/Manual/manual.tex</code>. For the detailed theory and numerical methods used in WWM, you can consult Dr. Aron Roland\u2019s PhD thesis.</p> <p>Note</p> <p>A good resource for beginners is a mini manual by Ms. Christelle Auguste (U. of Tasmania).</p>"},{"location":"schism/barotropic-solver.html","title":"Barotropic solver","text":""},{"location":"schism/barotropic-solver.html#general-formulation","title":"General formulation","text":"<p>SCHISM solves the barotropic equations first (Eqs 1-3) first, as the transport and turbulent closure equations lag one time step behind (in other words, the baroclinic pressure gradient term in the momentum equation is treated explicitly in SCHISM). The transport and turbulent closure equations will be discussed later. Due to the hydrostatic approximation, the vertical velocity \\(w\\) is solved from the 3D continuity equation after the horizontal velocity is found. To solve the coupled Eqs. 1 and 3, we first discretize them and the vertical boundary conditions semi-implicitly in time as - </p> \\[\\begin{equation} \\label{eq01} \\frac{\\eta^{n+1} - \\eta^{n}}{\\Delta t} + \\theta \\nabla \\cdot \\int_{-h}^{\\eta} \\pmb{u}^{n+1} dz + (1-\\theta) \\nabla \\cdot \\int_{-h}^{\\eta} \\pmb{u}^{n} dz = 0 \\end{equation}\\] \\[\\begin{equation} \\label{eq02} \\frac{\\pmb{u}^{n+1} - \\pmb{u}^*}{\\Delta t} = \\pmb{f} - g \\theta \\nabla \\eta^{n+1} - g(1-\\theta)\\nabla\\eta^n + \\pmb{m}_z^{n+1} - \\alpha\\left|\\pmb{u}\\right|\\pmb{u}^{n+1} L(x, y, z) \\end{equation}\\] \\[\\begin{equation} \\label{eq03} \\begin{aligned} \\text{for 3D cells: }     \\begin{cases}     \\nu^n \\frac{\\partial \\pmb{u}^{n+1}}{\\partial z} = \\pmb{\\tau}_{w}^{n+1}, \\text{ at } z=\\eta^n\\\\     \\nu^n \\frac{\\partial \\pmb{u}^{n+1}}{\\partial z} = \\chi^n \\pmb{u}_{b}^{n+1}, \\text{ at } z=-h     \\end{cases} \\end{aligned} \\end{equation}\\] <p>where superscripts denote the time step, \\(0 \\leq \\theta \\leq 1\\) is the implicitness factor, \\(\\pmb{u}^*(x, y, z, t^n)\\) is the back-tracked value calculated with Eulerian-Lagrangian Method (ELM; see here), and \\(\\chi^n = C_D \\left| \\pmb{u}_{b}^{n} \\right|\\). The elevations in the 2nd and 3rd terms of Eq. \\(\\ref{eq01}\\) are treated explicitly, which effectively amounts to a linearization procedure.</p> <p>A Galerkin weighted residual statement in the weak form for Eq. \\(\\ref{eq01}\\) reads: </p> \\[\\begin{equation} \\label{eq04} \\int_\\Omega \\phi_i \\frac{\\eta^{n+1} - \\eta^{n}}{\\Delta t} d\\Omega + \\theta \\left[ -\\int_\\Omega \\nabla \\phi_i \\cdot \\pmb{U}^{n+1} d\\Omega + \\int_\\Gamma \\phi_i U_n^{n+1} d\\Gamma \\right] + (1-\\theta) \\left[ -\\int_\\Omega \\nabla \\phi_i \\cdot \\pmb{U}^{n} d\\Omega + \\int_\\Gamma \\phi_i U_n^n d\\Gamma \\right] = 0, (i = 1, ... , N_p) \\end{equation}\\] <p>Where \\(N_p\\) is the total number of nodes, \\(\\Gamma \\equiv \\Gamma_\\nu + \\overline{\\Gamma}_\\nu\\) is the boundary of the entire domain \\(\\Omega\\), with \\(\\Gamma_\\nu\\) corresponding to the boundary sagments where natural boundary conditions are specified, \\(\\pmb{U} = \\int_{-h}^{\\eta} \\pmb{u}dz\\) is the depth-integrated velocity, \\(U_n\\) is its normal component along the boundary, and \\(\\hat{U}_n\\) is the boundary condition. In SCHISM, linear shape functions are used (area coordinates for triangles and bi-linear function for quads); thus, \\(\\phi_i\\) are familier \"hat\" functions.</p>"},{"location":"schism/barotropic-solver.html#locally-2d-case","title":"Locally 2D case","text":"<p>Since there is only one degree of freedom in the vertical dimention in this case, a straightforward integration of Eq. \\(\\ref{eq02}\\) gives - </p> \\[\\begin{equation} \\label{eq05} \\pmb{U}^{n+1} = \\check{\\pmb{G}} - g\\theta\\Delta t \\frac{H^2}{\\tilde{H}} \\nabla \\eta^{n+1} \\end{equation}\\] <p>Where \\(\\check{\\pmb{G}}\\) incorporates explicit term - </p> \\[\\begin{equation} \\label{eq06} \\check{\\pmb{G}} = \\frac{H}{\\tilde{H}}\\left[ \\pmb{U}^* + \\Delta t \\left( \\pmb{F} + \\pmb{\\tau}_w - g(1-\\theta)H\\nabla\\eta^n \\right) \\right] \\end{equation}\\] <p>and \\(\\pmb{F}\\) is the depth integrated term of \\(\\pmb{f}\\), and \\(\\tilde{H}\\) is the depth enhanced by the bottom friction and form drag - </p> \\[\\begin{equation} \\label{eq07} \\tilde{H} = H + \\left( \\chi + \\alpha \\left| \\pmb{u} \\right| H\\right)\\Delta t \\end{equation}\\] <p>The net effect of the vegetation is therefore equivalent to increase in the bottom drag, since the 3D structure of the flow/vegetation is not accounted for. Substituting Eq. \\(\\ref{eq05}\\) into Eq. \\(\\ref{eq04}\\) results in an integral equation for the unknown \\(\\eta^{n+1}\\) alone.</p>"},{"location":"schism/barotropic-solver.html#locally-3d-case","title":"Locally 3D case","text":"<p>We first integrate Eq. \\(\\ref{eq02}\\) from bottom to surface - </p> \\[\\begin{equation} \\label{eq08} \\frac{\\pmb{U}^{n+1}-\\pmb{U}^*}{\\Delta t} = \\pmb{F} - gH\\theta\\nabla\\eta^{n+1} - gH(1-\\theta)\\nabla\\eta^n + \\pmb{\\tau}_w - \\chi\\pmb{u}_b^{n+1} - \\alpha\\overline{\\left| \\pmb{u} \\right|} \\pmb{U}^{\\alpha} \\end{equation}\\] <p>where we have performed linearization of the vegetation term - </p> \\[\\begin{equation} \\label{eq09} \\int_{-h}^{z_v} \\left|\\pmb{u}\\right|\\pmb{u}dz \\approx \\overline{\\left| \\pmb{u} \\right|} \\equiv \\overline{\\left| \\pmb{u} \\right|} \\pmb{U}^{\\alpha} , (\\text{where, }\\pmb{U}^{\\alpha} = \\int_{-h}^{z_v}\\pmb{u}dz) \\end{equation}\\] \\[\\begin{equation} \\label{eq10} \\overline{\\left| \\pmb{u} \\right|} = \\frac{1}{H^\\alpha} \\int_{-h}{z_v} \\left| \\pmb{u}^n \\right| dz \\end{equation}\\] <p>and \\(H^\\alpha = z_v +h\\) is the height of vegetation. Note that similar procedures have been used for other nonlinear terms (e.g. the quadratic bottom drag).</p> <p>To eliminate \\(\\pmb{u}_b^{n+1}\\) in Eq \\(\\ref{eq08}\\), we invoke the discretized momentum equation at the bottom cell and utilize the fact that the Reynolds stress is constant within the boundary layer, as shown in Zhang and Baptista (2008) - </p> \\[\\begin{equation} \\label{eq11} \\frac{\\pmb{u}_b^{n+1} - \\pmb{u}_b^*}{\\Delta t} = \\pmb{f}_b - g\\theta\\nabla\\eta^{n+1} - g(1-\\theta)\\nabla\\eta^n - \\alpha\\left|\\pmb{u}_b\\right|\\pmb{u}_b^{n+1} \\end{equation}\\] <p>from which \\(\\pmb{u}_b^{n+1}\\) can be formally solved as - </p> \\[\\begin{equation} \\label{eq12} \\pmb{u}_b^{n+1} = \\frac{1}{1+\\alpha\\left|\\pmb{u}_b\\right|\\Delta t} \\left[\\pmb{u}_b^* +\\pmb{f}_b\\Delta t - g(1-\\theta)\\Delta t \\nabla \\eta^n \\right] - \\frac{g\\theta\\Delta t}{1+\\alpha\\left|\\pmb{u}_b\\right|\\Delta t}\\nabla\\eta^{n+1} \\end{equation}\\] <p>The subscript \\(b\\) denotes the top of the bottom cell. Note that the main difference from the original formulation of Zhang and Baptista (2008) is the appearance of the vegetation term.</p> <p>The remaining task is to find \\(\\pmb{U}^\\alpha\\). We\u2019ll discuss two scenarios of submerged and emergent vegetation.</p>"},{"location":"schism/barotropic-solver.html#emergent-vegetation","title":"Emergent vegetation","text":"<p>When the vegetation is locally emergent, i.e., \\(H^\\alpha \\geq H\\), we have \\(\\pmb{U}^\\alpha = \\pmb{U}^{n+1}\\), and therefore \\(\\pmb{U}^{n+1}\\) can be found from Eq. \\(\\ref{eq08}\\) and \\(\\ref{eq12}\\) as - </p> \\[\\begin{equation} \\label{eq13} \\pmb{U}^{n+1} = \\pmb{G}_1 - \\frac{g\\theta\\hat{H}\\Delta t}{1+\\alpha\\overline{\\left| \\pmb{u} \\right|} \\Delta t} \\nabla\\eta^{n+1} \\end{equation}\\] <p>where \\(\\pmb{G}_1\\) contains explicit terms - </p> \\[\\begin{equation} \\label{eq14} \\pmb{G}_1 = \\frac{\\pmb{U}^* + (\\pmb{F}+\\pmb{\\tau}_w)\\Delta t - g(1-\\theta)\\hat{H}\\Delta t \\nabla\\eta^n-\\tilde{\\chi}\\Delta t (\\pmb{u}_b^*+\\pmb{f}_b\\Delta t)}{1+\\alpha\\overline{\\left| \\pmb{u} \\right|} \\Delta t} \\end{equation}\\] \\[\\begin{equation} \\label{eq15} \\tilde{\\chi} = \\frac{\\chi}{1+\\alpha \\left| \\pmb{u}_b \\right| \\Delta t} \\end{equation}\\] <p>and \\(\\hat{H}\\) is a friction modified depth - </p> \\[\\begin{equation} \\label{eq16} \\hat{H} = H - \\tilde{\\chi}\\Delta t \\end{equation}\\] <p>Compared to the original formulation in Zhang and Baptista (2008), the only change in this depth is the vegetation term in \\(\\tilde{\\chi}\\).</p>"},{"location":"schism/barotropic-solver.html#submerged-vegetation","title":"Submerged vegetation","text":"<p>When the vegetation is submerged, i.e., \\(H^\\alpha &lt; H\\), strong shear and turbulence develop between the vegetation and the overlying flow above it (ST94). Nepf and Vivoni (2000) demonstrated that there are two zones for submerged aquatic vegetation (SAV). In the upper canopy (called the \u2018vertical exchange zone\u2019), mean shear at the top of the canopy produces vertical turbulent exchange with the overlying water, which plays a significant role in the momentum balance. The lower canopy (\u2018longitudinal change zone\u2019 as in Nepf and Vivoni, 2000) communicates with surrounding water predominantly through longitudinal advection. The extent of the vertical exchange of momentum between the vegetation zone and overlying water is dependent on the submergence.</p> <p>We first integrate the momentum equation (Eq. \\(\\ref{eq02}\\)) from the bottom to the top of canopy - </p> \\[\\begin{equation} \\label{eq17} \\pmb{U}^\\alpha = \\pmb{U}^{*\\alpha} + \\pmb{F}^\\alpha\\Delta t - g\\theta H^\\alpha \\Delta t \\nabla\\eta^{n+1} - g(1-\\theta)H^\\alpha\\Delta t \\nabla \\eta^n - \\alpha \\Delta t \\overline{\\left| \\pmb{u} \\right|} \\pmb{U}^\\alpha + \\Delta t\\nu \\Bigr\\rvert_{-h}^{z_v} \\end{equation}\\] <p>where</p> \\[\\begin{equation} \\label{eq18} \\begin{aligned} \\pmb{U}^{*\\alpha} = \\int_{-h}^{z_v}\\pmb{u}^* dz\\\\ \\pmb{F}^\\alpha = \\int_{-h}^{z_v}\\pmb{f}dz \\end{aligned} \\end{equation}\\] <p>The Reynolds stress at the top of canopy can be calculated from theory proposed by ST94. These authors found through lab experiments that the stress variation inside the vegetation layer approximately follows an exponential law</p> \\[\\begin{equation} \\label{eq19} \\nu\\frac{\\partial\\pmb{u}}{\\partial z} \\equiv \\overline{u'w'} = \\pmb{R}_0 e^{\\beta_2 (z-z_v)} \\text{ for } z \\leq z_v \\end{equation}\\] <p>where \\(\\pmb{R}_0\\) is the stress at \\(z=z_v\\), and \\(\\beta_2\\) is determined by an empirical formula - </p> \\[\\begin{equation} \\label{eq20} \\beta_2 = \\sqrt{\\frac{\\sqrt{N_v}}{H^\\alpha}} \\left[ -0.32 - 0.85 \\log_{10} \\left( \\frac{H - H^\\alpha}{H^\\alpha} I\\right) \\right] \\end{equation}\\] <p>where \\(I\\) is an energy gradient - </p> \\[\\begin{equation} \\label{eq21} I = \\frac{\\chi \\left| \\pmb{u}_b \\right|}{gH} \\end{equation}\\] <p>which is estimated from the previous time step in the model.</p> <p>The stress term in Eq. \\(\\ref{eq19}\\) therefore becomes</p> \\[\\begin{equation} \\label{eq22} \\nu\\frac{\\partial\\pmb{u}}{\\partial z}\\Bigr\\rvert_{-h}^{z_v} = \\beta \\chi \\pmb{u}_b^{n+1} \\end{equation}\\] <p>where \\(\\beta = e^{\\beta_2(z_v - z_b)}-1\\), and \\(z_b\\) is the location of the top of the bottom grid cell. Substituting Eq. \\(\\ref{eq22}\\) and Eq. \\(\\ref{eq12}\\) into Eq. \\(\\ref{eq17}\\) we can solve for \\(\\pmb{U}^\\alpha\\) as - </p> \\[\\begin{equation} \\label{eq23} \\pmb{U}^\\alpha = \\pmb{G}_3 - \\frac{g\\theta\\hat{H}^\\alpha\\Delta t}{1+\\alpha\\overline{\\left| \\pmb{u}\\right|}\\Delta t}\\nabla \\eta^{n+1} \\end{equation}\\] \\[\\begin{equation} \\label{eq24} \\pmb{G}_3 = \\frac{\\pmb{U}^{*\\alpha}+\\pmb{F}^\\alpha\\Delta t + \\beta\\tilde{\\chi}\\Delta t(\\pmb{u}_b^* + \\pmb{f}_b\\Delta t) - g(1-\\theta)\\hat{H}^\\alpha\\Delta t \\nabla \\eta^n}{1+\\alpha\\overline{\\left| \\pmb{u} \\right|}\\Delta t} \\end{equation}\\] \\[\\begin{equation} \\label{eq25} \\hat{H}^\\alpha = H^\\alpha + \\beta\\tilde{\\chi}\\Delta t \\end{equation}\\] <p>Finally, substituting Eq. \\(\\ref{eq23}\\) and Eq. \\(\\ref{eq12}\\) into Eq. \\(\\ref{eq08}\\) results in a relationship between \\(\\pmb{U}^{n+1}\\) and \\(\\eta^{n+1}\\) - </p> \\[\\begin{equation} \\label{eq26} \\pmb{U}^{n+1} = \\pmb{G}_2 - g\\theta\\overline{\\overline{H}}\\Delta t \\nabla \\eta^{n+1} \\end{equation}\\] \\[\\begin{equation} \\label{eq27} \\overline{\\overline{H}} = H - \\tilde{\\chi}\\Delta t - c\\hat{H}^\\alpha \\end{equation}\\] \\[\\begin{equation} \\label{eq28} c = \\frac{\\alpha\\overline{\\left| \\pmb{u} \\right|}\\Delta t}{1 + \\alpha\\overline{\\left| \\pmb{u} \\right|}\\Delta t} \\end{equation}\\] \\[\\begin{equation} \\label{eq29} \\pmb{G}_2 = \\pmb{U}^* - c\\pmb{U}^{*\\alpha} + (\\pmb{F} + \\pmb{\\tau_w})\\Delta t - c\\pmb{F}^\\alpha\\Delta t - \\tilde{\\chi}\\Delta t(1+\\beta c)(\\pmb{u}_b^*+\\pmb{f}_b\\Delta t) - g(1-\\theta)\\overline{\\overline{H}}\\Delta t \\nabla\\eta^n \\end{equation}\\]"},{"location":"schism/barotropic-solver.html#general-case","title":"General case","text":"<p>In summary, the depth-integrated velocity can be expressed in compact form as - </p> \\[\\begin{equation} \\label{eq30} \\pmb{U}^{n+1} = \\pmb{E} - g\\theta\\breve{H}\\Delta t\\nabla\\eta^{n+1} \\end{equation}\\] <p>where, </p> \\[\\begin{equation} \\label{eq31} \\begin{aligned} \\breve{H} = \\begin{cases} \\frac{H^2}{\\breve{H}}, \\text{ 2D }\\\\ \\frac{\\hat{H}}{1+\\alpha\\overline{\\left| \\pmb{u} \\right|}\\Delta t}, \\text{ 3D emergent }\\\\ \\overline{\\overline{H}}, \\text{ 3D submerged } \\end{cases} \\end{aligned} \\end{equation}\\] \\[\\begin{equation} \\label{eq32} \\begin{aligned} \\pmb{E} = \\begin{cases} \\breve{\\pmb{G}}, \\text{ 2D }\\\\ \\pmb{G}_1, \\text{ 3D emergent }\\\\ \\pmb{G}_2, \\text{ 3D submerged } \\end{cases} \\end{aligned} \\end{equation}\\] <p>Substituting Eq. \\(\\ref{eq30}\\) back into Eq. \\(\\ref{eq04}\\) gives an equation for the unknown elevations alone - </p> \\[\\begin{equation} \\label{eq33} I_1 = I_4 - \\theta\\Delta t I_3 - (1-\\theta)\\Delta t I_5 - \\theta\\Delta t I_6 \\text{, for } i=1, \\cdots, N_p \\end{equation}\\] <p>where,</p> \\[\\begin{equation} \\label{eq34} I_1 = \\int_\\Omega \\left[ \\phi_i \\eta^{n+1} + g\\theta^2\\Delta t^2\\ \\check{H}\\nabla\\phi_i\\cdot\\nabla\\eta^{n+1}\\right]d\\Omega \\end{equation}\\] \\[\\begin{equation} \\label{eq35} I_4 = \\int_\\Omega \\left[ \\phi_i\\eta^n + \\theta\\Delta t \\nabla\\phi_i\\cdot\\pmb{E} + (1-\\theta)\\Delta t \\nabla\\phi_i \\cdot\\pmb{U}^n \\right]d\\Omega \\end{equation}\\] \\[\\begin{equation} \\label{eq36} I_3 = \\int_{\\Gamma_\\nu} \\phi_i\\hat{U}_n^{n+1}d\\Gamma_\\nu \\end{equation}\\] \\[\\begin{equation} \\label{eq37} I_5 = \\int_\\Gamma \\phi_i U_n^n d\\Gamma \\end{equation}\\] \\[\\begin{equation} \\label{eq38} I_6 = \\int_{\\overline{\\Gamma}_\\nu} \\phi_i U_n^{n+1} d\\overline{\\Gamma}_\\nu \\end{equation}\\] <p>Following standard finite-element procedures, and using appropriate essential and natural boundary conditions, SCHISM solves Eq. \\(\\ref{eq33}\\) to determine the elevations at all nodes. Note that the RHS terms \\(I_{3-6}\\) are known; in the case of \\(I_6\\), the integrals on \\(\\overline{\\Gamma}_\\nu\\) need not be evaluated since the essential boundary conditions are imposed by eliminating corresponding rows and columns of the matrix.</p> <p>The matrix resulting from Eq. \\(\\ref{eq33}\\) is sparse and symmetric. It is also positive-definite as long as the depth \\(\\breve{H}\\) is non-negative (<code>ihhat=1</code>); numerical experiments indicated that even this restriction can be relaxed for many practical applications that include shallow areas. We show that the addition of vegetation does not introduce additional stability constraint. The effects of the vegetation on \\(\\breve{H}\\) are generally similar to the bottom friction. For the 2D case, \\(\\breve{H}\\) is always positive. For the 3D emergent case, the vegetation term in the denominator is positive and so does not change the sign. For the 3D submerged case, as \\(\\alpha \\rightarrow 0\\), previous results of Zhang and Baptista (2008) are recovered. As \\(\\alpha \\rightarrow \\infty\\) (i.e., very dense vegetation), the friction term (the second term in Eq. \\(\\ref{eq27}\\)) dwarfs in comparison with the vegetation term (the third term in Eq. \\(\\ref{eq27}\\)), and therefore the friction is negligible under dense vegetation. Since \\(c \\rightarrow 1\\) as \\(\\alpha \\rightarrow \\infty\\), \\(\\breve{H}\\) approaches the submergence \\(H-H^\\alpha\\), which is positive. When the submergence is very small (i.e. almost emergent vegetation), \\(\\breve{H} \\rightarrow 0\\) and the conditioning of the matrix would somewhat deteriorate but the model remains stable. Physically, this means that very strong shear will develop near the canopy.</p> <p>It\u2019s important to notice that the friction-modified depth is different between 2D and 3D cases, which has implications in shallow depths. We show more details of the evaluation of the integrals \\(I_i\\) below. The corresponding constant for 2D prisms is always positive (see below) and therefore the 2D mode is inherently more stable than 3D mode; consequently, judiciously leveraging SCHISM\u2019s polyphorphism enhances stability near the wetting and drying interface. The matrix can be efficiently solved using a pre-conditioned Conjugate Gradient method (Casulli and Cattani 1994). This simple matrix solver is implemented in SCHISM; alternatively, the efficient parallel matrix solver PETSc can be used for large matrices.</p> <p>In the model, the decision on 2D/3D emergent/3D submerged scenarios is made at each side (where the velocity is defined) based on the total depths from the previous time step and the transition of regimes is handled in the model.</p>"},{"location":"schism/barotropic-solver.html#integral-i_3","title":"Integral \\(I_3\\)","text":"<p>This is a boundary integral that only need to be evaluated when the node \\(i\\) is located on an open boundary segment where Neuman-type B.C. is prescribed. Since the unknowns vary linearly along any side, we have (cf. Figure 1) -</p> \\[\\begin{equation} \\label{eq39} I_3 = \\sum_j \\frac{L_{ij}}{2} \\sum_{k=kbs}^{N_z-1} \\Delta z_{j,k+1} \\frac{\\hat{u}_{j,k+1}^{n+1} + \\hat{u}_{j,k}^{n+1}}{2} \\end{equation}\\] <p>where the outer sum is carried out along the 2 adjacent open side \\(j\\), \\(L_{ij}\\) is the side length, \\(\\Delta z_{j,k+1}\\) is the layer thickness along side \\(j\\), and \\(kbs\\) is the local bottom index.</p> <p></p> Boundary node i with adjacent sides. <p>If a Flather-type radiation condition (Flather 1987) needs to be applied, it can be done in the following fashion - </p> \\[\\begin{equation} \\label{eq40} \\hat{U}_n^{n+1} - \\overline{U}_n = \\sqrt{\\frac{g}{H}} (\\eta^{n+1} - \\overline{\\eta}) \\end{equation}\\] <p>where \\(\\overline{U}_n\\) and \\(\\overline{\\eta}\\) are specified mean incoming current and mean elevation. Then - </p> \\[\\begin{equation} \\label{eq41} I_3 = \\sum_j \\frac{L_{ij}(\\overline{U}_n)_{ij}}{2} + \\frac{L_{ij}\\sqrt{gH_{ij}}}{6} \\left[ 2(\\eta_i^{n+1} - \\overline{\\eta}_i) + (\\eta_j^{n+1} - \\overline{\\eta}_j) \\right] \\end{equation}\\] <p>In this case, the unknown \\(\\eta^{n+1}\\) need to be moved to the LHS, and the diagonal (associated with \\(\\eta_i^{n+1}\\)) is enhanced as a result and matrix symmetry is preserved.</p>"},{"location":"schism/barotropic-solver.html#integral-i_5","title":"Integral \\(I_5\\)","text":"<p>Similar to \\(I_3\\), we have - </p> \\[\\begin{equation} \\label{eq42} I_5 = \\sum_j \\frac{L_{ij}}{2} \\sum_{k=kbs}^{N_z-1} \\Delta z_{j, k+1} \\frac{u_{j, k+1}^{n} + u_{j,k}^{n}}{2} \\end{equation}\\]"},{"location":"schism/barotropic-solver.html#integral-i_1","title":"Integral \\(I_1\\)","text":"<p>This is the only implicit term. Referring to Figure 2, we have - </p> \\[\\begin{equation} \\label{eq43} I_1 = \\sum_{j=1}^{Nb(i)} \\sum_{l=1}^{i34(j)} \\eta_{j,l}^{n+1} \\int_{A_j} \\hat{\\phi_{i'}} \\hat{\\phi_l} dA_j + g\\theta^2 \\Delta t^2 \\sum_{j=1}^{Nb(i)} \\overline{\\check{H}_j} \\sum_{l=1}^{i34(j)} \\eta_{j,l}^{n+1} \\int_{A_j} \\nabla\\hat{\\phi_{i'}}\\cdot\\nabla\\hat{\\phi_l} dA_j \\end{equation}\\] <p>Where \\(j\\) is a neighbouring element of \\(i\\), \\(i'\\) is the local index of node \\(i\\) inside element \\(j\\), overbar in \\(\\overline{\\check{H}}\\) denotes element averating, and \\(\\hat{\\phi}\\) is the local linear shape function. We discuss the case of a triangle and quad element.</p> <p></p> Node ball used in calculating integral I 1."},{"location":"schism/barotropic-solver.html#case-i-triangle","title":"Case I: triangle","text":"<p>The 2 integrals can be evaluated analytically as - </p> \\[\\begin{equation} \\label{eq44} \\int_{A_j} \\hat{\\phi_{i'}} \\hat{\\phi_l} dA_j = \\frac{1+\\delta_{i',l}}{12}A_j \\end{equation}\\] \\[\\begin{equation} \\label{eq45} \\int_{A_j} \\nabla\\hat{\\phi_{i'}} \\cdot \\nabla\\hat{\\phi_l} dA_j = \\frac{\\vec{i'}\\cdot\\vec{l}}{4A_j} \\end{equation}\\] <p>where \\(\\vec{i'}\\) and \\(\\vec{l}\\) are two vectors along side \\(i'\\) and \\(l\\) respectively, and \\(\\delta_{i',l}\\) is the Kronecker delta - </p> \\[\\begin{equation*} \\delta_{i',l} = \\begin{cases} 1, i' = l \\\\ 0, i' \\neq l \\end{cases} \\end{equation*}\\]"},{"location":"schism/barotropic-solver.html#case-ii-quad","title":"Case II: Quad","text":"<p>We can analytically evaluate integral Eq. \\(\\ref{eq44}\\) as - </p> \\[\\begin{equation} \\label{eq46} \\int_{A_j} \\hat{\\phi_{i'}}\\hat{\\phi_l}dA_j = \\frac{A_j}{16}\\left(1+\\frac{1}{3}\\xi_{i'}\\xi_l\\right)\\left(1+\\frac{1}{3}\\varsigma_{i'}\\varsigma_l\\right) + \\frac{B_1}{96}\\left(1+\\frac{1}{3}\\varsigma_{i'}\\varsigma_l\\right)\\left(\\xi_{i'}+\\xi_l\\right) + \\frac{B_2}{96}\\left(1+\\frac{1}{3}\\xi_{i'}\\xi_l\\right)\\left(\\varsigma_{i'}+\\varsigma_l\\right) \\end{equation}\\] <p>Where \\((\\xi, \\varsigma)\\) are local coordinates, and \\(B_1\\) and \\(B_2\\) are 2 geometric constants (Figure 3) - </p> \\[\\begin{equation} \\label{eq47} \\begin{aligned} B_1 = \\left(\\vec{12}\\times\\vec{43}\\right)_k = \\left(x_2-x_1\\right)\\left(y_3-y_4\\right) - \\left(x_3-x_4\\right)\\left(y_2-y_1\\right)\\\\ B_2 = \\left(\\vec{23}\\times\\vec{14}\\right)_k \\end{aligned} \\end{equation}\\] <p></p> Quad element and local transformation. <p>The other integral Eq. \\(\\ref{eq45}\\) cannot be evaluated analytically and so we use the 4-point Gauss quadrature.</p>"},{"location":"schism/barotropic-solver.html#integral-i_4","title":"Integral \\(I_4\\)","text":"<p>This integral contains most of the explicit terms. Most terms are straightforward to evaluate, e.g., using element averaging or analytical integration (in the case of volume sources/sinks); the integrals involving the shape function or its derivative can be calculated using the similar method as in \\(I_1\\). Therefore we will only discuss the a few terms below given their importance in SCHISM.</p>"},{"location":"schism/barotropic-solver.html#baroclinicity","title":"Baroclinicity","text":"<p>Since a FVM is used to solve the tracers (including T,S) at the prism center, we evaluate the density gradient at prism center via a reconstruction method. Referring to Figure 4, given a prism center '0', we first project the gradient onto vectors connecting adjacent prism centers - </p> \\[\\begin{equation} \\label{eq48} \\frac{\\partial\\rho}{\\partial x}\\left(x_1-x_0\\right) + \\frac{\\partial\\rho}{\\partial y}\\left(y_1-y_0\\right) = \\rho_1-\\rho_0 \\end{equation}\\] \\[\\begin{equation} \\label{eq49} \\frac{\\partial\\rho}{\\partial x}\\left(x_2-x_0\\right) + \\frac{\\partial\\rho}{\\partial y}\\left(y_2-y_0\\right) = \\rho_2-\\rho_0 \\end{equation}\\] \\[\\begin{equation} \\label{eq50} \\frac{\\partial\\rho}{\\partial x}\\left(x_3-x_0\\right) + \\frac{\\partial\\rho}{\\partial y}\\left(y_3-y_0\\right) = \\rho_3-\\rho_0 \\end{equation}\\] <p>after a cubic spline interpolation has been performed to calculate the density at prism '1' at the same vertical location as \u20180\u2019 (i.e. (\\(i\\),\\(k\\))). Note that if the element \\(i\\) is a quad, we will have 4 equations. We then solve pairs of equations to find for \\(\\nabla\\rho\\), i.e., Eq. \\(\\ref{eq48}\\) with Eq. \\(\\ref{eq49}\\), Eq. \\(\\ref{eq49}\\) with Eq. \\(\\ref{eq50}\\), and Eq. \\(\\ref{eq50}\\) with Eq. \\(\\ref{eq48}\\). If the 3 centers happen to be co-linear, the equations have no solution and are discarded; however, at least 1 pair has a valid solution. </p> <p></p> Reconstruction method. i is the element index and k is the vertical index. <p>If a neighbor does not exist (boundary) or is dry, we replace the corresponding equation with the no-flux B.C.; e.g., if AB is such a side, then -</p> \\[\\begin{equation} \\label{eq51} \\frac{\\partial\\rho}{\\partial y}\\left(x_A-x_B\\right) + \\frac{\\partial\\rho}{\\partial x}\\left(y_B-y_A\\right) = 0 \\end{equation}\\] <p>After the density gradients are found at prism centers, a simple linear interpolation in the vertical is used to calculate the gradients at side centers (and half levels). Then the trapezoidal rule is used to compute the baroclinic term: \\(-\\frac{g}{\\rho_0}\\int_z^\\eta\\nabla\\rho dz\\). This will also be utilized in the solution of the momentum equation.</p>"},{"location":"schism/barotropic-solver.html#horizontal-viscosity","title":"Horizontal viscosity","text":"<p>Momentum stabilization is an important consideration in designing advection and viscosity schemes. Zhang et al. (2016) demonstrated that the standard Laplacian viscosity is equivalent to the 5-point Shapiro filter (see below) on uniform grids; however, on non-uniform grids, it may behave like an \u2018amplifier\u2019 and therefore the filter form should be used instead (Figure 5a,b) - </p> \\[\\begin{equation} \\label{eq52} \\nabla\\cdot\\left(\\mu\\nabla u\\right)\\Biggr|_0 = \\frac{\\mu_0}{\\sqrt{3}A_I}\\left(u_1+u_2+u_3+u_4-4u_0\\right) \\end{equation}\\] <p>where all velocities have been interpolated onto a horizontal plane using linear interpolation in the vertical. </p> <p></p> Shapiro filters and viscosity stencil for (a) triangular and (b) quadrangular elements. 'I' and 'II' are 2 adjacent elements of side of interest ('0'). The extended stencil used in constructing bi-harmonic viscosity is shown in (c). The special case of a boundary side is shown in (d). <p>The bi-harmonic viscosity is often superior to the Laplacian viscosity as it is more discriminating in removing sub-grid instabilities without adversely affecting the resolved scales of flow (Griffies and Hallberg 2000). The bi-harmonic viscosity can be implemented by applying the Laplacian operator twice. Referring to Figure 5c, we have - </p> \\[\\begin{equation} \\label{eq53} \\begin{aligned} -\\lambda\\nabla^4u\\Biggr|_0  &amp;= -\\lambda\\gamma_3\\left( \\nabla^2 u_1 + \\nabla^2 u_2 + \\nabla^2 u_3 + \\nabla^2 u_4 - 4\\nabla^2 u_0 \\right)\\\\ &amp;= \\frac{\\gamma_2}{\\Delta t}\\left[ 7\\left( u_1 + u_2 + u_3 + u_4\\right) - u_{1a} - u_{1b} - u_{2a} - u_{2b} - u_{3a} - u_{3b} - u_{4a} - u_{4b} - 20u_0 \\right] \\end{aligned} \\end{equation}\\] <p>where \\(\\lambda\\)  is a hyper viscosity in \\(m^4/s\\), \\(\\gamma_3 = \\frac{1}{\\sqrt{3}A_I}\\) and \\(\\gamma_2 = \\lambda\\gamma_3^2\\Delta t\\) is a diffusion-number-like dimensionless constant. We found that in practice \\(\\gamma_2 \\leq 0.025\\)  is sufficient to suppress inertial spurious modes.</p> <p>References</p> <p>Casulli, V. and E. Cattani (1994) Stability, accuracy and efficiency of a semi-implicit method for 3D shallow water flow. Computers &amp; Mathematics with Applications, 27, pp. 99-112.</p> <p>Flather, R.A. (1987) A tidal model of Northeast Pacific. Atmosphere-Ocean, 25, pp. 22-45.</p> <p>Zhang, Y. and Baptista, A.M. (2008) \"SELFE: A semi-implicit Eulerian-Lagrangian finite-element model for cross-scale ocean circulation\", Ocean Modelling, 21(3-4), 71-96</p> <p>Zhang, Y., Ye, F., Stanev, E.V., Grashorn, S. (2016). Seamless cross-scale modeling with SCHISM, Ocean Modelling, 102, 64-81. doi:10.1016/j.ocemod.2016.05.002</p>"},{"location":"schism/eulerian-lagrangian-method.html","title":"Eulerian-Lagrangian Method","text":"<p>The default option for the momentum advection in SCHISM is ELM, which is one of few explicit methods that are unconditionally stable. Under this method, the momentum advection is approximated as -</p> \\[\\begin{equation} \\label{eq01} \\frac{D\\pmb{u}}{Dt}\\cong\\frac{\\pmb{u}(\\pmb{x}, t^{n+1}) - \\pmb{u}(\\pmb{x}^*, t^n)}{\\Delta t} \\end{equation}\\] <p>where \\(\\pmb{x}\\) is a shorthand for \\((x, y, z)\\), and \\(\\pmb{x}^*\\) is the location of the foot of characteristic line (FOCL), calculated from the characteristic equation - </p> \\[\\begin{equation} \\label{eq02} \\frac{D\\pmb{x}}{Dt} = \\pmb{u} \\end{equation}\\] <p>The location \\(\\pmb{x}^*\\) is found via a backtracking step, standard in an ELM, via backward integration of Eq. \\(\\ref{eq02}\\) starting from a given location (\\(\\pmb{x}\\)), which is in our case a side center at whole level where the horizontal velocity \\(\\pmb{u}\\) is defined. The fixed starting location (Eulerian framework) followed by a Lagrangian tracking step gives the name Eulerian-Lagrangian method. Therefore the ELM consists of two major steps: a backtracking step (Figure 1a) and an interpolation step at FOCL (Figure 1b). We further sub-divide the tracking step into smaller intervals (based on local flow gradients), and use a 2nd-order Runge-Kutta method (mid-point method) within each interval, in order to accurately track the trajectory. Although exact integration methods have been proposed (Ham et al. 2006), their implementation is complicated for a 3D (triangular and quadrangular) prism and in the exceptional cases of wetting and drying interfaces. The interpolation step serves as an important control for numerical diffusion/dispersion in the ELM, and we therefore experimented with several options as shown below. However, before we get to this, we first explain how SCHISM converts the velocities at sides to the velocities at nodes, as the latter are required in the interpolation of the velocities along the characteristic line and at the FOCL (Figure 1).</p> <p></p> Two steps in Eulerian\u2013Lagrangian method. (a) The characteristic equation is integrated backward in space and time, starting from a side center (the green dot). The characteristic line is further subdivided into smaller intervals (bounded by the red dots), based on local flow gradients, and a 2nd-order Runge\u2013Kutta method is used within each interval. The foot of characteristic line is marked as a yellow dot. Note that the vertical position of the trajectory is also changing and so the tracking is in 3D space. (b) Interpolation is carried out at FOCL (yellow dot), based on either the nodes of the containing elements (blue dots), or the 2-tier neighborhood (blue plus red dots; the latter are the neighbors of the blue dots) using a dual kriging method. Proper linear vertical interpolation has been carried out first to bring the values at each node onto a horizontal plane before the horizontal interpolation is done. <p>As explained by Danilov (2013), the conversion method used bears important ramifications: judicious averaging (e.g., from side to elements or to node etc.) may greatly reduce the need later on for filters to remove the inertial spurious modes while still keeping the inherent numerical dissipation low. In fact, one could have used the discontinuous velocity calculated within each element to carry out the backtracking, but this would introduce insufficient amount of dissipation to suppress the inertial modes.</p> <p>In the first approach (\u2018MA\u2019 hereafter; <code>indvel=1</code>), we use inverse distance weights to interpolate from velocities at surrounding sides onto a node (Figure 2a). This introduces diffusion which may be excessive in our experience, and therefore no further stabilization (via filters or viscosity) is required for this approach (see the discussion of stabilization in Danilov 2013). This approach works well in shallow waters especially for the inundation process, as numerical stability often trumps the order of accuracy there. </p> <p></p> Two methods of converting side velocities to a node velocity. (a) Inverse distance interpolation from sides (blue dots) to node (yellow dot); (b) use of FEM shape function to find the node velocity within each element first (the red arrow), i.e. u1 = uII + uIII \u2013uI , followed by a simple averaging method to calculate the final value from all of its surrounding elements (dashed arrows) <p>The 2nd approach (\u2018MB\u2019 hereafter; <code>indvel=0</code>) is more elegant and utilizes the (linear) shape function in FEM within each element to calculate the node velocities. This is equivalent to using the \\(P^{NC}\\) non-conformal shape function (Le Roux et al. 2005) as one essentially interpolates based on information at sides (Figure 2b). Because each element produces a velocity vector at each of its nodes, the final node velocity is the simple average of the values calculated from all of the surrounding elements (Figure 2a). This approach introduces much less dissipation, but does exhibit inertial spurious modes. As a result, further stabilization is required. To this end, SCHISM uses a 5-point Shapiro filter (Shapiro 1970) as illustrated in Figure 5ab; the velocity at a side \u20180\u2019 is filtered as -</p> \\[\\begin{equation} \\label{eq03} \\tilde{\\pmb{u}_0} = \\pmb{u}_0 + \\frac{\\gamma}{4}\\left( \\pmb{u}_1 + \\pmb{u}_2 + \\pmb{u}_3 + \\pmb{u}_4 -4\\pmb{u}_0 \\right) \\end{equation}\\] <p>with the strength usually set as \\(\\gamma = 0.5\\).  It\u2019s obvious that the filter is analogous to the Laplacian viscosity implementation in the previous section. It proves to be very effective in removing the sub-grid scale inertial spurious modes; however, it tends introduces too much dissipation in the eddying regime, and therefore should be used only in the non-eddying regime, i.e. shallow waters. Since it\u2019s equivalent to the Laplacian viscosity, we may remove this filter in the future options and ask users to use <code>ihorcon=1</code> instead.</p> <p>Once the node velocities are found via MA or MB, the interpolation at the FOCL is carried out in 3D space. A simple linear interpolation is used in the vertical dimension as the results from the cubic-spline interpolation turned out to be similar, due to more confined spatial scales and smaller grid sizes in the vertical. The horizontal interpolation can be done using either a simple linear shape function based on all of the nodes of the containing element (\u2018LI\u2019 hereafter), or a higher-order dual kriging method (\u2018KR\u2019 hereafter) suggested by Le Roux et al. (1997) Figure 5b The latter requires larger stencil around the FOCL, and for best parallel efficiency we use a 2-tier neighborhood as shown in Figure 5b. Given a total of N nodes available in the 2-tier neighborhood, the interpolation function is constructed as (Le Roux 1997) - </p> \\[\\begin{equation} \\label{eq04} f^h(x,y) = (\\alpha_1 + \\alpha_2 x + \\alpha_3 y) + \\sum_{i=1}^N \\beta_i K(r_i) \\end{equation}\\] <p>where the first 3 RHS terms inside the parentheses represent a mean drift (modeled as a linear function), and the 2nd term is the fluctuation part, \\(\\alpha_j\\), \\(\\beta_i\\) are unknown coefficients, and \\(r_i\\) is the distance between (\\(x\\),\\(y\\)) and (\\(x_i\\),\\(y_i\\)), with \\(i\\) being a node. The following forms of the generalized covariance function are commonly used (Le Roux et al. 1997) - </p> \\[\\begin{equation} \\label{eq05} K(r) = -r, r^2\\log(r), r^3, -r^5, r^7 \\end{equation}\\] <p>with increasing dispersion for the higher-degree functions; therefore in practice, the last two functions are seldom used. In the following we will refer to the first 3 functions as \u2018KR1\u2019, \u2018KR2\u2019 and \u2018KR3\u2019 respectively.</p> <p>The equations to solve for the unknown coefficients are - </p> \\[\\begin{equation} \\label{eq06} \\begin{aligned} f^h(x_i, y_i) = d_i, 1 \\leq i \\leq N\\\\ \\sum_{i=1}^{N} \\beta_i = 0\\\\ \\sum_{i=1}^{N} x_i\\beta_i = 0\\\\ \\sum_{i=1}^{N} y_i\\beta_i = 0 \\end{aligned} \\end{equation}\\] <p>where \\(d_i\\) are given data at each node. The 1st equation in Eqs. \\(\\ref{eq06}\\)  indicates that the dual kriging is an exact interpolator, and the other 3 equations are derived from minimization of the variance of estimation error (Le Roux et al. 1997). Note that the matrix of Eqs. \\(\\ref{eq06}\\) is dependent only on geometry and therefore can be inverted and stored before the time stepping loop to achieve greater efficiency. After the coefficients are found, the interpolation at FOCL is done via Eqs. \\(\\ref{eq04}\\).</p> <p>The smaller stencil used here compared to that used by Le Roux et al. (1997) leads to larger numerical dispersion. Therefore an effective method must be found to control the dispersion, and we use the ELAD scheme of Shchepetkin and McWilliams (1998) for this purpose. The essence of ELAD is to iteratively diffuse the excess field, instead of the original signal, using a diffusion operator/smoother. The viscosity scheme presented in the previous sub-section is used as the diffusion operator. The procedure is summarized as follows - </p> <ol> <li> <p>Find the local max/min at FOCL. Assuming that the prism at FOCL starting from a side \\(j\\) and level \\(k\\) is (\\(kf\\),\\(nf\\)), where \\(nf\\) is the element index and \\(kf\\) is the vertical index, the max/min are found in the prism (\\(kf\\),\\(nf\\)) as -</p> \\[\\begin{equation} \\label{eq07} \\begin{aligned} u_{k, j}^{max} = \\max_{l=1:i34, k=-1,0} u_{kf+k, im(l, nf)}\\\\ u_{k, j}^{min} = \\min_{l=1:i34, k=-1,0} u_{kf+k, im(l, nf)} \\end{aligned} \\end{equation}\\] <p>where \\(im()\\) enumerates all nodes of an element.</p> </li> <li> <p>The excess field associated with (k,j) is - </p> \\[\\begin{equation} \\label{eq08} \\varepsilon_{k, j}^{(1)} = \\max\\left[ 0, u_{k,j}^{n+1, 1} - u_{k,j}^{\\max} \\right] + \\min\\left[ 0, u_{k,j}^{n+1, 1} - u_{k,j}^{\\min} \\right] \\end{equation}\\] <p>where \\(u_{k,j}^{n+1, 1}\\) is the interpolated value at FOCL.</p> </li> <li> <p>Apply a global diffusion operator to \\(\\varepsilon\\) to obtain estimated velocity at the next iteration - </p> \\[\\begin{equation} \\label{eq09} u_{k,j}^{n+1, 2} = u_{k, j}^{n+1, 1} + \\mu'\\Delta t \\nabla^2 \\varepsilon_{k, j}^{(1)}, \\forall j, k \\end{equation}\\] <p>and we use 5-point filter with maximum strength - </p> \\[\\begin{equation} \\label{eq10} u_{k,j}^{n+1, 2} = u_{k, j}^{n+1, 1} + \\frac{1}{8} \\left[ \\varepsilon_{k, 1}^{(1)} + \\varepsilon_{k, 2}^{(1)} + \\varepsilon_{k, 3}^{(1)} + \\varepsilon_{k, 4}^{(1)} - 4 \\varepsilon_{k, j}^{(1)} \\right] \\end{equation}\\] <p>where subscripts 1-4 are the 4 adjacent sides of \\(j\\) (Figure 5ab);</p> </li> <li> <p>Calculate the new excess field using \\(u_{k, j}^{n+1, 2}\\) in (2) and apply the filter (3) again to find the velocity at the next iteration \\(u_{k,j}^{n+1, 3}\\). Iterate until the excess field falls below a prescribed threshold. In practice, 10 iterations are usually sufficient to bring the excess field below an acceptable level (\\(10^{-4} m/s\\)); the remaining excess field is then further smoothed with the viscosity.</p> </li> </ol> <p>The filter in Eqs. \\(\\ref{eq10}\\) is conservative in the sense that it only redistributes excess mass and does not introduce any additional mass. This is similar in spirit to the conservative scheme of Gravel and Staniforth (1994) but appears simpler in implementation. At a boundary side \\(j\\), Eqs. \\(\\ref{eq10}\\) is modified in order to maintain the conservation - </p> \\[\\begin{equation} \\label{eq11} u_{k,j}^{n+1, 2} = u_{k, j}^{n+1, 1} + \\frac{1}{8} \\left[ \\varepsilon_{k, 1}^{(1)} + \\varepsilon_{k, 2}^{(1)} - 2 \\varepsilon_{k, j}^{(1)} \\right] \\end{equation}\\] <p>where subscripts '1' and '2' are the 2 adjacent sides of \\(j\\) (Figure 5d). Note that since the linear interpolation scheme (LI) does not introduce local extrema, ELAD is not applied there.</p> <p>The various schemes presented above can be freely combined, resulting in schemes like \u2018MA-LI\u2019, \u2018MB-KR2\u2019 etc. Experiments indicate that overall the best scheme is MB-LI for both eddying and non-eddying regimes (Zhang et al. 2016).</p> <p>References</p> <p>Danilov, D. (2013) Ocean modeling on unstructured meshes, Ocean Mod., 69, 195-210.</p> <p>Gravel, S. and A. Staniforth (1994), A mass-conserving semi-Lagrangian scheme for the shallow-water equations, Mon. Wea. Rev., 122, 243-248.</p> <p>Ham, D.A., Pietrzak, J., and G.S. Stelling (2006), A streamline tracking algorithm for semi-Lagrangian advection schemes based on the analytic integration of the velocity field, Journal of Computational and Applied Mathematics 192, 168\u2013174.</p> <p>Le Roux, D.Y., Lin, C.A., Staniforth, A. (1997), An accurate interpolating scheme for semi-Lagrangian advection on an unstructured mesh for ocean modelling, Tellus, 49A, 119\u2013138.</p> <p>Le Roux, D.Y., S\u00e8ne, A., Rostand, V., and E. Hanert (2005), On some spurious mode issues in shallow-water models using a linear algebra approach. Ocean Modelling 10, 83\u201394.</p> <p>Shapiro, R. (1970), Smoothing, filtering and boundary effects, Rev. Geophys. Space Phys. 8 (2), 359\u2013387.</p> <p>Shchepetkin, A.F. and J.C. Mcwilliams (1998), Quasi-Monotone Advection Schemes Based on Explicit Locally Adaptive Dissipation , Monthly Weather Review, 126, 1541-80.</p> <p>Zhang, Y., Ye, F., Stanev, E.V., Grashorn, S. (2016). Seamless cross-scale modeling with SCHISM, Ocean Modelling, 102, 64-81. doi:10.1016/j.ocemod.2016.05.002</p>"},{"location":"schism/geometry-discretization.html","title":"Geometry and discretization","text":"<p>As a FE model, SCHISM uses flexible UG in the horizontal and flexible vertical coordinate systems in the vertical dimension. </p>"},{"location":"schism/geometry-discretization.html#horizontal-grid","title":"Horizontal grid","text":"<p>Hybrid triangular-quad elements are used in the horizontal, to take advantage of the superior boundary-fitting capability of triangles and efficiency/accuracy of quads in representing certain features like channels. Figure 1 shows an example of horizontal grid.</p> <p></p> Example horizontal grid (hgrid.gr3) of SCHISM. <p>Figure 2 shows our convention of numbering local nodes/sides etc.</p> <p></p> Horizontal element convention. Local indices of nodes/sides for (a) triangular element, and (b) quad element. (c) Adjacent elements of an element (following side convention). (d,e): Local ball info (surrounding elements/nodes of node i) for (d) internal and (e) boundary node i. (f) shows a local side center-based frame used to calculate the normal fluxes; the (global) element number of \u201c1\u201d is smaller than \u201c2\u201d, and xs axis always points out of \u201c1\u201d. We follow counter-clockwise convention/right-hand rule."},{"location":"schism/geometry-discretization.html#vertical-grid","title":"Vertical grid","text":""},{"location":"schism/geometry-discretization.html#hybrid-sz-grid","title":"Hybrid SZ grid","text":"<p>The 1st type uses a hybrid S (terrain-following generalized s-coordinates; Song and Haidvogel 1994) and shaved z coordinates, with the latter always being placed underneath the former at a prescribed demarcation depth \\(h_s\\). Note that the use of shaved z layers is optional and the users can use a pure \\(S\\) grid with a choice of \\(h_s\\) greater than the maximum depths in the grid. Figure 3 shows a \\(SZ\\) grid.</p> <p></p>  Example of SZ grid. (a) Vertical coordinate systems (thick line is the bottom); (b) side view of a vertical transect resulted from SZ grid; the red cells are irregular/shaved cells. <p>The transformation from \\(S\\) to \\(Z\\) is given by - </p> \\[\\begin{equation} \\begin{aligned} z=\\eta(1+\\sigma) + h_x \\sigma + (\\tilde{h} - h_c)C(\\sigma), \\text{where} (-1 \\leq \\sigma \\leq 0)\\\\ \\\\ C(\\sigma) = (1-\\theta_b) \\frac{sinh(\\theta_f \\sigma)}{sinh \\theta_f} + \\theta_b \\frac{tanh \\left[ \\theta_f (\\sigma + 1/2) \\right] - tanh(\\theta_f/2)}{2 tanh (\\theta_f /2)}, \\text{given} ( 0 \\leq \\theta_b \\leq 1; 0 \\lt \\theta_f \\leq 20) \\end{aligned} \\end{equation}\\] <p>where \\(\\tilde{h} = min(h, h_s)\\) is a \u201crestricted\u201d depth, \\(h_c\\) is a positive constant dictating the thickness of the bottom or surface layer that needs to be resolved, and \\(\\theta_b\\) and \\(\\theta_f\\) are constants that control the vertical resolution near the bottom and surface. As \\(\\theta_f \\rightarrow 0\\), the \\(S\\) coordinates reduce to the traditional \\(\\sigma\\)-coordinates:</p> \\[\\begin{equation} z=\\tilde{H} \\sigma + \\eta \\end{equation}\\] <p>Where \\(\\tilde{H} = \\tilde{h} + \\eta\\) is the restricted total water depth. For \\(\\theta_f \\gg 1\\), more resolution is skewed towards the boundaries, and the transformation becomes more nonlinear. If \\(\\theta_b \\rightarrow 0\\), only the surface is resolved, not the bottom, while if \\(\\theta_b \\rightarrow 1\\), both are resolved (Figure 4).</p> <p></p>  Examples of S transformation. <p>For typical coastal applications, we suggest \\(\\theta_b = 0\\). Unfortunately, the \\(S\\) coordinate becomes invalid in shallow depth \\(\\tilde{h} \\lt h_c\\); under such circumstance, the traditional \\(\\sigma\\) coordinates (Equation 2) are used.</p>"},{"location":"schism/geometry-discretization.html#lsc2-grid","title":"\\(LSC^2\\) grid","text":"<p>The 2nd type of vertical coordinate uses localized \\(\\sigma\\) Each grid node has its own vertical grid with a set of \\(\\sigma\\) coordinates for maximum flexibility; the mismatch of # of vertical levels between adjacent nodes is treated with shaved cells near the bottom, thus the name Localized Sigma Coordinates with Shaved Cells (\\(LSC^2\\)).</p> <p>Although there are many ways of generating a \\(LSC^2\\) grid, a convenient start is the Vanishing Quasi Sigma (VQS) suggested by Dukhovskoy et al. (2009). The essence of VQS is to first design a master (vertical) grid at selected reference depths, and then use this master grid to interpolate the local z coordinates at a grid node based on the local depth and 2 references depths that contains the depth (Figure 5). The original VQS also requires masking of thin layers near the bottom, and is not free of Z-like staircases near the bottom (Figure 5d). Since SCHISM is an implicit model, we do not need such special treatment, and furthermore, \u2018fill in\u2019 unmatched levels with shaved cells to get \\(LSC^2\\). As can be seen from Figure 5, a major advantage of \\(LSC^2\\), besides being very economical (as fewer/more # of levels are used in shallow/deep), is that it resembles a Z grid near the surface and interior of the water column while behaving like terrain-following grid near the bottom. As demonstrated in Zhang et al. (2015, 2016ab), \\(LSC^2\\) is instrumental in reducing unphysical diapycnal mixing and pressure-gradient errors (PGE). A well-designed \\(LSC^2\\) grid completely removes the need for bathymetry manipulation (e.g. smoothing/clipping), thus enabling a faithful representation of the bathymetry/topography, as demonstrated in those papers. However, some experience is required in designing a good \\(LSC^2\\) grid, and so beginners may want to start with the \\(SZ\\) grid.</p> <p></p> $LSC^2$ grid. (a) Horizontal grid showing the location of the transect (yellow line); (b) master grid at 19 reference depths; (c) corresponding vertical grid of the transect in (a), with degenerate prisms/shaved cells located near the bottom. (d) shows a typical VQS grid that contains staircases near the bottom."},{"location":"schism/geometry-discretization.html#prisms","title":"Prisms","text":"<p>Regardless which type of vgrid is chosen, the basic 3D computational unit in SCHISM is a triangular or quad prism, with 3 or 4 vertical faces and uneven top and bottom faces (Figure 6). SCHISM solves all equations in the original Z space for consistency; even with spherical coordinates (lon/lat), the equations are not transformed but instead multiple coordinate frames are used (see below). A staggering scheme a la Arakawa-CD grid is used to define variables. The surface elevations are defined at the nodes. The horizontal velocities are defined at the side centers and whole levels. The vertical velocities are defined at the element centers and whole levels, and the tracer concentration is defined at prism center, as they are solved with a finite-volume method. The linear shape functions are used for elevations and velocities (the latter has a vertical linear shape function as well). For quad elements, the bi-linear shape function is used.</p> <p></p> Basic 3D computational unit in SCHISM where variables are staggered. <p>At the end of each time step, the vertical levels are updated to account for free-surface movement. Although method like Arbitrary Lagrangian Eulerian (ALE) can be used to march the vertical levels in time, this is not done at the moment. Therefore, the state variables are simply moved to the new vertical location without re-interpolation.</p> <p>In the model sometimes vertical interpolation is required (e.g., calculation of baroclinc force). We use cubic spline interpolation in the vertical to minimize diffusion.</p>"},{"location":"schism/geometry-discretization.html#polymorphism","title":"Polymorphism","text":"<p>The combination of \\(LSC^2\\) vertical grid (Zhang et al. 2015) and horizontal mixed-element grids results in an extremely flexible grid system that has great practical applications. We demonstrate this with a toy problem for coastal ocean-estuary-river system depicted in Figure 7. Since the tracer concentrations are defined at the prism centers, a row of quads and 1 vertical layer resembles a 1D model (Figure 7c). Similarly, a row of quads with multiple vertical layers leads to 2DV configuration (Figure 7c). Some parts of the shoals that are sufficiently shallow are discretized using 1 vertical layer (Figure 7b), which is a 2DH configuration. The deeper part of the domain is discretized using full 3D prisms, but with a larger number of layers in the deeper depths than in the shallow depths, in a typical \\(LSC^2\\) fashion (Figure 7a; Zhang et al. 2015). Different types of grids are seamlessly welded into a single SCHISM grid, resulting in greatest efficiency. With some care taken of the consistent bottom friction formulations across 1D, 2D and 3D, the model results show no discontinuity across different types of grids. The use of 1D or 2D cells in shallow areas also enhances numerical stability, as they are well suited and more stable for inundation process than 3D cells; e.g., the crowding of multiple 3D layers in the shallow depths is not conducive to stability.</p> <p></p> Model polymorphism illustrated with a toy problem. The mixed triangular-quadrangular grid and the bathymetry are shown in the foreground. The vertical transect grid along the redline going from deep ocean into estuary (\u2018shipping channel\u2019) is shown in insert (a). The 3D view of the grid near the head of estuary is shown in insert (b), with few layers on the shallow shoals. The grid near the upstream river is shown in insert (c), where transition from 2DV to 1D grid can be seen. In the test, a M2 tide is applied at the ocean boundary, and fresh water discharges are imposed at the heads of the river and estuary. <p>References</p> <p>Zhang, Y., Ateljevich, E., Yu, H-C., Wu, C-H., and Yu, J.C.S. (2015) A new vertical coordinate system for a 3D unstructured-grid model, Ocean Modelling, 85, 16-31.</p>"},{"location":"schism/momentum-equation.html","title":"Momentum equation","text":"<p>After the elevations are found, SCHISM solves the momentum Eqs. 1  along each vertical column at side centers. A semi-implicit Galerkin finite-element method is used, with the barotropic pressure gradient and the vertical viscosity terms being treated implicitly, and other terms treated explicitly. For 3D cells, we have - </p> \\[\\begin{equation} \\label{eq01} \\int_{\\delta_b-h}^{\\eta} \\psi_l \\left[ \\pmb{u}^{n+1} - \\Delta t \\frac{\\partial}{\\partial z} \\left( \\nu \\frac{\\partial \\pmb{u}^{n+1}}{\\partial z} \\right) \\right] dz = \\int_{\\delta_b - h}^{\\eta} \\pmb{g} \\psi_l dz , (l = kbs + 1, \\cdots, N_z) \\end{equation}\\] <p>where \\(\\psi\\) is the hat function in the vertical dimension, \\(\\delta_b\\) is the bottom cell thickness, and </p> \\[\\begin{equation} \\label{eq02} \\pmb{g} = \\pmb{u}^* + \\Delta t \\left[ \\pmb{f} - g\\theta\\nabla\\eta^{n+1} - g(1-\\theta)\\nabla\\eta^n \\right] \\end{equation}\\] <p>The two terms that are treated implicitly would have imposed the most severe stability constraints if treated explicitly. The explicit treatment of the baroclinic pressure gradient and the horizontal viscosity terms, however, does impose mild stability constraints.</p> <p>The final FEM equations are - </p> \\[\\begin{equation} \\label{eq03} \\begin{aligned} \\frac{\\Delta z_{l+1}}{6} \\left( 2 \\pmb{u}_{l}^{n+1} + \\pmb{u}_{l+1}^{n+1} \\right) + \\frac{\\Delta z_l}{6} \\left( 2 \\pmb{u}_l^{n+1} + \\pmb{u}_{l-1}^{n+1} \\right) - \\nu_{l+1/2} \\Delta t \\frac{\\pmb{u}_{l+1}^{n+1} - \\pmb{u}_l^{n+1}}{\\Delta z_{l+1}} + \\nu_{l-1/2} \\Delta t \\frac{\\pmb{u}_l^{n+1} - \\pmb{u}_{l-1}^{n+1}}{\\Delta z_l} &amp;= \\frac{\\Delta z_{l+1}}{6} \\left( 2 \\pmb{g}_l + \\pmb{g}_{l+1} \\right) + \\frac{\\Delta z_l}{6} \\left( 2\\pmb{g}_l + \\pmb{g}_{l-1} \\right), (l = kbs + 2, \\cdots, N_z - 1)\\\\ \\frac{\\Delta z_{l+1}}{6} \\left( 2\\pmb{u}_{l}^{n+1} + \\pmb{u}_{l+1}^{n+1} \\right) - \\nu_{l+1/2} \\Delta t \\frac{\\pmb{u}_{l+1}^{n+1} - \\pmb{u}_{l}^{n+1}}{\\Delta z_{l+1}} \\chi\\Delta t \\pmb{u}_{kbs+1}^{n+1} &amp;= \\frac{\\Delta z_{l+1}}{6} \\left( 2\\pmb{g}_l + \\pmb{g}_{l+1} \\right), (l = kbs + 1)\\\\ \\frac{\\Delta z_l}{6} \\left( 2\\pmb{u}_l^{n+1} + \\pmb{u}_{l-1}^{n+1} \\right) + \\nu_{l-1/2} \\Delta t \\frac{\\pmb{u}_l^{n+1} - \\pmb{u}_{l-1}^{n+1}}{\\Delta z_l} &amp;= \\pmb{\\tau}_{w}^{n+1} \\Delta t + \\frac{\\Delta z_l}{6} \\left( 2\\pmb{g}_l + \\pmb{g}_{l-1} \\right), (l=N_z) \\end{aligned} \\end{equation}\\] <p>The bottom velocity is - </p> \\[\\begin{equation} \\label{eq04} \\begin{aligned} \\pmb{u}_{kbs}^{n+1} &amp;= 0, \\text{ if } \\chi \\neq 0\\\\ \\pmb{u}_{kbs}^{n+1} &amp;= \\pmb{u}_{kbs + 1}^{n+1}, \\text{ if } \\chi = 0 \\end{aligned} \\end{equation}\\] <p>which is consistent with the bottom BL formulation we used.</p> <p>After the velocities at all sides are found, the velocity at a node, which is needed in ELM, is evaluated using scheme MA or MB as discussed above.</p> <p>If a cell is 2D locally, the velocity is simply solved as - </p> \\[\\begin{equation} \\label{eq05} \\pmb{u}^{n+1} = \\frac{\\breve{H}}{H} \\left[ \\pmb{u}^* + \\left( \\pmb{f} + \\pmb{\\tau}_w/H \\right) \\Delta t - g\\theta\\nabla\\eta^{n+1} - g(1-\\theta)\\nabla\\eta^n \\right] \\end{equation}\\]"},{"location":"schism/overview.html","title":"How to read this manual","text":"<p>This manual contains detailed information on physical and numerical formulations, as well as usage for  SCHISM. For beginners, we suggest you familiarize yourself with the basic notations in  Physical formulation and Numerical formulation  but skip some details in those two chapters; there is also a \u2018cheat sheet\u2019 in 'Typical workflow' below. This chapter describes how to set up the model, including mesh  generation, and  so should be read carefully, in consultation with appropriate sections in the 2 chapters and detailed descriptions on inputs/outputs. Since SCHISM is quite a sophisticated package, we strongly recommend you start from the simple  test cases and gradually progress toward more complex 3D baroclinic or coupled applications.</p>"},{"location":"schism/overview.html#notation-used-in-this-manual","title":"Notation used in this manual","text":"<p>We will use bold characters to denote vectors and matrices, and unbold characters to denote scalars in mathematical equations. In addition, superscripts usually denote time step and subscripts denote spatial locations. E.g., \\(T_{i,k}^{n+1}\\) may mean the temperature at step \\(n+1\\) (i.e., new time step) and prism \\((i,k)\\), where \\(i\\) is the element number and \\(k\\) is the (whole) vertical index. We will use inline code blocks to denote input file names (e.g. <code>param.nml</code>) or code/pseudo-code fragments. </p> <p>Below are some notations used in this manual:</p> <p>\\(N_p\\): number of nodes</p> <p>\\(N_s\\): number of sides</p> <p>\\(N_e\\): number of elements</p> <p>\\(N_z\\): maximum number of vertical levels</p> <p>\\(i34(j)\\): type of an element \\(j\\) (3: triangle; 4: quad)</p> <p>\\(Nb(i)\\): number of surrounding elements of a node \\(i\\);</p> <p>\\(kbp(i)\\): bottom index as seen by a node \\(i\\)</p> <p>\\(kbs(i)\\): bottom index as seen by a side \\(i\\)</p> <p>\\(kbe(i)\\): bottom index as seen by an element \\(i\\)</p> <p>\\(A\\): area of an element</p> <p>\\(\\Delta z\\): layer thickness (at a node, side or elem.)</p> <p>\\(\\delta_{ij}\\): Kronecker Delta function (\\(=1\\) when \\(i=j\\); \\(0\\) otherwise)</p>"},{"location":"schism/overview.html#other-resources-for-beginners","title":"Other resources for beginners","text":"<p>Over the years various user groups have come up with their own documentations  to help SCHISM beginners, and you may find them helpful. For example, CA Dept of Water  Resources group maintained a (Hello SCHISM site).</p>"},{"location":"schism/physical-formulation.html","title":"Physical formulation","text":""},{"location":"schism/physical-formulation.html#governing-equations","title":"Governing equations","text":"<p>We will focus only on the hydrostatic solver in side SCHISM. Under this mode, we solve the standard Navier-Stokes equations with hydrostatic and Boussinesq approximations, including the effects of vegetation.</p> <p>Momentum equation: </p> \\[\\begin{equation} \\begin{aligned} \\frac{Du}{dt} = \\pmb{f} - g \\nabla \\eta + \\pmb{m}_z - \\alpha \\left| \\pmb{u} \\right| \\pmb{u} L(x, y, z)\\\\ \\pmb{f} = f(v, -u) - \\frac{g}{\\rho_0} \\int_z^{\\eta} \\nabla \\rho d\\zeta - \\frac{\\nabla p_A}{\\rho_0} + a g \\nabla \\Psi + \\pmb{F}_m + other \\end{aligned} \\label{eq:momentum} \\end{equation}\\] <p>Continuity equation in 3D and 2D depth-integrated forms:</p> \\[\\begin{align} \\nabla \\cdot \\pmb{u} + \\frac{\\partial w}{\\partial z} = 0\\\\ \\frac{\\partial \\eta}{\\partial t} + \\nabla \\cdot \\int_{-h}^{\\eta} \\pmb{u} dz = 0 \\end{align}\\] <p>Transport equations:</p> \\[\\begin{equation} \\frac{\\partial C}{\\partial t} + \\nabla \\cdot (\\pmb{u}C) = \\frac{\\partial}{\\partial z} \\left( \\kappa \\frac{\\partial C}{\\partial z} \\right) + F_h  \\end{equation}\\] <p>Equation of state:</p> \\[\\begin{equation*} \\rho = \\rho(S, T, p) \\end{equation*}\\] <p>Where, </p> <ul> <li>\\(\\nabla\\) : \\(\\left( \\frac{\\partial}{\\partial x}, \\frac{\\partial}{\\partial y} \\right)\\)</li> <li>\\(\\frac{D}{Dt}\\) : material derivative</li> <li>\\((x, y)\\): horizontal Cartesian coordinates</li> <li>\\(z\\): vertical coordinate, positive upward</li> <li>\\(t\\): time</li> <li>\\(\\eta(x, y, t)\\): free-surface elevation in meters [\\(m\\)]</li> <li>\\(h(x, y)\\): bathymetric depth (measured from a fixed datum) [\\(m\\)]</li> <li>\\(\\pmb{u}(x, y, z, t)\\): horizontal velocity, with Cartesian components \\((u, v)\\) [\\(m/s\\)]</li> <li>\\(w(x, y, z, t)\\): vertical velocity [\\(m/s\\)]</li> <li>\\(p\\): hydrostatic pressure [\\(Pa\\)]</li> <li>\\(p_A\\): atmospheric pressure reduced to mean sea level (MSL) [\\(Pa\\)]</li> <li>\\(\\rho, \\rho_0\\): water density and reference water density [\\(kg/m^3\\)]</li> <li>\\(\\pmb{f}\\): other forcing terms in momentum (baroclinic gradient, horizontal viscosity, Coriolis, earth tidal potential, atmospheric pressure, radiation stress). These are usually treated explicitly in the numerical formulation</li> <li>\\(g\\): acceleration of gravity, in [\\(m/s^2\\)]</li> <li>\\(C\\): tracer concentration (e.g., salinity, temperature, sediment etc)</li> <li>\\(\\nu\\): vertical eddy viscosity, in [\\(m^2/s\\)]</li> <li>\\(\\kappa\\): vertical eddy diffusivity, for tracers, in [\\(m^2/s\\)]</li> <li>\\(\\pmb{F}_m\\): horizontal viscosity [\\(m^2/s\\)]</li> <li>\\(F_h\\): horizontal diffusion and mass sources/sinks [\\(m^2/s\\)]</li> </ul> <p>Vegetation effects have been accounted for in Eq. 1. The main vegetation parameter is \\(\\alpha(x, y) = D_v N_v C_{Dv}/2\\) is a vegetation related density variable in [\\(m^{-1}]\\), where \\(D_v\\) is the stem diameter, \\(N_v\\) is the vegetation density (number of stems per \\(m^2\\)), and \\(C_{Dv}\\) is the bulk form drag coefficient. Selection of \\(C_{Dv}\\) is the topic of other studies with values between 0 and 3 (Nepf and Vivoni 2000; Tanino and Nepf 2008), and is validated against reported lab study values. The underlying assumption used here is to treat the vegetation as arrays of solid cylinders, which is only a first-order approximation of the problem. Flexibility of the vegetation, sheltering effects within a cluster of vegetation can lead to one to two orders of reduction in the drag forces, and Gaylord et al. (2008) showed that the drag formulation is also species dependent. These additional complexities are outside the scope of the current study. In this paper, we assume \\(C_{Dv}\\) is a constant, but a vertically varying \\(C_{Dv}\\) (as suggested by Nepf and Vivoni 2000 and others) can be easily added as well; the latter can be used to approximate flexible stems (Nepf and Vivoni 2000; Luhar and Nepf 2011).</p> <p>Since SCHISM allows \u2018polymorphism\u2019 with mixed 2D and 3D cells in a single grid (Zhang et al. 2016), we have different forms for the vertical eddy viscosity term \\(\\pmb{m}_z\\) and vegetation term \\(L(x, y, z)\\). </p> \\[\\begin{equation} \\begin{aligned}     \\pmb{m}_z=  \\begin{cases}     \\frac{\\partial}{\\partial z}\\left( \\nu \\frac{\\partial \\pmb{u}}{\\partial z} \\right),&amp; \\text{3D cells}\\\\     \\frac{\\pmb{\\tau}_w - \\chi \\pmb{u}}{H}, &amp; \\text{2D cells} \\end{cases}\\\\     L(x, y, z)=  \\begin{cases}     \\mathcal{H}(z_v - z),&amp; \\text{3D}\\\\     1,              &amp; \\text{2D} \\end{cases} \\end{aligned} \\end{equation}\\] <p>where, \\(\\nu\\) is the eddy viscosity, \\(\\pmb{\\tau}_w\\) is the surface wind stress, \\(H=h+\\eta\\) is the total water depth (with \\(h\\) being the depth measured from a fixed datum), \\(\\chi = C_d \\left| \\pmb{u} \\right|\\), \\(C_D\\) is the bottom drag coefficient, \\(z_v\\)  is the z-coordinate of the canopy, and \\(\\mathcal{H}()\\) is the Heaviside step function - </p> \\[\\begin{equation*} \\mathcal{H} =  \\begin{cases}     1, &amp; x \\geq 0\\\\     0, &amp; x \\lt 0 \\end{cases} \\end{equation*}\\] <p>Note that \\(\\pmb{u}\\) denotes the depth-averaged velocity in a 2D region.</p>"},{"location":"schism/physical-formulation.html#boundary-conditions-bc","title":"Boundary conditions (B.C.)","text":"<p>The differential equations above need initial condition (I.C.) and B.C. In general, all state variables (\\(\\eta\\), \\(\\pmb{u}\\), \\(C\\)) are specified at \\(t=0\\) as I.C. and these are also specified at all open lateral boundary segments (open ocean, rivers etc). However, not all variables need to be specified at all boundary segments and we\u2019ll revisit this in the input-output section, i.e., bctides.</p> <p>The vertical B.C. for (Eq 1-4) are described in detail below as these impact the numerical scheme. Note that these only apply to 3D cells; for 2D cells, Eq. 1a has taken into account the B.C.</p> <p>At the sea surface, SCHISM enforces the balance between the internal Reynolds stress and the applied shear stress.</p> \\[\\begin{equation} \\nu \\frac{\\partial \\pmb{u}}{\\partial z} = \\pmb{\\tau}_w, \\text{ at } z = \\eta \\end{equation}\\] <p>where the stress \\(\\pmb{\\tau}_z\\) can be parameterized using the approach of Zeng et al. (1998) or the simpler approach of Pond and Pickard (1998). If the Wind Wave Model is invoked, it can also be calculated from the wave model.</p> <p>Because the bottom boundary layer is usually not well resolved in ocean models, the no-slip condition at the sea or river bottom (\\(\\pmb{u} = w = 0\\)) is replaced by a balance between the internal Reynolds stress and the bottom frictional stress. </p> \\[\\begin{equation} \\nu \\frac{\\partial \\pmb{u}}{\\partial z} = \\pmb{\\tau}_b, \\text{ at } z=-h \\end{equation}\\] <p>The specific form of the bottom stress \\(\\pmb{\\tau}_b\\) depends on the type of boundary layer used and here we will only discuss the turbulent boundary layer below (Blumberg and Mellor 1987), given its prevalent usage in ocean modeling. The bottom stress is then - </p> \\[\\begin{equation} \\pmb{\\tau}_b = C_D \\left| \\pmb{u}_b \\right| \\pmb{u}_b \\equiv \\chi \\pmb{u}_b \\end{equation}\\] <p>The velocity profile in the interior of the bottom boundary layer obeys the logarithmic law, which is smoothly matched to the exterior flow at the top of the boundary layer.</p> \\[\\begin{equation} \\pmb{u} = \\frac{ln[(z+h)/z_0]}{ln(\\delta_b/z_0)}\\pmb{u}_b, z_0-h \\leq z \\leq \\delta_b -h \\end{equation}\\] <p>Here, \\(\\delta_b\\) is the thickness of the bottom computational cell (assuming that the bottom is sufficiently resolved in SCHISM that the bottom cell is inside the boundary layer), \\(z_0\\) is the bottom roughness, and \\(\\pmb{u}_b\\) is the velocity measured at the top of the bottom computational cell. Therefore the Reynolds stress inside the boundary layer is derived as - </p> \\[\\begin{equation} \\nu \\frac{\\partial \\pmb{u}}{\\partial z} = \\frac{\\nu}{(z+h)ln(\\delta_b/z_0)}  \\pmb{u}_b \\end{equation}\\] <p>Utilizing the turbulence closure theory discussed below, we can show that the Reynolds stress is constant inside the boundary layer - </p> \\[\\begin{equation} \\nu \\frac{\\partial \\pmb{u}}{\\partial z} = \\frac{\\kappa_0}{ln(\\delta_b/z_0)} C_D^{1/2} \\left| \\pmb{u}_b \\right| \\pmb{u}_b, z_0-h \\leq z \\leq \\delta_b -h \\end{equation}\\] <p>and the drag coefficient is calculated from Eq. 7, 8, and 11 as - </p> \\[\\begin{equation} C_D = \\left( \\frac{1}{\\kappa_0} ln(\\delta_b/z_0) \\right) ^{-2} \\end{equation}\\] <p>which is the drag formula as discussed in Blumberg and Mellor (1987). Eq. 11 also shows that the vertical viscosity term in the momentum equation vanishes inside the boundary layer. This fact will be utilized in the numerical formulation.</p>"},{"location":"schism/physical-formulation.html#turbulence-closure","title":"Turbulence closure","text":"<p>Eq 1-4 are not closed and must be supplemented by turbulence closure equations for the viscosity/diffusivity. We use the Generic Length-scale (GLS) model of Umlauf and Burchard (2003), which has the advantage of encompassing most of the Eq 6 closure models \\(k-\\varepsilon\\) (Rodi 1984); \\(k-\\omega\\) (Wilcox 1998; Mellor and Yamada, 1982). In this framework, the transport, production, and dissipation of the turbulent kinetic energy (\\(K\\)) and of a generic length-scale variable (\\(\\psi\\)) are governed by - </p> \\[\\begin{equation} \\frac{Dk}{Dt} = \\frac{\\partial}{\\partial z} \\left( \\nu_k^{\\psi} \\frac{\\partial k}{\\partial z} \\right) + \\nu M^2 + \\kappa N^2 - \\varepsilon + c_{fk} \\alpha \\left| \\pmb{u} \\right|^3 \\mathcal{H} (z_v - z) \\end{equation}\\] \\[\\begin{equation} \\frac{D \\psi}{Dt} = \\frac{\\partial}{\\partial z} \\left( \\nu_{\\psi} \\frac{\\partial \\psi}{\\partial z} \\right) + \\frac{\\psi}{k}\\left[ c_{\\psi 1} \\nu M^2 + c_{\\psi 3} \\kappa N^2 - c_{\\psi 2}\\varepsilon F_{wall} + c_{f\\psi} \\alpha \\left| \\pmb{u} \\right|^3 \\mathcal{H}(z_v-z) \\right] \\end{equation}\\] <p>where \\(\\nu_k^{\\psi}\\) and \\(\\nu_{\\psi}\\) are vertical turbulent diffusivities, \\(c_{\\psi 1}\\), \\(c_{\\psi 2}\\), and \\(c_{\\psi 3}\\) are model-specific constants (Umlauf and Burchard 2003), \\(F_{wall}\\) is a wall proximity function, \\(M\\) and \\(N\\) are shear and buoyancy frequencies, and \\(\\varepsilon\\) is a dissipation rate. The generic length-scale is defined as - </p> \\[\\begin{equation} \\psi = (c_{\\mu}^0)^p K^m \\ell^n \\end{equation}\\] <p>where \\(c_{\\mu}^0 = 0.3^{1/2}\\) and \\(\\ell\\) is the turbulence mixing length. The specific choices of the constants \\(p\\), \\(m\\), and \\(n\\) lead to the different closure models mentioned above. Finally, vertical viscosities and diffusivities as appeared in Eq 1-4 are related to \\(K\\), \\(ell\\), and stability functions - </p> \\[\\begin{equation} \\begin{aligned} \\nu = \\sqrt{2} s_m K^{1/2} \\ell \\\\ \\kappa = \\sqrt{2} s_h K^{1/2} \\ell \\\\ \\nu_k^{\\psi} = \\frac{\\nu}{\\sigma_k^{\\psi}} \\\\ \\nu_{\\psi} = \\frac{\\nu}{\\sigma_{\\psi}} \\end{aligned} \\end{equation}\\] <p>where the Schmidt numbers \\(\\sigma_k^{\\psi}\\) and \\(\\sigma_{\\psi}\\) are model-specific constants. The stability functions (\\(s_m\\) and \\(s_h\\)) are given by an Algebraic Stress Model (e.g.: Kantha and Clayson 1994, Canuto et al. 2001, or Galperin et al. 1988). Following Shimizu and Tsujimoto (1994; ST94 hereafter), we set \\(c_{fk} = 0.07\\) and \\(c_{f\\psi} = 0.16\\).</p> <p>At the free surface and at the bottom of rivers and oceans, the turbulent kinetic energy and the mixing length are specified as Direchlet boundary conditions - </p> \\[\\begin{equation} K = \\frac{1}{2} B_1^{2/3} \\left| \\pmb{\\tau_b} \\right|, \\text{ or } \\frac{1}{2} B_1^{2/3} \\left| \\pmb{\\tau_w} \\right|  \\end{equation}\\] \\[\\begin{equation} \\ell = \\kappa_o d_b \\text{ or } \\kappa_0 d_s \\end{equation}\\] <p>where \\(\\pmb{\\tau_b}\\) is a bottom frictional stress, \\(\\kappa_0 = 0.4\\) is the von Karman\u2019s constant, \\(B_1\\) is a constant, and \\(d_b\\) and \\(d_s\\) are the distances to the bottom and the free surface, respectively.</p>"},{"location":"schism/physical-formulation.html#air-sea-exchange","title":"Air-sea exchange","text":"<p>We use the bulk aerodynamic module of Zeng et al. (1998), which can be viewed here.</p> <p>References</p> <p>Blumberg, A.F. and G.L. Mellor (1987) A description of a three-dimensional coastal ocean circulation model. In: Three-Dimensional Coastal Ocean Models, vol. 4, Coastal and Estuarine Studies, N. Heaps, editor, Washington, D.C.: AGU, pp. 1-16.</p> <p>Canuto, V.M., A. Howard, Y. Cheng and M.S. Dubovikov (2001) Ocean turbulence I: one-point closure model. Momentum and heat vertical diffusivities. J. Phys. Oceano., 31, pp. 1413-1426.</p> <p>Galperin, B., L. H. Kantha, S. Hassid and A. Rosati (1988) A quasi-equilibrium turbulent energy model for geophysical flows. J. Atmos. Sci., 45, pp. 55-62.</p> <p>Kantha, L.H. and C.A. Clayson (1994) An improved mixed layer model for geophysical applications. J. Geophy. Res, 99(25), pp. 235-266.</p> <p>Mellor, G.L. and T. Yamada (1982) Development of a turbulence closure model for geophysical fluid problems. Rev. Geophys., 20, pp. 851-875.</p> <p>Pond, S. and G.L. Pickard (1998) Introductory Dynamical Oceanography, Butterworth-Heinmann.</p> <p>Rodi, W. (1984) Turbulence models and their applications in hydraulics: a state of the art review. Delft, The Netherlands, International Association for Hydraulics Research.</p> <p>Umlauf, L. and H. Burchard (2003) A generic length-scale equation for geophysical turbulence models. J. Mar. Res., 6, pp. 235-265.</p> <p>Wilcox, D.C. (1998) Reassessment of scale determining equation for advance turbulence models. AIAA J., 26, pp. 1299-1310.</p> <p>Zeng, X., M. Zhao and R.E. Dickinson (1998) Intercomparison of bulk aerodynamic algorithms for the computation of sea surface fluxes using TOGA COARE and TAO data. J. Clim., 11, pp. 2628-2644.</p> <p>Zhang, Y., Ye, F., Stanev, E.V., Grashorn, S. (2016). Seamless cross-scale modeling with SCHISM, Ocean Modelling, 102, 64-81. doi:10.1016/j.ocemod.2016.05.002</p>"},{"location":"schism/spherical-coordinates.html","title":"Spherical coordinates","text":"<p>We used the approach of Comblen et al. (2009) and transform the coordinates instead of the equations. Since the unstructured grids work naturally on a sphere, the polar singularity is avoided. Most of the work is done inside local frames. There are 2 frames used (Figure 1); note that all frames rotate with the earth.</p> <p></p> Coordinate frames on a sphere. <p>Global frame \\((x_g, y_g, z_g)\\) (Figure 1). The origin is located at center of the earth (assumed to be a sphere) of radius \\(R_0\\), \\(x_g\\) axis pointing to prime meridian, \\(z_g\\) to the north pole. The coordinates are related to the longitude and latitude of a point on the spherical surface as:</p> \\[\\begin{equation} \\label{eq01} \\begin{cases} x_g = R_0 \\cos\\phi\\cos\\lambda\\\\ y_g = R_o \\cos\\phi\\sin\\lambda\\\\ z_g = R_0 \\sin\\phi \\end{cases} \\end{equation}\\] <p>Local frame, located at a point on sphere (e.g., node/side center/element centroid): The 3 axes of this frame are: \\(\\pmb\\lambda^0\\) (zonal), \\(\\pmb\\phi^0\\) (meridional North), and \\(\\pmb r^0 = \\pmb\\lambda^0 \\times \\pmb\\phi^0\\) (radial). The relationship between this frame and global frame is: </p> \\[\\begin{equation} \\label{eq02} \\begin{aligned} \\pmb\\lambda^0 = -\\sin\\lambda\\pmb i + \\cos\\lambda\\pmb j\\\\ \\pmb\\phi^0 = -\\cos\\lambda\\sin\\phi\\pmb i - \\sin\\lambda\\sin\\phi j + \\cos \\phi \\pmb k \\end{aligned} \\end{equation}\\] <p>The frame \\((\\pmb\\lambda^0, \\pmb\\phi^0, \\pmb r^0)\\) is then the local \\((x, y, z)\\) frame.</p> <p>Here, \\(\\pmb i, \\pmb j, \\pmb k\\) are unit vectors of the global frame. Strictly speaking this frame is undefined at the 2 poles, but we can still use it there as long as the axes are unique.</p> <p>Further assumption is made that when the origins are close to each other, the z-axes also coincide with each other, e.g. in the back-tracking part etc. This is reasonable as the relevant distances are much smaller than \\(R_0\\).</p> <p>With the aid from all these frames, the equations can be solved in a very similar way as in Cartesian frame. The main difference is in the evaluation of the vectors in the local frame. The changes to the code are therefore minimal.</p> <p>Below are some important info about arrays used in the code that are affected by lon/lat frames:</p> <ul> <li><code>(xnd,ynd,znd)</code>, <code>(xcj,ycj,zcj)</code>, <code>(xctr,yctr,zctr)</code> are global coordinates of node, side center and element centroid for <code>ics=1</code> or <code>2</code>. If <code>ics=1</code> (Cartesian), <code>znd=zcj=zctr= 0</code>;</li> <li><code>(znl, zs, ze)</code> are local z-coordinates measured vertically upward from the undisturbed surface (i.e. local frame when <code>ics=2</code>), at node, side, and element;</li> <li><code>eframe(1:3,1:3,1:nea)</code> is the tensor for the element frame (w.r.t. global frame). The 2nd index indicates axid id <code>(1=x; 2=y; 3=z)</code> and the 1st index indicates tensor components. <code>sframe</code> and <code>pframe</code> are similar.</li> </ul> <p>References</p> <p>Comblen, R., Legrand, S., Deleersnijder, E., and Legat, V. (2009) A finite element method for solving the shallow water equations on the sphere. Ocean Mod., 28, 12-23.</p>"},{"location":"schism/transport-equation.html","title":"Transport equation","text":"<p>SCHISM supports a few FV solvers for the transport equation. All of the tracers, including T,S, sediment (if invoked) etc are solved simultaneously for efficiency. </p> <p>The transport equation for a generic tracer C is given by:</p> \\[\\begin{equation} \\label{eq01} \\frac{\\partial C}{\\partial t} + \\nabla \\cdot (\\pmb{u}C) = \\frac{\\partial}{\\partial z} \\left( \\kappa \\frac{\\partial C}{\\partial z} \\right) + F_h \\end{equation}\\] <p>where \\(F_h\\) includes vertical settling term (see Vertical movement), source/sink and also horizontal viscosity terms. The vertical B.C. is:</p> \\[\\begin{equation} \\label{eq02} \\begin{aligned} \\kappa\\frac{\\partial C}{\\partial z} &amp;= \\hat{C}, z = \\eta\\\\ \\kappa\\frac{\\partial C}{\\partial z} &amp;= \\hat{C}_b, z = -h \\end{aligned} \\end{equation}\\] <p>Note that the 3D continuity equation ensures the constancy condition for the transport equation, i.e. \\(C=\\text{const}\\) initially will remain so in the absence of sinks/source.</p> <p>In the following, we describe the numerical algorithm starting from  the simplest 1st-order upwind scheme to the more complex 3rd-order WENO. In the newer versions, the pure upwind and explicit   TVD schemes have been deprecated.</p>"},{"location":"schism/transport-equation.html#upwind","title":"Upwind","text":"<p>Since most of the variables below are defined at prism center, we will use shorthand like \\(i\\) etc to denote a prism at level \\(k + 1/2\\) when there is no confusion. Also we often omit the superscript \\(n\\) in the explicit terms for brevity.</p> <p>A FV discretization of Eq. \\(\\ref{eq01}\\) for prism \\(i\\) is :</p> \\[\\begin{equation} \\label{eq03} C_i^{m+1} = C_i^m - \\frac{\\Delta t'}{V_i}\\sum_{j\\in S} Q_j C_{j*} + (F_h)_i^n \\Delta t' + \\frac{A_i \\Delta t'}{V_i} \\left[ \\kappa_{i, k} \\frac{C_{i, k+1}^{m+1} - C_{i,k}^{m+1}}{\\Delta z_{i, k+\\frac{1}{2}}} - \\kappa_{i, k-1} \\frac{C_{i,k}^{m+1} - C_{i,k-1}^{m+1}}{\\Delta z_{i, k-\\frac{1}{2}}} \\right], (k = kbe + 1, \\cdots, N_z) \\end{equation}\\] <p>where \\(\\Delta t' \\neq \\Delta t\\)  is the transport time step (subject to Courant condition below), \\(V_i\\) is the volume of the prism, \\(C_i\\) s a shorthand for \\(C_{i, k}\\) (i.e., concentration at prism \\((i,k)\\)), and \\(Q_j\\) is the flux at face \\(j\\) outward of the prism. Note that we have treated the diffusion term implicitly. For the sake of brevity we\u2019ll drop the source and diffusion terms from now on and focus on the advection term. With the upwind scheme, the face concentration is defined as:</p> \\[\\begin{equation} \\label{eq04} C_{j*} = \\begin{cases} C_i, j \\in S^+\\\\ C_j, j \\in S^- \\end{cases} \\equiv C_{up} \\end{equation}\\] <p>where we have used shorthand for concentration at prism \\(j\\) (i.e. the prism adjacent to \\((i,k)\\) from face j), and \\(S^+\\) and \\(S^-\\) are outflow and inflow faces respectively. The face concentration take different forms with higher-order schemes.</p> <p>Mass conservation</p> <p>Eq. \\(\\ref{eq03}\\) is the starting point of all FV solvers in SCHISM, from which a conservation statement can be derived. Assuming no zero fluxes at surface, bottom and lateral boundary, summing up over all prisms leads to:</p> \\[\\begin{equation*} \\sum_i V_i C_i^{m+1} = \\sum_i V_i C_i^m - \\Delta t' \\sum_{j\\in FS} Q_j C_j \\end{equation*}\\] <p>where \\(FS\\) stands for free surface. Note that the volume \\(V_i\\) is evaluated at previous step \\(m\\). The 2nd term in Eq. \\(\\ref{eq03}\\) cancels out at all faces (or vanish at lateral boundary) except at the free surface. The 2nd term in above equation represents the contribution from the surface movement and is supposed to account for the movement from \\(m\\) to \\(m+1\\). However, this balance is not precise (time truncation error). In the case of \\(TVD^2\\) or \\(WENO\\) (<code>itr_met&gt;2</code>), there is also additional splitting error. Therefore mass conservation is only good up to time truncation error.</p> <p>Retaining only the advection term, Eq. \\(\\ref{eq03}\\) then becomes:</p> \\[\\begin{equation} \\label{eq05} C_i^{m+1} = C_i \\left( 1 - \\frac{\\Delta t'}{V_i} \\sum_{j\\in S^+} \\left| Q_j \\right| \\right) + \\frac{\\Delta t'}{V_i}\\sum_{j\\in S^+} \\left| Q_j \\right| C_j \\end{equation}\\] <p>We have utilized the volume conservation:</p> \\[\\begin{equation} \\label{eq06} \\sum_{j\\in S^+} \\left| Q_j \\right| = \\sum_{j\\in S^-} \\left| Q_j \\right| \\end{equation}\\] <p>Therefore the Courant condition is:</p> \\[\\begin{equation} \\label{eq07} 1 - \\frac{\\Delta t'}{V_i} \\sum_{j\\in S^+} \\left| Q_j \\right| \\geq 0 \\end{equation}\\] <p>SCHISM uses this eq. to dynamically adjust the time step for transport for each step. Moreover, to improve efficiency, the vertical flux terms in Eq. \\(\\ref{eq05}\\) are treated implicitly, and the corresponding terms are then removed in the Courant condition - Eq. \\(\\ref{eq07}\\). This is allowable because upwind is a linear method.</p>"},{"location":"schism/transport-equation.html#tvd-explicit","title":"TVD (explicit)","text":"<p>The only difference between TVD and upwind schemes lies in the evaluation of the interfacial concentration:</p> \\[\\begin{equation} \\label{eq08} C_{j*} = C_{up} + \\frac{\\varphi_j}{2}\\left( C_{jD} - C_{up} \\right) \\end{equation}\\] <p>where \\(C_{up}\\) is given in Eq. \\(\\ref{eq04}\\), \\(C_{jD}\\) is the downstream concentration, and \\(0 \\leq \\varphi_j \\leq 2\\) is a limiter function. TVD scheme nominally approaches 2nd order accuracy due to the anti-diffusion term. </p> <p>After some algebraic manipulation, the final eq. for TVD is:</p> \\[\\begin{equation} \\label{eq09} C_i^{m+1} = C_i + \\frac{\\Delta t'}{V_i} \\sum_{j\\in S^-} \\left| Q_j \\right| (C_j - C_i) + \\frac{\\Delta t'}{V_i} \\sum_{j\\in S} \\left| Q_j \\right| \\frac{\\varphi_j}{2} (C_i - C_j) + \\text{source} + \\text{diffusion} \\end{equation}\\] <p>and the Courant condition is:</p> \\[\\begin{equation} \\label{eq10} \\Delta t' \\leq \\frac{V_i}{\\sum_{j\\in S^-}\\left| Q_j \\right| \\left( 1-\\frac{\\varphi_j}{2} + \\delta_i\\right)} \\end{equation}\\] <p>where:</p> \\[\\begin{equation} \\label{eq11} \\delta_i = \\sum_{p\\in S^+} \\frac{\\varphi(r_p)}{2r_p} \\end{equation}\\] <p>and the upwind ratio, which involves upwind of upwind neighboring prism, is given by:</p> \\[\\begin{equation} \\label{eq12} r_p = \\frac{\\sum_{m\\in S^-} \\left| Q_m \\right| (C_m - C_i)}{\\left| Q_p \\right| (C_i - C_p)}, p \\in S^+ \\end{equation}\\] <p>In Eqs. \\(\\ref{eq09}\\) and \\(\\ref{eq10}\\), the faces \\(S\\), \\(S^+\\), and \\(S^-\\) need to exclude the locations where upwind is applied: all horizontal and vertical boundaries, and interfaces between wetting and drying. In those places, \\(\\varphi_j = \\delta_i = 0\\). Again SCHISM automatically calculates the time step according to the Courant condition (Eq. \\(\\ref{eq10}\\)); the sub-time step used is the minimum of all prisms. The choices for the limiter function include: MINMOD, OSHER, van Leer, Super Bee etc.</p> <p>Since TVD scheme here is a nonlinear method, we cannot treat the vertical fluxes implicitly, and so all fluxes have  to be treated explicitly. TVD method is therefore more expensive than upwind. A more efficient \\(TVD^2\\) using a fractional  time step method should be used. </p>"},{"location":"schism/transport-equation.html#tvd2","title":"\\(TVD^2\\)","text":"<p>The TVD scheme shown above is explicit in 3D space and thus subject to the Courant condition, which comprises of horizontal and vertical fluxes across each of the prism faces (Casulli and Zanolli 2005). The restriction related to the vertical fluxes is especially severe due to smaller grid size used in the vertical dimension, and therefore a large number of sub-cycles within each time step are usually required. To partially mitigate the issue, a hybrid upwind-TVD approach can be used in which the more efficient upwind scheme, with an implicit treatment of the vertical fluxes, is used when the flow depth falls below a given threshold (with the assumption that stratification is usually much smaller in the shallows). However, this approach does not work in deeper depths of eddying regime, as large vertical velocities are not uncommon along steep bathymetric slopes. Together with the fact that a large number of vertical levels are usually required in the eddying regime, the explicit scheme leads to subpar computational performance and usually takes over 90% of the total CPU time.</p> <p>We therefore develop an implicit TVD scheme in the vertical dimension in SCHISM. We start from the FVM formulation of the 3D transport equation at a prism \\(i\\):</p> \\[\\begin{equation} \\label{eq13} C_i^{n+1} = C_i^n - \\frac{\\Delta t}{V_i} \\sum_{j\\in S^-} \\left| Q_j \\right| (C_i - C_j) - \\frac{\\Delta t}{V_i} \\sum_{j\\in S} Q_j C_{jr} + \\frac{A_i \\Delta t}{V_i} \\left[ \\left(\\kappa \\frac{\\partial C}{\\partial z} \\right)_{i,k} - \\left(\\kappa \\frac{\\partial C}{\\partial z} \\right)_{i, k-1} \\right] + \\frac{\\Delta t}{V_i} \\int_{V_i} F_h dV \\end{equation}\\] <p>where \\(C_j\\) is the concentration at the neighboring prism of \\(i\\) across a prism face \\(j\\in S = S^+ \\cup S^-\\), with \\(S^+/S^-\\) denoting outflow/inflow faces (which can be horizontal or vertical) respectively, \\(V_i\\) is the prism volume, \\(A_i\\) is the area of the associated surficial element, and \\(Q_j\\) is the flux at a face. In Eq. \\(\\ref{eq13}\\) we have utilized the volume conservation in a prism (which is enforced by the solution of the vertical velocity): \\(\\sum_{j\\in S^-}\\left| Q_j \\right| = \\sum_{j\\in S^+} \\left| Q_j \\right|\\). We have also approximated the concentration at a face as the sum of an upwind and a correction part as:</p> \\[\\begin{equation} \\label{eq14} C\\Biggr|_j = C_{jup} + C_{jr} \\end{equation}\\] <p>Note that in the 2nd term of RHS of Eq. \\(\\ref{eq13}\\), we have \\(C_j = C_{jup}\\) as \\(j\\) is an inflow face. In addition, we have intentionally left out the time level in some terms in Eq. \\(\\ref{eq13}\\) as they will be treated explicitly or implicitly in the following.</p> <p>We split the solution of Eq. \\(\\ref{eq13}\\) into 3 sub-steps:</p> \\[\\begin{equation} \\label{eq15} C_i^{m+1} = C_i^n + \\frac{\\Delta t_m}{V_i} \\sum_{j\\in S_H^-} \\left| Q_j \\right| (C_j^m - C_i^m) - \\frac{\\Delta t_m}{V_i} \\sum_{j\\in S_H} Q_j \\hat\\psi_j^m, (m = 1, \\cdots, M) \\end{equation}\\] \\[\\begin{equation} \\label{eq16} \\widetilde C_i = C_i^{M+1} + \\frac{\\Delta t}{V_i} \\sum_{j\\in S_V^-} \\left| Q_j \\right| (\\widetilde C_j - \\widetilde C_i) - \\frac{\\Delta t}{V_i} \\sum_{j\\in S_V} Q_j (\\Phi_j + \\Psi_j), (j = kbe+1, \\cdots, N_z) \\end{equation}\\] \\[\\begin{equation} \\label{eq17} C_i^{n+1} = \\widetilde C_i + \\frac{A_i \\Delta t}{V_i} \\left[ \\left( \\kappa \\frac{\\partial C}{\\partial z} \\right)_{i,k}^{n+1} - \\left( \\kappa \\frac{\\partial C}{\\partial z} \\right)_{i, k-1}^{n+1} \\right] + \\frac{\\Delta t}{V_i} \\int_{V_i} F_h^n dV, (k = kbe+1, \\cdots, N_z) \\end{equation}\\] <p>The 1st step solves the horizontal advection part (for all 3D prisms \\(i\\)), the 2nd step deals with the vertical advection part (where \\(k_b\\) is the bottom level index and \\(N_z\\) is the surface level index), and the last step tackles the remaining terms. We could have combined the 1st and 3rd steps into a single step at the expense of efficiency, because sub-cycling is used in the 1st step. In Eq. \\(\\ref{eq15}\\), sub-cylcing in \\(M\\) sub-steps is required because of the horizontal Courant number condition, \\(\\Delta t_m\\) is the sub-time step used, and \\(\\hat\\psi_j^m\\) is a standard TVD limiter function. Eq. \\(\\ref{eq15}\\) is then solved with a standard TVD method. The last step (Eq. \\(\\ref{eq17}\\)) requires the solution of a simple tri-diagonal matrix. So we will only focus on the 2nd step.</p> <p>Following Duraisamy and Baeder (2007, hereafter DB07), we use two limiter functions in Eq. \\(\\ref{eq16}\\): \\(\\Phi_j\\) is the space limiter and \\(\\Psi_j\\) is the time limiter - thus the name \\(TVD^2\\). The origin of these two limiters is the approximation Eq. \\(\\ref{eq14}\\) via a Taylor expansion in both space and time (DB07):</p> \\[\\begin{equation} \\label{eq18} \\begin{aligned} C_j^{n+\\frac{1}{2}} &amp;= C_{jup}^{n+1} + \\Phi_j + \\Psi_j\\\\ &amp;= C_{jup}^{n+1} + \\pmb{r}\\cdot\\Bigr[ \\nabla C \\Bigr]_{jup}^{n+1} - \\frac{\\Delta t}{2} \\Bigr[ \\frac{\\partial C}{\\partial t} \\Bigr]_{jup}^{n+1} \\end{aligned} \\end{equation}\\] <p>Note that the interface value is taken at time level \\(n+\\frac{1}{2}\\) to gain 2nd-order accuracy in time. The vector \\(\\pmb{r}\\) points from prism center \\(jup\\) to face center \\(j\\). Due to the operator splitting method, \\(C^{n+1}\\) now actually corresponds to \\(\\widetilde{C}\\). Customary in a TVD method, we then replace the last 2 terms with limiter functions:</p> \\[\\begin{equation} \\label{eq19} C_j^{n+\\frac{1}{2}} = \\widetilde C_{jup} + \\frac{\\phi_j}{2} (\\widetilde C_{jD} - \\widetilde C_{jup}) - \\frac{\\psi_j}{2} (\\widetilde C_{jup} - C_{jup}^{M+1}) \\end{equation}\\] <p>and so:</p> \\[\\begin{equation} \\label{eq20} \\begin{aligned} \\Phi_j = \\frac{\\phi_j}{2} (\\widetilde C_{jD} - \\widetilde C_{jup})\\\\ \\Psi_j = \\frac{\\psi_j}{2} (\\widetilde C_{jup} - C_{jup}^{M+1}) \\end{aligned} \\end{equation}\\] <p>where \u2018jD\u2019 stands for the downwind prism of \\(i\\) along the face \\(j\\), and \\(\\phi_j\\) and \\(\\psi_j\\) are 2 limiter functions in space and time respectively. Note that \\(\\phi_j = \\psi_j = 1\\) leads to 2nd-order accuracy in both space and time.</p> <p>Substituting Eq. \\(\\ref{eq20}\\) in to Eq. \\(\\ref{eq16}\\) and after some algebra we obtain a nonlinear equation for the unknown concentration:</p> \\[\\begin{equation} \\label{eq21} \\widetilde C_i + \\frac{\\frac{\\Delta t}{V_i} \\sum_{j\\in S_V^-} \\left| Q_j \\right| \\left[ 1 + \\frac{1}{2} \\left( \\sum_{p\\in S_V^+} \\frac{\\phi_p}{r_p} - \\phi_j \\right) \\right] (\\widetilde C_i - \\widetilde C_j)}{1 + \\frac{\\Delta t}{2V_i} \\sum_{j\\in S_V^+} \\left| Q_j \\right| \\left( \\sum_{q\\in S_V^-} \\frac{\\psi_q}{s_q} - \\psi_j \\right)} = C_i^{M+1} \\end{equation}\\] <p>where \\(r_p\\) and \\(s_q\\) are upwind and downwind ratios respectively:</p> \\[\\begin{equation} \\label{eq22} \\begin{aligned} r_p &amp;= \\frac{\\sum_{q\\in S_V^-}\\left| Q_q \\right| (\\widetilde C_q - \\widetilde C_i)}{\\left| Q_p \\right| (\\widetilde C_i - \\widetilde C_p)}, p \\in S_V^+\\\\ s_q &amp;= \\frac{(\\widetilde C_i - C_i^{M+1}) \\sum_{p\\in S_V^+} \\left| Q_p \\right|}{\\left| Q_p \\right| (\\widetilde C_q - C_q^{M+1})}, q\\in S_V^- \\end{aligned} \\end{equation}\\] <p>DB07 showed that a sufficient TVD condition for Eq. \\(\\ref{eq21}\\) is that the coefficient of the 2nd LHS term be non-negative, i.e.:</p> \\[\\begin{equation} \\label{eq23} 1 + \\frac{1}{2}\\left(\\sum_{p\\in S_V^+} \\frac{\\phi_p}{r_p} - \\phi_j \\right) \\geq 0 \\end{equation}\\] \\[\\begin{equation} \\label{eq24} 1 + \\frac{\\Delta t}{2V_i} \\sum_{j\\in S_V^+} \\left| Q_j \\right| \\left( \\sum_{q\\in S_V^-} \\frac{\\psi_q}{s_q} - \\psi_j \\right) \\geq \\delta \\gt 0 \\end{equation}\\] <p>where \\(\\delta\\) is a small positive number. Eq. \\(\\ref{eq23}\\) can be satisfied with any choice of standard limiter functions in space, and Eq. \\(\\ref{eq24}\\) must be solved together with Eq. \\(\\ref{eq21}\\) iteratively, because \\(\\psi\\) and \\(s_q\\) are functions of \\(\\widetilde C\\). We need to discuss 3 scenarios for prism \\(i\\):</p> <p>Scenario 1.  vertically convergent flow: in this case, the outer sum in Eq. \\(\\ref{eq24}\\) is 0, so the inequality is always true;</p> <p>Scenario 2. divergent flow: the numerator of the 2nd LHS term in Eq. \\(\\ref{eq21}\\) is 0, and so \\(\\widetilde C_i = C_i^{M+1}\\);</p> <p>Scenario 3. uni-directional flow (either upward or downward): in this case, prism \\(i\\) has exactly 1 inflow and 1 outflow face vertically, so a sufficient condition for Eq. \\(\\ref{eq24}\\) is:</p> \\[\\begin{equation} \\label{eq25} 1 - \\frac{\\Delta t}{2 V_i} \\left| Q_j \\right| \\psi_j \\geq \\delta \\gt 0, j\\in S_V^+ \\end{equation}\\] <p>Therefore we choose the following form for the limiter:</p> \\[\\begin{equation} \\label{eq26} \\psi_j = \\text{max}\\left[0, \\text{min}\\left[1, \\frac{2(1-\\delta)V_i}{\\left| Q_j \\right|\\Delta t} \\right] \\right], j\\in S_V^+ \\end{equation}\\] <p>where we have imposed a maximum of 1 in an attempt to obtain 2nd-order accuracy in time. Note that the limiter is a function of the vertical Courant number: it decreases as the Courant number increases. Eqs. \\(\\ref{eq21}\\) and \\(\\ref{eq26}\\) are then solved using a simple Picard iteration method starting from \\(\\psi = 0\\) everywhere, and fast convergence within a few iterations is usually observed.</p> <p>Simple benchmark tests indicate that \\(TVD^2\\) is accurate for a wide range of Courant numbers as found in typical geophysical flows. It works equally well in eddying and non-eddying regimes, from very shallow to very deep depths, and is thus ideal for cross-scale applications. You are encouraged to use this option as much as possible.</p>"},{"location":"schism/transport-equation.html#third-order-weno-scheme","title":"Third-order WENO scheme","text":"<p>This option starts from the same Eqs (\\(\\ref{eq15}\\) - \\(\\ref{eq17}\\)), but solves Eq. (\\(\\ref{eq15}\\)) using a third-order WENO scheme. Essentially we use a higher-order reconstruction method to approximate the numerical flux and the details can be found in   Ye et al. (2019).</p>"},{"location":"schism/transport-equation.html#hybridization-with-eulerian-lagrangian-method","title":"Hybridization with Eulerian-Lagrangian Method","text":"<p>The FV schemes described above all have explicit component (in the horizontal dimension) that is subject to stability   constraint (Courant condition). This constraint can become severe, e.g. with high mesh resolution in the shallows in watershed  applications. To alleviate this constaint, SCHISM allows local hybridization between any of the FV schemes and the Eulerian-Lagrangian Method (ELM). Like the ELM scheme used for momentum advection, the ELM scheme for the transport advection is unconditionally  stable and monotone (if a linear interpolation is used at the foot of the characteristic line). The only downside of the ELM  is that it does not conserve mass in Eulerian sense (but it does in Lagrangian sense), and therefore should be used sparingly,  i.e., only to locally speed up the transport solver.</p> <p>The user can invoke this scheme by setting <code>ielm_transport=1</code> and prescribing a maximum allowed number of sub-sucyclings per  time step <code>max_subcyc</code>. To limit the use of ELM only for extreme cases, it's important to set a proper <code>max_subcyc</code>. A  rule of thumb is that a sub time step (for the explicit FV sovler) should be around 10 sec, so max_subcyc should be <code>dt/10</code>.</p> <p>Another issue with this hybridized scheme is that the combination of WENO and ELM in shallows can sometimes lead to  large numerical dispersion; see Known issues for details. A simple  solution for this issue is to make the affected regions upwind via <code>tvd.prop</code>.</p>"},{"location":"schism/transport-equation.html#vertical-movement","title":"Vertical movement","text":"<p>Many tracers have \u2018behaviors\u2019 in the form of vertical migration (upward or downward) in the water column. This is modeled with a \u2018settling\u2019 term: </p> \\[\\begin{equation} \\label{eq27} \\frac{\\partial C}{\\partial t} + \\nabla \\cdot (\\pmb{u}C) = \\frac{\\partial}{\\partial z} \\left( \\kappa \\frac{\\partial C}{\\partial z} \\right) + \\frac{\\partial (w_s C)}{\\partial z} \\end{equation}\\] <p>where \\(w_s\\) is the settling velocity (positive downward). This term is treated implicitly to avoid stability issues; in particular, it\u2019s solved in the 3rd step together with the diffusion term in Eq. \\(\\ref{eq17}\\). The benefit of this approach is that often the settling term balances the diffusion at boundary (e.g., sediment).</p>"},{"location":"schism/transport-equation.html#horizontal-bc-for-transport","title":"Horizontal B.C. for transport","text":"<p>In either upwind or TVD schemes, the concentration at the neighboring prism \\(T_j\\) at the open boundary is known. For outflow, \\(T_j=T_i\\) and the signal is advected out of the domain without hindrance. For incoming flow, \\(T_j\\) is specified by the B.C. (either in <code>bctides.in</code> or <code>*.th</code>), and SCHISM nudges to this value with a relaxation constant (specified in <code>bctides.in</code>), in order to prevent sharp gradient there. For a complete list of horizontal B.C. supported by SCHISM, see bctides.in.</p> <p>References</p> <p>Casulli, V. and P. Zanolli (2005) High resolution methods for multidimensional advection\u2013diffusion problems in free-surface hydrodynamics. Ocean Modelling, 10, pp.137-151.</p> <p>Duraisamy, K. and J.D. Baeder (2007), Implicit Scheme For Hyperbolic Conservation Laws Using Nonoscillatory Reconstruction In Space And Time, Siam J. Sci. Comput. 29(6), 2607\u20132620.</p>"},{"location":"schism/turbulence-closure.html","title":"Turbulence closure","text":"<p>Umlauf and Burchard\u2019s Generic Length Scale (GLS) model is </p> \\[\\begin{equation} \\label{eq01} \\begin{aligned} \\frac{DK}{Dt} &amp;= \\frac{\\partial}{\\partial z} ( \\nu_k^\\psi \\frac{\\partial K}{\\partial z} ) + \\nu M^2 + \\mu N^2 - \\varepsilon\\\\ \\frac{D\\psi}{Dt} &amp;= \\frac{\\partial}{\\partial z} ( \\nu_\\psi \\frac{\\partial \\psi}{\\partial z} ) + \\frac{\\psi}{K} ( c_{\\psi 1} \\nu M^2 + c_{\\psi 3} \\mu N^2 - c_{\\psi 2} F_w \\varepsilon) \\end{aligned} \\end{equation}\\] <p>with natural B.C.</p> \\[\\begin{equation} \\label{eq02} \\begin{cases} \\nu_k^\\psi \\frac{\\partial K}{\\partial z} = 0, z = -h \\text{ or } \\eta\\\\ \\nu_\\psi \\frac{\\partial\\psi}{\\partial z} = \\kappa_0 n \\nu_\\psi \\frac{\\psi}{l}, z = -h\\\\ \\nu_\\psi \\frac{\\partial\\psi}{\\partial z} = -\\kappa_0 n \\nu_\\psi \\frac{\\psi}{l}, z = \\eta \\end{cases} \\end{equation}\\] <p>and essential B.C.:</p> \\[\\begin{equation} \\label{eq03} \\begin{cases} K = ( c_\\mu^0 )^{-2} \\nu \\left| \\frac{\\partial u}{\\partial z} \\right|\\\\ l = \\kappa_0\\Delta, \\text{ at } z = -h \\text{ or } \\eta\\\\ \\psi = ( c_\\mu^0 )^p K^m ( \\kappa_0 \\Delta )^n \\end{cases} \\end{equation}\\] <p>where \\(K\\) is the TKE, \\(l\\) is the mixing length, \\(c_{\\psi *}\\) are constants, \\(\\psi = ( c_\\mu^0 )^p K^m l^n\\) is a generic length-scale variable, and \\(\\Delta\\) is the distance to the boundary (surface or bottom). The turbulence production and dissipation terms are:</p> \\[\\begin{equation} \\label{eq04} M^2 = (\\frac{\\partial u}{\\partial z})^2 + (\\frac{\\partial v}{\\partial z})^2 \\end{equation}\\] \\[\\begin{equation} \\label{eq05} N^2 = \\frac{g}{\\rho_0}\\frac{\\partial \\rho}{\\partial z} \\end{equation}\\] \\[\\begin{equation} \\label{eq06} \\varepsilon = (c_\\mu^0)^3 K^{1.5} l^{-1} \\end{equation}\\] <p>In the code, the natural B.C. is applied first (see the FEM formulation below), and the essential B.C. is then used  to overwrite the boundary values of the unknown, as suggested by GOTM. We also follow some other models and neglect  the advection terms here. In the FEM formulation,  \\(K\\), \\(\\psi\\) are defined at nodes and whole levels. Furthermore, the sums of \\(M^2\\) and \\(N^2\\) are  treated explicitly/implicitly depending on the sign. The final equations look similar to those for the momentum equation: </p> \\[\\begin{equation} \\label{eq07} \\begin{aligned} &amp;\\mathcal{H} (N_z -m) \\left[ \\frac{\\Delta z_{m+1}}{6} (2K_m^{n+1} + K_{m+1}^{n+1} - 2K_m^n - K_{m+1}^n) - \\Delta t (\\nu_k^\\psi)_{m+\\frac{1}{2}}^n \\frac{K_{m+1}^{n+1} - K_m^{n+1}}{\\Delta z_{m+1}} \\right]\\\\ &amp;+ \\mathcal{H}(m-kbp) \\left[ \\frac{\\Delta z_m}{6} (2K_m^{n+1} + K_{m-1}^{n+1} - 2K_m^n - K_{m-1}^n) - \\Delta t (\\nu_k^\\psi)_{m-\\frac{1}{2}}^n \\frac{K_m^{n+1} - K_{m-1}^{n+1}}{\\Delta z_m} \\right]\\\\ &amp;= \\mathcal{H} (N_z - m) \\Delta t \\left[ \\begin{Bmatrix} \\frac{\\Delta z_m + 1}{2} (\\nu_t M^2 + \\nu_t^\\theta N^2)_{m+\\frac{1}{2}}^{n}\\\\ \\frac{\\Delta z_{m+1}}{2} (\\nu_t M^2 + \\nu_t^\\theta N^2)_{m+\\frac{1}{2}}^{n} \\frac{2K_m^{n+1} + K_{m+1}^{n+1}}{K_{m+\\frac{1}{2}}^{n}} \\end{Bmatrix} - (c_\\mu^0)^3 (K^{0.5} l^{-1})_{m+\\frac{1}{2}}^{n} \\frac{\\Delta z_{m+1}}{6} (2K_m^{n+1} + K_{m+1}^{n+1}) \\right]\\\\ &amp;+ \\mathcal{H}(m-kbp)\\Delta t \\left[ \\begin{Bmatrix} \\frac{\\Delta z_m}{2} (\\nu_t M^2 + \\nu_t^\\theta N^2)_{m-\\frac{1}{2}}^{n}\\\\ \\frac{\\Delta z_m}{2} (\\nu_t M^2 + \\nu_t^\\theta N^2)_{m-\\frac{1}{2}}^{n} \\frac{2K_m^{n+1} + K_{m-1}^{n+1}}{K_{m-\\frac{1}{2}}^{n}}\\end{Bmatrix} - (c_\\mu^0)^3 (K^{0.5}l^{-1})_{m-\\frac{1}{2}}^{n} \\frac{\\Delta z_m}{6} (2K_m^{n+1} + K_{m-1}^{n+1}) \\right] , (l = kbp, \\cdots, N_z) \\end{aligned} \\end{equation}\\] \\[\\begin{equation} \\label{eq08} \\begin{aligned} &amp;\\mathcal{H}(N_z - m) \\left[ \\frac{\\Delta z_{m+1}}{6} (2\\psi^{n+1}_{m} + \\psi_{m+1}^{n+1} - 2\\psi_m^n - \\psi_{m+1}^{n}) - \\Delta t (\\nu_\\psi)_{m+\\frac{1}{2}}^{n} \\frac{\\psi_{m+1}^{n+1} - \\psi_{m}^{n+1}}{\\Delta z_{m+1}} \\right]\\\\ &amp;+ \\mathcal{H}(m-kbp) \\left[ \\frac{\\Delta z_{m+1}}{6} (2\\psi_m^{n+1} + \\psi_{m-1}^{n+1} -2\\psi_m^n - \\psi_{m-1}^n) - \\Delta t (\\nu_\\psi)_{m-\\frac{1}{2}}^n \\frac{\\psi_m^{n+1} - \\psi_{m-1}^{n+1}}{\\Delta z_m} \\right]\\\\ &amp;+ \\kappa_0 n \\Delta t \\left[ \\delta_{m, N_z} \\left(\\frac{\\nu_\\psi}{l}\\right)_{N_z}^n \\psi_{N_z}^{n+1} + \\delta_{m, kbp} \\left( \\frac{\\nu_\\psi}{l} \\right)_{kbp}^n \\psi_{kbp}^{n+1} \\right]\\\\ &amp;= \\mathcal{H}(N_z - m) \\Delta t \\left[ \\begin{Bmatrix} \\frac{\\Delta z_{m+1}}{2} (c_{\\psi 1} \\nu_t M^2 + c_{\\psi 3} \\nu_t^\\theta N^2)_{m+\\frac{1}{2}}^{n} \\left(\\frac{\\psi}{K}\\right)_{m+\\frac{1}{2}}^{n} \\\\ \\frac{\\Delta z_{m+1}}{2} \\left( \\nu_t M^2 + \\nu_t^\\theta N^2 \\right)_{m+\\frac{1}{2}}^n \\frac{2\\psi_m^{n+1} + \\psi_{m+1}^{n+1}}{2K_{m+\\frac{1}{2}}^n} \\end{Bmatrix} - c_{\\psi 2} \\left( c_\\mu^0 \\right)^3 \\left(K^{0.5}l^{-1}F_w\\right)_{m+\\frac{1}{2}}^{n} \\frac{\\Delta z_{m+1}}{6} \\left( 2\\psi_m^{n+1} + \\psi_{m+1}^{n+1} \\right) \\right] \\\\ &amp;+\\mathcal{H}(m-kbp) \\Delta t \\left[ \\begin{Bmatrix} \\frac{\\Delta z_m}{2} \\left( c_{\\psi 1} \\nu_t M^2 + c_{\\psi 3} \\nu_t^\\theta N^2 \\right)_{m-\\frac{1}{2}}^{n} \\left( \\frac{\\psi}{K} \\right)_{m-\\frac{1}{2}}^{n}\\\\ \\frac{\\Delta z_m}{2} \\left( \\nu_t M^2 + \\nu_t^\\theta N^2 \\right)_{m-\\frac{1}{2}}^{n} \\frac{2\\psi_{m}^{n+1} + \\psi_{m-1}^{n+1}}{2K_{m-\\frac{1}{2}}^{n}} \\end{Bmatrix} - (c_\\mu^0)^3 \\left(K^{0.5}l^{-1}F_w\\right)_{m-\\frac{1}{2}}^{n} \\frac{\\Delta z_m}{6} \\left( 2\\psi_{m}^{n+1} + \\psi_{m-1}^{n+1} \\right) \\right], (l = kbp, \\cdots, N_z)  \\end{aligned} \\end{equation}\\] <p>where \\(\\begin{Bmatrix}\\end{Bmatrix}\\) indicates the alternative explicit/implicit schemes mentioned above, and \\(\\mathcal{H}\\) is a step function. We have applied the natural B.C. (Eqs. \\(\\ref{eq02}\\)) in these equations, and after \\(K\\) and \\(\\psi\\) are solved, the essential B.C. (Eqs \\(\\ref{eq03}\\)) is then used to overwrite the boundary values.</p> <p>References</p> <p>Umlauf, L. and H. Burchard (2003) A generic length-scale equation for geophysical turbulence models. J. Mar. Res., 6, pp. 235-265.</p>"},{"location":"schism/updating-levels.html","title":"Updating the levels/Inundation","text":"<p>After all variables are solved at the new step, the vertical grid is updated to reflect the newly solved elevations. An important aspect of this update is the treatment of inundation (wetting/drying). SCHISM supports 2 options for inundation. Note that the elevations are solved at all nodes including dry nodes at the previous time step; in other words, the elevations at the dry nodes \u2013 they are simply below the local bottom and can be thought as inactive ground water.</p> <p>The 1st option (<code>inunfl=0</code>) is the default one that should be used in most applications. It uses a simple book-keeping algorithm to mark node/side/element as wet/dry based on a threshold depth (<code>h0</code>). SCHISM does not support partial wetting and drying, and so the rule inside the code is: an element is wet if all of its nodes and sides are wet, and is dry if any of its nodes or sides becomes dry. A node/side is wet iff (if and only if) at least 1 of its surrounding element is wet. For newly rewetted element/node/side, some state variables may be re-initialized based wet neighbors.</p> <p>The 2nd option (<code>inunfl=1</code>) uses a shoreline tracking algorithm which requires finer resolution to be effective; otherwise the extrapolation procedure below may over-predict the inundation. In realistic cases, &lt;5m resolution is usually sufficient for this purpose. Starting from the shoreline position at step \\(n\\), each node on this line is checked for wetting and drying, and the local portion of the line is updated accordingly (Figure 1). The process is iterative and multi-layer wetting and drying is possible. After the new shoreline position is found at step \\(n+1\\),a constant extrapolation of surface elevation is used from this position projected onto the nearest \u2018dry\u2019 node, in order to enhance the stability of the wetting and drying front (a technique advocated by the tsunami MOST model).</p> <p></p> Shoreline tracking algorithm. (a) The orange line is the shoreline from step n, and the light blue line is the updated portion since A is wetted and B becomes dry at step n+1. (b) At the end of the tracking, constant extrapolation of elevation is used at the new shoreline position, which may flood the next dry node."},{"location":"schism/vertical-velocity.html","title":"Vertical velocity","text":"<p>The vertical velocity serves as a diagnostic variable for local volume conservation<sup>1</sup>, but is a physically important quantity, especially when a steep slope is present (Zhang et al. 2004). To solve the vertical velocity, we apply a finite-volume method to a typical prism, as depicted in Figure 6, assuming that \\(w\\) is constant within an element \\(i\\), and obtain - </p> \\[\\begin{equation} \\label{eq01} \\hat{S}_{k+1} \\left( \\overline{u}_{k+1}^{n+1} n_{k+1}^{x} + \\overline{v}_{k+1}^{n+1} n_{k+1}^{y} + w_{i, k+1}^{n+1} n_{k+1}^{z} \\right) - \\hat{S}_{k} \\left( \\overline{u}_{k}^{n+1} n_{k}^{x} + \\overline{v}_{k}^{n+1} n_{k}^{y} + w_{i, k}^{n+1} n_{k}^{z} \\right) + \\sum_{m=1}^{3} \\hat{P}_{js(i, m)} \\left( \\hat{q}_{js(i, m), k}^{n+1} + \\hat{q}_{js(i, m), k+1}^{n+1}  \\right)/2 = 0, (k=k^b, \\cdots, N_z - 1) \\end{equation}\\] <p>where \\(\\hat{S}\\) and \\(\\hat{P}\\) are the areas of the prism surfaces (Figure 6), (\\(n^x, n^y, n^z\\)), are the normal vector (pointing upward), \\(\\overline{u}\\) and \\(\\overline{v}\\) the averaged horizontal velocities at the top and bottom surfaces, and \\(\\hat{q}\\) is the outward normal velocity at each side center. The vertical velocity is then solved from the bottom to the surface, in conjunction with the bottom boundary condition \\((u, v, q)\\cdot\\pmb{n}=0\\). In the case of earthquake module (<code>imm\u22600</code>), the bed velocity is prescribed. A compact form for Eqs \\(\\ref{eq01}\\) is \\(\\sum_{j\\epsilon S^+} \\left| Q_j\\right| = \\sum_{j\\epsilon S^-} \\left| Q_j\\right|\\), where \\(Q_j\\) is the facial fluxes outward of a prism \\(i\\). This conservation will be utilized in the transport equation as the foundation for mass conservation and constancy.</p> <p>References Zhang, Y., Baptista, A.M. and Myers, E.P. (2004) \"A cross-scale model for 3D baroclinic circulation in estuary-plume-shelf systems: I. Formulation and skill assessment\". Cont. Shelf Res., 24: 2187-2214.</p> <ol> <li> <p>Although other definitions of volume/mass exist, we define volume/mass in the finite-volume sense throughout this paper and measure conservation based on this definition.\u00a0\u21a9</p> </li> </ol>"}]}